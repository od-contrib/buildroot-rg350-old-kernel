diff --git a/attic/Makefile.inc b/attic/Makefile.inc
index 3e898c2..512e163 100644
--- a/attic/Makefile.inc
+++ b/attic/Makefile.inc
@@ -1,5 +1,5 @@
 ifndef GCABI
-$(error GCABI is undefined. Consult the README.md file to set it according to your kernel)
+#$(error GCABI is undefined. Consult the README.md file to set it according to your kernel)
 endif
 
 PLATFORM_GL_LIBS ?= -lEGL -lGLESv2
@@ -9,7 +9,7 @@ CXX = $(GCCPREFIX)g++
 LD = $(GCCPREFIX)ld
 AR = $(GCCPREFIX)ar
 
-GCC_CFLAGS = -D_POSIX_C_SOURCE=200809 -D_GNU_SOURCE
+GCC_CFLAGS = -D_POSIX_C_SOURCE=200809 -D_GNU_SOURCE -I../../src
 COMMON_FLAGS = -O2 -g3 -ggdb3 -Wall -Wmissing-prototypes \
           -DGCABI_${GCABI} $(GCC_CFLAGS) -I$(TOP)/lib -I$(TOP)/galcore_headers/include_$(GCABI) \
           -fPIC -pthread \
diff --git a/attic/driver/etna_rasterizer.h b/attic/driver/etna_rasterizer.h
index 0574391..3744fdc 100644
--- a/attic/driver/etna_rasterizer.h
+++ b/attic/driver/etna_rasterizer.h
@@ -28,5 +28,8 @@ struct pipe_context;
 
 void etna_pipe_rasterizer_init(struct pipe_context *pipe);
 
+#define VIVS_PA_SYSTEM_MODE_UNK0  0x00000001
+#define VIVS_PA_SYSTEM_MODE_UNK4  0x00000010
+
 #endif
 
diff --git a/attic/gc_abi.h b/attic/gc_abi.h
new file mode 100644
index 0000000..d04a79a
--- /dev/null
+++ b/attic/gc_abi.h
@@ -0,0 +1,54 @@
+/*
+ * Copyright (c) 2012-2013 Etnaviv Project
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sub license,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice (including the
+ * next paragraph) shall be included in all copies or substantial portions
+ * of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ */
+/** Kernel ABI definition file for Etna **/
+#ifndef H_GCABI
+#define H_GCABI
+//#define GCABI_USER_SIGNAL_HAS_TYPE
+//#define GCABI_CONTEXT_HAS_PHYSICAL
+#define GCABI_HAS_MINOR_FEATURES_2
+#define GCABI_HAS_MINOR_FEATURES_3
+
+#define GCABI_CHIPIDENTITY_EXT
+
+// One of these must be set:
+//#define GCABI_HAS_CONTEXT
+#define GCABI_HAS_STATE_DELTAS
+
+#define GCABI_HAS_HARDWARE_TYPE
+
+/* IOCTL structure for userspace driver*/
+typedef struct 
+{
+    void *in_buf;
+    unsigned int in_buf_size;
+    void *out_buf;
+    unsigned int out_buf_size;
+} vivante_ioctl_data_t;
+
+#include "gc_hal_base.h"
+#include "gc_hal.h"
+#include "gc_hal_driver.h"
+#include "gc_hal_kernel_buffer.h"
+#include "gc_hal_types.h"
+#endif
+
diff --git a/attic/gc_hal.h b/attic/gc_hal.h
new file mode 100644
index 0000000..c87bb1e
--- /dev/null
+++ b/attic/gc_hal.h
@@ -0,0 +1,2372 @@
+/****************************************************************************
+*
+*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*
+*    This program is free software; you can redistribute it and/or modify
+*    it under the terms of the GNU General Public License as published by
+*    the Free Software Foundation; either version 2 of the license, or
+*    (at your option) any later version.
+*
+*    This program is distributed in the hope that it will be useful,
+*    but WITHOUT ANY WARRANTY; without even the implied warranty of
+*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+*    GNU General Public License for more details.
+*
+*    You should have received a copy of the GNU General Public License
+*    along with this program; if not write to the Free Software
+*    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*
+*****************************************************************************/
+
+
+
+
+#ifndef __gc_hal_h_
+#define __gc_hal_h_
+
+#include "gc_hal_rename.h"
+#include "gc_hal_types.h"
+#include "gc_hal_enum.h"
+#include "gc_hal_base.h"
+#include "gc_hal_profiler.h"
+#include "gc_hal_driver.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/******************************************************************************\
+******************************* Alignment Macros *******************************
+\******************************************************************************/
+
+#define gcmALIGN(n, align) \
+( \
+    ((n) + ((align) - 1)) & ~((align) - 1) \
+)
+
+#define gcmALIGN_BASE(n, align) \
+( \
+    (n) & ~((align) - 1) \
+)
+
+/******************************************************************************\
+***************************** Element Count Macro *****************************
+\******************************************************************************/
+
+#define gcmSIZEOF(a) \
+( \
+    (gctSIZE_T) (sizeof(a)) \
+)
+
+#define gcmCOUNTOF(a) \
+( \
+    sizeof(a) / sizeof(a[0]) \
+)
+
+/******************************************************************************\
+******************************** gcsOBJECT Object *******************************
+\******************************************************************************/
+
+/* Type of objects. */
+typedef enum _gceOBJECT_TYPE
+{
+    gcvOBJ_UNKNOWN              = 0,
+    gcvOBJ_2D                   = gcmCC('2','D',' ',' '),
+    gcvOBJ_3D                   = gcmCC('3','D',' ',' '),
+    gcvOBJ_ATTRIBUTE            = gcmCC('A','T','T','R'),
+    gcvOBJ_BRUSHCACHE           = gcmCC('B','R','U','$'),
+    gcvOBJ_BRUSHNODE            = gcmCC('B','R','U','n'),
+    gcvOBJ_BRUSH                = gcmCC('B','R','U','o'),
+    gcvOBJ_BUFFER               = gcmCC('B','U','F','R'),
+    gcvOBJ_COMMAND              = gcmCC('C','M','D',' '),
+    gcvOBJ_COMMANDBUFFER        = gcmCC('C','M','D','B'),
+    gcvOBJ_CONTEXT              = gcmCC('C','T','X','T'),
+    gcvOBJ_DEVICE               = gcmCC('D','E','V',' '),
+    gcvOBJ_DUMP                 = gcmCC('D','U','M','P'),
+    gcvOBJ_EVENT                = gcmCC('E','V','N','T'),
+    gcvOBJ_FUNCTION             = gcmCC('F','U','N','C'),
+    gcvOBJ_HAL                  = gcmCC('H','A','L',' '),
+    gcvOBJ_HARDWARE             = gcmCC('H','A','R','D'),
+    gcvOBJ_HEAP                 = gcmCC('H','E','A','P'),
+    gcvOBJ_INDEX                = gcmCC('I','N','D','X'),
+    gcvOBJ_INTERRUPT            = gcmCC('I','N','T','R'),
+    gcvOBJ_KERNEL               = gcmCC('K','E','R','N'),
+    gcvOBJ_KERNEL_FUNCTION      = gcmCC('K','F','C','N'),
+    gcvOBJ_MEMORYBUFFER         = gcmCC('M','E','M','B'),
+    gcvOBJ_MMU                  = gcmCC('M','M','U',' '),
+    gcvOBJ_OS                   = gcmCC('O','S',' ',' '),
+    gcvOBJ_OUTPUT               = gcmCC('O','U','T','P'),
+    gcvOBJ_PAINT                = gcmCC('P','N','T',' '),
+    gcvOBJ_PATH                 = gcmCC('P','A','T','H'),
+    gcvOBJ_QUEUE                = gcmCC('Q','U','E',' '),
+    gcvOBJ_SAMPLER              = gcmCC('S','A','M','P'),
+    gcvOBJ_SHADER               = gcmCC('S','H','D','R'),
+    gcvOBJ_STREAM               = gcmCC('S','T','R','M'),
+    gcvOBJ_SURF                 = gcmCC('S','U','R','F'),
+    gcvOBJ_TEXTURE              = gcmCC('T','X','T','R'),
+    gcvOBJ_UNIFORM              = gcmCC('U','N','I','F'),
+    gcvOBJ_VARIABLE             = gcmCC('V','A','R','I'),
+    gcvOBJ_VERTEX               = gcmCC('V','R','T','X'),
+    gcvOBJ_VIDMEM               = gcmCC('V','M','E','M'),
+    gcvOBJ_VG                   = gcmCC('V','G',' ',' '),
+}
+gceOBJECT_TYPE;
+
+/* gcsOBJECT object defintinon. */
+typedef struct _gcsOBJECT
+{
+    /* Type of an object. */
+    gceOBJECT_TYPE              type;
+}
+gcsOBJECT;
+
+typedef struct _gckHARDWARE *       gckHARDWARE;
+
+/* CORE flags. */
+typedef enum _gceCORE
+{
+    gcvCORE_MAJOR       = 0x0,
+    gcvCORE_2D          = 0x1,
+    gcvCORE_VG          = 0x2
+}
+gceCORE;
+
+#define gcdCORE_COUNT               3
+
+/*******************************************************************************
+**
+**  gcmVERIFY_OBJECT
+**
+**      Assert if an object is invalid or is not of the specified type.  If the
+**      object is invalid or not of the specified type, gcvSTATUS_INVALID_OBJECT
+**      will be returned from the current function.  In retail mode this macro
+**      does nothing.
+**
+**  ARGUMENTS:
+**
+**      obj     Object to test.
+**      t       Expected type of the object.
+*/
+#if gcmIS_DEBUG(gcdDEBUG_TRACE)
+#define _gcmVERIFY_OBJECT(prefix, obj, t) \
+    if ((obj) == gcvNULL) \
+    { \
+        prefix##TRACE(gcvLEVEL_ERROR, \
+                      #prefix "VERIFY_OBJECT failed: NULL"); \
+        prefix##TRACE(gcvLEVEL_ERROR, "  expected: %c%c%c%c", \
+                      gcmCC_PRINT(t)); \
+        prefix##ASSERT((obj) != gcvNULL); \
+        prefix##FOOTER_ARG("status=%d", gcvSTATUS_INVALID_OBJECT); \
+        return gcvSTATUS_INVALID_OBJECT; \
+    } \
+    else if (((gcsOBJECT*) (obj))->type != t) \
+    { \
+        prefix##TRACE(gcvLEVEL_ERROR, \
+                      #prefix "VERIFY_OBJECT failed: %c%c%c%c", \
+                      gcmCC_PRINT(((gcsOBJECT*) (obj))->type)); \
+        prefix##TRACE(gcvLEVEL_ERROR, "  expected: %c%c%c%c", \
+                      gcmCC_PRINT(t)); \
+        prefix##ASSERT(((gcsOBJECT*)(obj))->type == t); \
+        prefix##FOOTER_ARG("status=%d", gcvSTATUS_INVALID_OBJECT); \
+        return gcvSTATUS_INVALID_OBJECT; \
+    }
+
+#   define gcmVERIFY_OBJECT(obj, t)     _gcmVERIFY_OBJECT(gcm, obj, t)
+#   define gcmkVERIFY_OBJECT(obj, t)    _gcmVERIFY_OBJECT(gcmk, obj, t)
+#else
+#   define gcmVERIFY_OBJECT(obj, t)     do {} while (gcvFALSE)
+#   define gcmkVERIFY_OBJECT(obj, t)    do {} while (gcvFALSE)
+#endif
+
+/******************************************************************************/
+/*VERIFY_OBJECT if special return expected*/
+/******************************************************************************/
+#ifndef EGL_API_ANDROID
+#   define _gcmVERIFY_OBJECT_RETURN(prefix, obj, t, retVal) \
+        do \
+        { \
+            if ((obj) == gcvNULL) \
+            { \
+                prefix##PRINT_VERSION(); \
+                prefix##TRACE(gcvLEVEL_ERROR, \
+                              #prefix "VERIFY_OBJECT_RETURN failed: NULL"); \
+                prefix##TRACE(gcvLEVEL_ERROR, "  expected: %c%c%c%c", \
+                              gcmCC_PRINT(t)); \
+                prefix##ASSERT((obj) != gcvNULL); \
+                prefix##FOOTER_ARG("retVal=%d", retVal); \
+                return retVal; \
+            } \
+            else if (((gcsOBJECT*) (obj))->type != t) \
+            { \
+                prefix##PRINT_VERSION(); \
+                prefix##TRACE(gcvLEVEL_ERROR, \
+                              #prefix "VERIFY_OBJECT_RETURN failed: %c%c%c%c", \
+                              gcmCC_PRINT(((gcsOBJECT*) (obj))->type)); \
+                prefix##TRACE(gcvLEVEL_ERROR, "  expected: %c%c%c%c", \
+                              gcmCC_PRINT(t)); \
+                prefix##ASSERT(((gcsOBJECT*)(obj))->type == t); \
+                prefix##FOOTER_ARG("retVal=%d", retVal); \
+                return retVal; \
+            } \
+        } \
+        while (gcvFALSE)
+#   define gcmVERIFY_OBJECT_RETURN(obj, t, retVal) \
+                            _gcmVERIFY_OBJECT_RETURN(gcm, obj, t, retVal)
+#   define gcmkVERIFY_OBJECT_RETURN(obj, t, retVal) \
+                            _gcmVERIFY_OBJECT_RETURN(gcmk, obj, t, retVal)
+#else
+#   define gcmVERIFY_OBJECT_RETURN(obj, t)     do {} while (gcvFALSE)
+#   define gcmVERIFY_OBJECT_RETURN(obj, t)    do {} while (gcvFALSE)
+#endif
+
+/******************************************************************************\
+********************************** gckOS Object *********************************
+\******************************************************************************/
+
+/* Construct a new gckOS object. */
+gceSTATUS
+gckOS_Construct(
+    IN gctPOINTER Context,
+    OUT gckOS * Os
+    );
+
+/* Destroy an gckOS object. */
+gceSTATUS
+gckOS_Destroy(
+    IN gckOS Os
+    );
+
+/* Query the video memory. */
+gceSTATUS
+gckOS_QueryVideoMemory(
+    IN gckOS Os,
+    OUT gctPHYS_ADDR * InternalAddress,
+    OUT gctSIZE_T * InternalSize,
+    OUT gctPHYS_ADDR * ExternalAddress,
+    OUT gctSIZE_T * ExternalSize,
+    OUT gctPHYS_ADDR * ContiguousAddress,
+    OUT gctSIZE_T * ContiguousSize
+    );
+
+/* Allocate memory from the heap. */
+gceSTATUS
+gckOS_Allocate(
+    IN gckOS Os,
+    IN gctSIZE_T Bytes,
+    OUT gctPOINTER * Memory
+    );
+
+/* Free allocated memory. */
+gceSTATUS
+gckOS_Free(
+    IN gckOS Os,
+    IN gctPOINTER Memory
+    );
+
+/* Wrapper for allocation memory.. */
+gceSTATUS
+gckOS_AllocateMemory(
+    IN gckOS Os,
+    IN gctSIZE_T Bytes,
+    OUT gctPOINTER * Memory
+    );
+
+/* Wrapper for freeing memory. */
+gceSTATUS
+gckOS_FreeMemory(
+    IN gckOS Os,
+    IN gctPOINTER Memory
+    );
+
+/* Allocate paged memory. */
+gceSTATUS
+gckOS_AllocatePagedMemory(
+    IN gckOS Os,
+    IN gctSIZE_T Bytes,
+    OUT gctPHYS_ADDR * Physical
+    );
+
+/* Allocate paged memory. */
+gceSTATUS
+gckOS_AllocatePagedMemoryEx(
+    IN gckOS Os,
+    IN gctBOOL Contiguous,
+    IN gctSIZE_T Bytes,
+    OUT gctPHYS_ADDR * Physical
+    );
+
+/* Lock pages. */
+gceSTATUS
+gckOS_LockPages(
+    IN gckOS Os,
+    IN gctPHYS_ADDR Physical,
+    IN gctSIZE_T Bytes,
+    IN gctBOOL Cacheable,
+    OUT gctPOINTER * Logical,
+    OUT gctSIZE_T * PageCount
+    );
+
+/* Map pages. */
+gceSTATUS
+gckOS_MapPages(
+    IN gckOS Os,
+    IN gctPHYS_ADDR Physical,
+#ifdef __QNXNTO__
+    IN gctPOINTER Logical,
+#endif
+    IN gctSIZE_T PageCount,
+    IN gctPOINTER PageTable
+    );
+
+/* Map pages. */
+gceSTATUS
+gckOS_MapPagesEx(
+    IN gckOS Os,
+    IN gceCORE Core,
+    IN gctPHYS_ADDR Physical,
+#ifdef __QNXNTO__
+    IN gctPOINTER Logical,
+#endif
+    IN gctSIZE_T PageCount,
+    IN gctPOINTER PageTable
+    );
+
+/* Unlock pages. */
+gceSTATUS
+gckOS_UnlockPages(
+    IN gckOS Os,
+    IN gctPHYS_ADDR Physical,
+    IN gctSIZE_T Bytes,
+    IN gctPOINTER Logical
+    );
+
+/* Free paged memory. */
+gceSTATUS
+gckOS_FreePagedMemory(
+    IN gckOS Os,
+    IN gctPHYS_ADDR Physical,
+    IN gctSIZE_T Bytes
+    );
+
+/* Allocate non-paged memory. */
+gceSTATUS
+gckOS_AllocateNonPagedMemory(
+    IN gckOS Os,
+    IN gctBOOL InUserSpace,
+    IN OUT gctSIZE_T * Bytes,
+    OUT gctPHYS_ADDR * Physical,
+    OUT gctPOINTER * Logical
+    );
+
+/* Free non-paged memory. */
+gceSTATUS
+gckOS_FreeNonPagedMemory(
+    IN gckOS Os,
+    IN gctSIZE_T Bytes,
+    IN gctPHYS_ADDR Physical,
+    IN gctPOINTER Logical
+    );
+
+/* Allocate contiguous memory. */
+gceSTATUS
+gckOS_AllocateContiguous(
+    IN gckOS Os,
+    IN gctBOOL InUserSpace,
+    IN OUT gctSIZE_T * Bytes,
+    OUT gctPHYS_ADDR * Physical,
+    OUT gctPOINTER * Logical
+    );
+
+/* Free contiguous memory. */
+gceSTATUS
+gckOS_FreeContiguous(
+    IN gckOS Os,
+    IN gctPHYS_ADDR Physical,
+    IN gctPOINTER Logical,
+    IN gctSIZE_T Bytes
+    );
+
+/* Get the number fo bytes per page. */
+gceSTATUS
+gckOS_GetPageSize(
+    IN gckOS Os,
+    OUT gctSIZE_T * PageSize
+    );
+
+/* Get the physical address of a corresponding logical address. */
+gceSTATUS
+gckOS_GetPhysicalAddress(
+    IN gckOS Os,
+    IN gctPOINTER Logical,
+    OUT gctUINT32 * Address
+    );
+
+/* Get the physical address of a corresponding logical address. */
+gceSTATUS
+gckOS_GetPhysicalAddressProcess(
+    IN gckOS Os,
+    IN gctPOINTER Logical,
+    IN gctUINT32 ProcessID,
+    OUT gctUINT32 * Address
+    );
+
+/* Map physical memory. */
+gceSTATUS
+gckOS_MapPhysical(
+    IN gckOS Os,
+    IN gctUINT32 Physical,
+    IN gctSIZE_T Bytes,
+    OUT gctPOINTER * Logical
+    );
+
+/* Unmap previously mapped physical memory. */
+gceSTATUS
+gckOS_UnmapPhysical(
+    IN gckOS Os,
+    IN gctPOINTER Logical,
+    IN gctSIZE_T Bytes
+    );
+
+/* Read data from a hardware register. */
+gceSTATUS
+gckOS_ReadRegister(
+    IN gckOS Os,
+    IN gctUINT32 Address,
+    OUT gctUINT32 * Data
+    );
+
+/* Read data from a hardware register. */
+gceSTATUS
+gckOS_ReadRegisterEx(
+    IN gckOS Os,
+    IN gceCORE Core,
+    IN gctUINT32 Address,
+    OUT gctUINT32 * Data
+    );
+
+/* Write data to a hardware register. */
+gceSTATUS
+gckOS_WriteRegister(
+    IN gckOS Os,
+    IN gctUINT32 Address,
+    IN gctUINT32 Data
+    );
+
+/* Write data to a hardware register. */
+gceSTATUS
+gckOS_WriteRegisterEx(
+    IN gckOS Os,
+    IN gceCORE Core,
+    IN gctUINT32 Address,
+    IN gctUINT32 Data
+    );
+
+/* Write data to a 32-bit memory location. */
+gceSTATUS
+gckOS_WriteMemory(
+    IN gckOS Os,
+    IN gctPOINTER Address,
+    IN gctUINT32 Data
+    );
+
+/* Map physical memory into the process space. */
+gceSTATUS
+gckOS_MapMemory(
+    IN gckOS Os,
+    IN gctPHYS_ADDR Physical,
+    IN gctSIZE_T Bytes,
+    OUT gctPOINTER * Logical
+    );
+
+/* Unmap physical memory from the specified process space. */
+gceSTATUS
+gckOS_UnmapMemoryEx(
+    IN gckOS Os,
+    IN gctPHYS_ADDR Physical,
+    IN gctSIZE_T Bytes,
+    IN gctPOINTER Logical,
+    IN gctUINT32 PID
+    );
+
+/* Unmap physical memory from the process space. */
+gceSTATUS
+gckOS_UnmapMemory(
+    IN gckOS Os,
+    IN gctPHYS_ADDR Physical,
+    IN gctSIZE_T Bytes,
+    IN gctPOINTER Logical
+    );
+
+/* Create a new mutex. */
+gceSTATUS
+gckOS_CreateMutex(
+    IN gckOS Os,
+    OUT gctPOINTER * Mutex
+    );
+
+/* Delete a mutex. */
+gceSTATUS
+gckOS_DeleteMutex(
+    IN gckOS Os,
+    IN gctPOINTER Mutex
+    );
+
+/* Acquire a mutex. */
+gceSTATUS
+gckOS_AcquireMutex(
+    IN gckOS Os,
+    IN gctPOINTER Mutex,
+    IN gctUINT32 Timeout
+    );
+
+/* Release a mutex. */
+gceSTATUS
+gckOS_ReleaseMutex(
+    IN gckOS Os,
+    IN gctPOINTER Mutex
+    );
+
+/* Atomically exchange a pair of 32-bit values. */
+gceSTATUS
+gckOS_AtomicExchange(
+    IN gckOS Os,
+    IN OUT gctUINT32_PTR Target,
+    IN gctUINT32 NewValue,
+    OUT gctUINT32_PTR OldValue
+    );
+
+/* Atomically exchange a pair of pointers. */
+gceSTATUS
+gckOS_AtomicExchangePtr(
+    IN gckOS Os,
+    IN OUT gctPOINTER * Target,
+    IN gctPOINTER NewValue,
+    OUT gctPOINTER * OldValue
+    );
+
+#if gcdSMP
+gceSTATUS
+gckOS_AtomSetMask(
+    IN gctPOINTER Atom,
+    IN gctUINT32 Mask
+    );
+
+gceSTATUS
+gckOS_AtomClearMask(
+    IN gctPOINTER Atom,
+    IN gctUINT32 Mask
+    );
+#endif
+
+gceSTATUS
+gckOS_DumpGPUState(
+    IN gckOS Os,
+    IN gceCORE Core
+    );
+
+/*******************************************************************************
+**
+**  gckOS_AtomConstruct
+**
+**  Create an atom.
+**
+**  INPUT:
+**
+**      gckOS Os
+**          Pointer to a gckOS object.
+**
+**  OUTPUT:
+**
+**      gctPOINTER * Atom
+**          Pointer to a variable receiving the constructed atom.
+*/
+gceSTATUS
+gckOS_AtomConstruct(
+    IN gckOS Os,
+    OUT gctPOINTER * Atom
+    );
+
+/*******************************************************************************
+**
+**  gckOS_AtomDestroy
+**
+**  Destroy an atom.
+**
+**  INPUT:
+**
+**      gckOS Os
+**          Pointer to a gckOS object.
+**
+**      gctPOINTER Atom
+**          Pointer to the atom to destroy.
+**
+**  OUTPUT:
+**
+**      Nothing.
+*/
+gceSTATUS
+gckOS_AtomDestroy(
+    IN gckOS Os,
+    OUT gctPOINTER Atom
+    );
+
+/*******************************************************************************
+**
+**  gckOS_AtomGet
+**
+**  Get the 32-bit value protected by an atom.
+**
+**  INPUT:
+**
+**      gckOS Os
+**          Pointer to a gckOS object.
+**
+**      gctPOINTER Atom
+**          Pointer to the atom.
+**
+**  OUTPUT:
+**
+**      gctINT32_PTR Value
+**          Pointer to a variable the receives the value of the atom.
+*/
+gceSTATUS
+gckOS_AtomGet(
+    IN gckOS Os,
+    IN gctPOINTER Atom,
+    OUT gctINT32_PTR Value
+    );
+
+/*******************************************************************************
+**
+**  gckOS_AtomSet
+**
+**  Set the 32-bit value protected by an atom.
+**
+**  INPUT:
+**
+**      gckOS Os
+**          Pointer to a gckOS object.
+**
+**      gctPOINTER Atom
+**          Pointer to the atom.
+**
+**      gctINT32 Value
+**          The value of the atom.
+**
+**  OUTPUT:
+**
+**      Nothing.
+*/
+gceSTATUS
+gckOS_AtomSet(
+    IN gckOS Os,
+    IN gctPOINTER Atom,
+    IN gctINT32 Value
+    );
+
+/*******************************************************************************
+**
+**  gckOS_AtomIncrement
+**
+**  Atomically increment the 32-bit integer value inside an atom.
+**
+**  INPUT:
+**
+**      gckOS Os
+**          Pointer to a gckOS object.
+**
+**      gctPOINTER Atom
+**          Pointer to the atom.
+**
+**  OUTPUT:
+**
+**      gctINT32_PTR Value
+**          Pointer to a variable the receives the original value of the atom.
+*/
+gceSTATUS
+gckOS_AtomIncrement(
+    IN gckOS Os,
+    IN gctPOINTER Atom,
+    OUT gctINT32_PTR Value
+    );
+
+/*******************************************************************************
+**
+**  gckOS_AtomDecrement
+**
+**  Atomically decrement the 32-bit integer value inside an atom.
+**
+**  INPUT:
+**
+**      gckOS Os
+**          Pointer to a gckOS object.
+**
+**      gctPOINTER Atom
+**          Pointer to the atom.
+**
+**  OUTPUT:
+**
+**      gctINT32_PTR Value
+**          Pointer to a variable the receives the original value of the atom.
+*/
+gceSTATUS
+gckOS_AtomDecrement(
+    IN gckOS Os,
+    IN gctPOINTER Atom,
+    OUT gctINT32_PTR Value
+    );
+
+/* Delay a number of microseconds. */
+gceSTATUS
+gckOS_Delay(
+    IN gckOS Os,
+    IN gctUINT32 Delay
+    );
+
+/* Get time in milliseconds. */
+gceSTATUS
+gckOS_GetTicks(
+    OUT gctUINT32_PTR Time
+    );
+
+/* Compare time value. */
+gceSTATUS
+gckOS_TicksAfter(
+    IN gctUINT32 Time1,
+    IN gctUINT32 Time2,
+    OUT gctBOOL_PTR IsAfter
+    );
+
+/* Get time in microseconds. */
+gceSTATUS
+gckOS_GetTime(
+    OUT gctUINT64_PTR Time
+    );
+
+/* Memory barrier. */
+gceSTATUS
+gckOS_MemoryBarrier(
+    IN gckOS Os,
+    IN gctPOINTER Address
+    );
+
+/* Map user pointer. */
+gceSTATUS
+gckOS_MapUserPointer(
+    IN gckOS Os,
+    IN gctPOINTER Pointer,
+    IN gctSIZE_T Size,
+    OUT gctPOINTER * KernelPointer
+    );
+
+/* Unmap user pointer. */
+gceSTATUS
+gckOS_UnmapUserPointer(
+    IN gckOS Os,
+    IN gctPOINTER Pointer,
+    IN gctSIZE_T Size,
+    IN gctPOINTER KernelPointer
+    );
+
+/*******************************************************************************
+**
+**  gckOS_QueryNeedCopy
+**
+**  Query whether the memory can be accessed or mapped directly or it has to be
+**  copied.
+**
+**  INPUT:
+**
+**      gckOS Os
+**          Pointer to an gckOS object.
+**
+**      gctUINT32 ProcessID
+**          Process ID of the current process.
+**
+**  OUTPUT:
+**
+**      gctBOOL_PTR NeedCopy
+**          Pointer to a boolean receiving gcvTRUE if the memory needs a copy or
+**          gcvFALSE if the memory can be accessed or mapped dircetly.
+*/
+gceSTATUS
+gckOS_QueryNeedCopy(
+    IN gckOS Os,
+    IN gctUINT32 ProcessID,
+    OUT gctBOOL_PTR NeedCopy
+    );
+
+/*******************************************************************************
+**
+**  gckOS_CopyFromUserData
+**
+**  Copy data from user to kernel memory.
+**
+**  INPUT:
+**
+**      gckOS Os
+**          Pointer to an gckOS object.
+**
+**      gctPOINTER KernelPointer
+**          Pointer to kernel memory.
+**
+**      gctPOINTER Pointer
+**          Pointer to user memory.
+**
+**      gctSIZE_T Size
+**          Number of bytes to copy.
+**
+**  OUTPUT:
+**
+**      Nothing.
+*/
+gceSTATUS
+gckOS_CopyFromUserData(
+    IN gckOS Os,
+    IN gctPOINTER KernelPointer,
+    IN gctPOINTER Pointer,
+    IN gctSIZE_T Size
+    );
+
+/*******************************************************************************
+**
+**  gckOS_CopyToUserData
+**
+**  Copy data from kernel to user memory.
+**
+**  INPUT:
+**
+**      gckOS Os
+**          Pointer to an gckOS object.
+**
+**      gctPOINTER KernelPointer
+**          Pointer to kernel memory.
+**
+**      gctPOINTER Pointer
+**          Pointer to user memory.
+**
+**      gctSIZE_T Size
+**          Number of bytes to copy.
+**
+**  OUTPUT:
+**
+**      Nothing.
+*/
+gceSTATUS
+gckOS_CopyToUserData(
+    IN gckOS Os,
+    IN gctPOINTER KernelPointer,
+    IN gctPOINTER Pointer,
+    IN gctSIZE_T Size
+    );
+
+#ifdef __QNXNTO__
+/* Map user physical address. */
+gceSTATUS
+gckOS_MapUserPhysical(
+    IN gckOS Os,
+    IN gctPHYS_ADDR Phys,
+    OUT gctPOINTER * KernelPointer
+    );
+#endif
+
+gceSTATUS
+gckOS_SuspendInterrupt(
+    IN gckOS Os
+    );
+
+gceSTATUS
+gckOS_SuspendInterruptEx(
+    IN gckOS Os,
+    IN gceCORE Core
+    );
+
+gceSTATUS
+gckOS_ResumeInterrupt(
+    IN gckOS Os
+    );
+
+gceSTATUS
+gckOS_ResumeInterruptEx(
+    IN gckOS Os,
+    IN gceCORE Core
+    );
+
+/* Get the base address for the physical memory. */
+gceSTATUS
+gckOS_GetBaseAddress(
+    IN gckOS Os,
+    OUT gctUINT32_PTR BaseAddress
+    );
+
+/* Perform a memory copy. */
+gceSTATUS
+gckOS_MemCopy(
+    IN gctPOINTER Destination,
+    IN gctCONST_POINTER Source,
+    IN gctSIZE_T Bytes
+    );
+
+/* Zero memory. */
+gceSTATUS
+gckOS_ZeroMemory(
+    IN gctPOINTER Memory,
+    IN gctSIZE_T Bytes
+    );
+
+/* Device I/O control to the kernel HAL layer. */
+gceSTATUS
+gckOS_DeviceControl(
+    IN gckOS Os,
+    IN gctBOOL FromUser,
+    IN gctUINT32 IoControlCode,
+    IN gctPOINTER InputBuffer,
+    IN gctSIZE_T InputBufferSize,
+    OUT gctPOINTER OutputBuffer,
+    IN gctSIZE_T OutputBufferSize
+    );
+
+/*******************************************************************************
+**
+**  gckOS_GetProcessID
+**
+**  Get current process ID.
+**
+**  INPUT:
+**
+**      Nothing.
+**
+**  OUTPUT:
+**
+**      gctUINT32_PTR ProcessID
+**          Pointer to the variable that receives the process ID.
+*/
+gceSTATUS
+gckOS_GetProcessID(
+    OUT gctUINT32_PTR ProcessID
+    );
+
+gceSTATUS
+gckOS_GetCurrentProcessID(
+    OUT gctUINT32_PTR ProcessID
+    );
+
+/*******************************************************************************
+**
+**  gckOS_GetThreadID
+**
+**  Get current thread ID.
+**
+**  INPUT:
+**
+**      Nothing.
+**
+**  OUTPUT:
+**
+**      gctUINT32_PTR ThreadID
+**          Pointer to the variable that receives the thread ID.
+*/
+gceSTATUS
+gckOS_GetThreadID(
+    OUT gctUINT32_PTR ThreadID
+    );
+
+/******************************************************************************\
+********************************** Signal Object *********************************
+\******************************************************************************/
+
+/* Create a signal. */
+gceSTATUS
+gckOS_CreateSignal(
+    IN gckOS Os,
+    IN gctBOOL ManualReset,
+    OUT gctSIGNAL * Signal
+    );
+
+/* Destroy a signal. */
+gceSTATUS
+gckOS_DestroySignal(
+    IN gckOS Os,
+    IN gctSIGNAL Signal
+    );
+
+/* Signal a signal. */
+gceSTATUS
+gckOS_Signal(
+    IN gckOS Os,
+    IN gctSIGNAL Signal,
+    IN gctBOOL State
+    );
+
+/* Wait for a signal. */
+gceSTATUS
+gckOS_WaitSignal(
+    IN gckOS Os,
+    IN gctSIGNAL Signal,
+    IN gctUINT32 Wait
+    );
+
+/* Map a user signal to the kernel space. */
+gceSTATUS
+gckOS_MapSignal(
+    IN gckOS Os,
+    IN gctSIGNAL Signal,
+    IN gctHANDLE Process,
+    OUT gctSIGNAL * MappedSignal
+    );
+
+/* Unmap a user signal */
+gceSTATUS
+gckOS_UnmapSignal(
+    IN gckOS Os,
+    IN gctSIGNAL Signal
+    );
+
+/* Map user memory. */
+gceSTATUS
+gckOS_MapUserMemory(
+    IN gckOS Os,
+    IN gctPOINTER Memory,
+    IN gctSIZE_T Size,
+    OUT gctPOINTER * Info,
+    OUT gctUINT32_PTR Address
+    );
+
+/* Map user memory. */
+gceSTATUS
+gckOS_MapUserMemoryEx(
+    IN gckOS Os,
+    IN gceCORE Core,
+    IN gctPOINTER Memory,
+    IN gctSIZE_T Size,
+    OUT gctPOINTER * Info,
+    OUT gctUINT32_PTR Address
+    );
+
+/* Unmap user memory. */
+gceSTATUS
+gckOS_UnmapUserMemory(
+    IN gckOS Os,
+    IN gctPOINTER Memory,
+    IN gctSIZE_T Size,
+    IN gctPOINTER Info,
+    IN gctUINT32 Address
+    );
+
+/* Unmap user memory. */
+gceSTATUS
+gckOS_UnmapUserMemoryEx(
+    IN gckOS Os,
+    IN gceCORE Core,
+    IN gctPOINTER Memory,
+    IN gctSIZE_T Size,
+    IN gctPOINTER Info,
+    IN gctUINT32 Address
+    );
+
+#if !USE_NEW_LINUX_SIGNAL
+/* Create signal to be used in the user space. */
+gceSTATUS
+gckOS_CreateUserSignal(
+    IN gckOS Os,
+    IN gctBOOL ManualReset,
+    OUT gctINT * SignalID
+    );
+
+/* Destroy signal used in the user space. */
+gceSTATUS
+gckOS_DestroyUserSignal(
+    IN gckOS Os,
+    IN gctINT SignalID
+    );
+
+/* Wait for signal used in the user space. */
+gceSTATUS
+gckOS_WaitUserSignal(
+    IN gckOS Os,
+    IN gctINT SignalID,
+    IN gctUINT32 Wait
+    );
+
+/* Signal a signal used in the user space. */
+gceSTATUS
+gckOS_SignalUserSignal(
+    IN gckOS Os,
+    IN gctINT SignalID,
+    IN gctBOOL State
+    );
+#endif /* USE_NEW_LINUX_SIGNAL */
+
+/* Set a signal owned by a process. */
+#if defined(__QNXNTO__)
+gceSTATUS
+gckOS_UserSignal(
+    IN gckOS Os,
+    IN gctSIGNAL Signal,
+    IN gctINT Recvid,
+    IN gctINT Coid
+    );
+#else
+gceSTATUS
+gckOS_UserSignal(
+    IN gckOS Os,
+    IN gctSIGNAL Signal,
+    IN gctHANDLE Process
+    );
+#endif
+
+/******************************************************************************\
+** Cache Support
+*/
+
+gceSTATUS
+gckOS_CacheClean(
+    gckOS Os,
+    gctUINT32 ProcessID,
+    gctPHYS_ADDR Handle,
+    gctPOINTER Physical,
+    gctPOINTER Logical,
+    gctSIZE_T Bytes
+    );
+
+gceSTATUS
+gckOS_CacheFlush(
+    gckOS Os,
+    gctUINT32 ProcessID,
+    gctPHYS_ADDR Handle,
+    gctPOINTER Physical,
+    gctPOINTER Logical,
+    gctSIZE_T Bytes
+    );
+
+gceSTATUS
+gckOS_CacheInvalidate(
+    gckOS Os,
+    gctUINT32 ProcessID,
+    gctPHYS_ADDR Handle,
+    gctPOINTER Physical,
+    gctPOINTER Logical,
+    gctSIZE_T Bytes
+    );
+
+/******************************************************************************\
+** Debug Support
+*/
+
+void
+gckOS_SetDebugLevel(
+    IN gctUINT32 Level
+    );
+
+void
+gckOS_SetDebugZone(
+    IN gctUINT32 Zone
+    );
+
+void
+gckOS_SetDebugLevelZone(
+    IN gctUINT32 Level,
+    IN gctUINT32 Zone
+    );
+
+void
+gckOS_SetDebugZones(
+    IN gctUINT32 Zones,
+    IN gctBOOL Enable
+    );
+
+void
+gckOS_SetDebugFile(
+    IN gctCONST_STRING FileName
+    );
+
+/*******************************************************************************
+** Broadcast interface.
+*/
+
+typedef enum _gceBROADCAST
+{
+    /* GPU might be idle. */
+    gcvBROADCAST_GPU_IDLE,
+
+    /* A commit is going to happen. */
+    gcvBROADCAST_GPU_COMMIT,
+
+    /* GPU seems to be stuck. */
+    gcvBROADCAST_GPU_STUCK,
+
+    /* First process gets attached. */
+    gcvBROADCAST_FIRST_PROCESS,
+
+    /* Last process gets detached. */
+    gcvBROADCAST_LAST_PROCESS,
+
+    /* AXI bus error. */
+    gcvBROADCAST_AXI_BUS_ERROR,
+}
+gceBROADCAST;
+
+gceSTATUS
+gckOS_Broadcast(
+    IN gckOS Os,
+    IN gckHARDWARE Hardware,
+    IN gceBROADCAST Reason
+    );
+
+gceSTATUS
+gckOS_BroadcastHurry(
+    IN gckOS Os,
+    IN gckHARDWARE Hardware,
+    IN gctUINT Urgency
+    );
+
+gceSTATUS
+gckOS_BroadcastCalibrateSpeed(
+    IN gckOS Os,
+    IN gckHARDWARE Hardware,
+    IN gctUINT Idle,
+    IN gctUINT Time
+    );
+
+/*******************************************************************************
+**
+**  gckOS_SetGPUPower
+**
+**  Set the power of the GPU on or off.
+**
+**  INPUT:
+**
+**      gckOS Os
+**          Pointer to a gckOS object.ß
+**
+**      gctBOOL Clock
+**          gcvTRUE to turn on the clock, or gcvFALSE to turn off the clock.
+**
+**      gctBOOL Power
+**          gcvTRUE to turn on the power, or gcvFALSE to turn off the power.
+**
+**  OUTPUT:
+**
+**      Nothing.
+*/
+gceSTATUS
+gckOS_SetGPUPower(
+    IN gckOS Os,
+    IN gctBOOL Clock,
+    IN gctBOOL Power
+    );
+
+/*******************************************************************************
+** Semaphores.
+*/
+
+/* Create a new semaphore. */
+gceSTATUS
+gckOS_CreateSemaphore(
+    IN gckOS Os,
+    OUT gctPOINTER * Semaphore
+    );
+
+#if gcdENABLE_VG
+gceSTATUS
+gckOS_CreateSemaphoreVG(
+    IN gckOS Os,
+    OUT gctPOINTER * Semaphore
+    );
+#endif
+
+/* Delete a semahore. */
+gceSTATUS
+gckOS_DestroySemaphore(
+    IN gckOS Os,
+    IN gctPOINTER Semaphore
+    );
+
+/* Acquire a semahore. */
+gceSTATUS
+gckOS_AcquireSemaphore(
+    IN gckOS Os,
+    IN gctPOINTER Semaphore
+    );
+
+/* Try to acquire a semahore. */
+gceSTATUS
+gckOS_TryAcquireSemaphore(
+    IN gckOS Os,
+    IN gctPOINTER Semaphore
+    );
+
+/* Release a semahore. */
+gceSTATUS
+gckOS_ReleaseSemaphore(
+    IN gckOS Os,
+    IN gctPOINTER Semaphore
+    );
+
+/*******************************************************************************
+** Timer API.
+*/
+
+typedef void (*gctTIMERFUNCTION)(gctPOINTER);
+
+/* Create a timer. */
+gceSTATUS
+gckOS_CreateTimer(
+    IN gckOS Os,
+    IN gctTIMERFUNCTION Function,
+    IN gctPOINTER Data,
+    OUT gctPOINTER * Timer
+    );
+
+/* Destory a timer. */
+gceSTATUS
+gckOS_DestoryTimer(
+    IN gckOS Os,
+    IN gctPOINTER Timer
+    );
+
+/* Start a timer. */
+gceSTATUS
+gckOS_StartTimer(
+    IN gckOS Os,
+    IN gctPOINTER Timer,
+    IN gctUINT32 Delay
+    );
+
+/* Stop a timer. */
+gceSTATUS
+gckOS_StopTimer(
+    IN gckOS Os,
+    IN gctPOINTER Timer
+    );
+
+/******************************************************************************\
+********************************* gckHEAP Object ********************************
+\******************************************************************************/
+
+typedef struct _gckHEAP *       gckHEAP;
+
+/* Construct a new gckHEAP object. */
+gceSTATUS
+gckHEAP_Construct(
+    IN gckOS Os,
+    IN gctSIZE_T AllocationSize,
+    OUT gckHEAP * Heap
+    );
+
+/* Destroy an gckHEAP object. */
+gceSTATUS
+gckHEAP_Destroy(
+    IN gckHEAP Heap
+    );
+
+/* Allocate memory. */
+gceSTATUS
+gckHEAP_Allocate(
+    IN gckHEAP Heap,
+    IN gctSIZE_T Bytes,
+    OUT gctPOINTER * Node
+    );
+
+/* Free memory. */
+gceSTATUS
+gckHEAP_Free(
+    IN gckHEAP Heap,
+    IN gctPOINTER Node
+    );
+
+/* Profile the heap. */
+gceSTATUS
+gckHEAP_ProfileStart(
+    IN gckHEAP Heap
+    );
+
+gceSTATUS
+gckHEAP_ProfileEnd(
+    IN gckHEAP Heap,
+    IN gctCONST_STRING Title
+    );
+
+
+/******************************************************************************\
+******************************** gckVIDMEM Object ******************************
+\******************************************************************************/
+
+typedef struct _gckVIDMEM *         gckVIDMEM;
+typedef struct _gckKERNEL *         gckKERNEL;
+typedef struct _gckDB *             gckDB;
+
+/* Construct a new gckVIDMEM object. */
+gceSTATUS
+gckVIDMEM_Construct(
+    IN gckOS Os,
+    IN gctUINT32 BaseAddress,
+    IN gctSIZE_T Bytes,
+    IN gctSIZE_T Threshold,
+    IN gctSIZE_T Banking,
+    OUT gckVIDMEM * Memory
+    );
+
+/* Destroy an gckVDIMEM object. */
+gceSTATUS
+gckVIDMEM_Destroy(
+    IN gckVIDMEM Memory
+    );
+
+/* Allocate rectangular memory. */
+gceSTATUS
+gckVIDMEM_Allocate(
+    IN gckVIDMEM Memory,
+    IN gctUINT Width,
+    IN gctUINT Height,
+    IN gctUINT Depth,
+    IN gctUINT BytesPerPixel,
+    IN gctUINT32 Alignment,
+    IN gceSURF_TYPE Type,
+    OUT gcuVIDMEM_NODE_PTR * Node
+    );
+
+/* Allocate linear memory. */
+gceSTATUS
+gckVIDMEM_AllocateLinear(
+    IN gckVIDMEM Memory,
+    IN gctSIZE_T Bytes,
+    IN gctUINT32 Alignment,
+    IN gceSURF_TYPE Type,
+    OUT gcuVIDMEM_NODE_PTR * Node
+    );
+
+/* Free memory. */
+gceSTATUS
+gckVIDMEM_Free(
+    IN gcuVIDMEM_NODE_PTR Node
+    );
+
+/* Lock memory. */
+gceSTATUS
+gckVIDMEM_Lock(
+    IN gckKERNEL Kernel,
+    IN gcuVIDMEM_NODE_PTR Node,
+    IN gctBOOL Cacheable,
+    OUT gctUINT32 * Address
+    );
+
+/* Unlock memory. */
+gceSTATUS
+gckVIDMEM_Unlock(
+    IN gckKERNEL Kernel,
+    IN gcuVIDMEM_NODE_PTR Node,
+    IN gceSURF_TYPE Type,
+    IN OUT gctBOOL * Asynchroneous
+    );
+
+/* Construct a gcuVIDMEM_NODE union for virtual memory. */
+gceSTATUS
+gckVIDMEM_ConstructVirtual(
+    IN gckKERNEL Kernel,
+    IN gctBOOL Contiguous,
+    IN gctSIZE_T Bytes,
+    OUT gcuVIDMEM_NODE_PTR * Node
+    );
+
+/* Destroy a gcuVIDMEM_NODE union for virtual memory. */
+gceSTATUS
+gckVIDMEM_DestroyVirtual(
+    IN gcuVIDMEM_NODE_PTR Node
+    );
+
+/******************************************************************************\
+******************************** gckKERNEL Object ******************************
+\******************************************************************************/
+
+struct _gcsHAL_INTERFACE;
+
+/* Notifications. */
+typedef enum _gceNOTIFY
+{
+    gcvNOTIFY_INTERRUPT,
+    gcvNOTIFY_COMMAND_QUEUE,
+}
+gceNOTIFY;
+
+/* Flush flags. */
+typedef enum _gceKERNEL_FLUSH
+{
+    gcvFLUSH_COLOR              = 0x01,
+    gcvFLUSH_DEPTH              = 0x02,
+    gcvFLUSH_TEXTURE            = 0x04,
+    gcvFLUSH_2D                 = 0x08,
+    gcvFLUSH_ALL                = gcvFLUSH_COLOR
+                                | gcvFLUSH_DEPTH
+                                | gcvFLUSH_TEXTURE
+                                | gcvFLUSH_2D,
+}
+gceKERNEL_FLUSH;
+
+/* Construct a new gckKERNEL object. */
+gceSTATUS
+gckKERNEL_Construct(
+    IN gckOS Os,
+    IN gceCORE Core,
+    IN gctPOINTER Context,
+    IN gckDB SharedDB,
+    OUT gckKERNEL * Kernel
+    );
+
+/* Destroy an gckKERNEL object. */
+gceSTATUS
+gckKERNEL_Destroy(
+    IN gckKERNEL Kernel
+    );
+
+/* Dispatch a user-level command. */
+gceSTATUS
+gckKERNEL_Dispatch(
+    IN gckKERNEL Kernel,
+    IN gctBOOL FromUser,
+    IN OUT struct _gcsHAL_INTERFACE * Interface
+    );
+
+/* Query the video memory. */
+gceSTATUS
+gckKERNEL_QueryVideoMemory(
+    IN gckKERNEL Kernel,
+    OUT struct _gcsHAL_INTERFACE * Interface
+    );
+
+/* Lookup the gckVIDMEM object for a pool. */
+gceSTATUS
+gckKERNEL_GetVideoMemoryPool(
+    IN gckKERNEL Kernel,
+    IN gcePOOL Pool,
+    OUT gckVIDMEM * VideoMemory
+    );
+
+#if gcdUSE_VIDMEM_PER_PID
+gceSTATUS
+gckKERNEL_GetVideoMemoryPoolPid(
+    IN gckKERNEL Kernel,
+    IN gcePOOL Pool,
+    IN gctUINT32 Pid,
+    OUT gckVIDMEM * VideoMemory
+    );
+
+gceSTATUS
+gckKERNEL_CreateVideoMemoryPoolPid(
+    IN gckKERNEL Kernel,
+    IN gcePOOL Pool,
+    IN gctUINT32 Pid,
+    OUT gckVIDMEM * VideoMemory
+    );
+
+gceSTATUS
+gckKERNEL_RemoveVideoMemoryPoolPid(
+    IN gckKERNEL Kernel,
+    IN gckVIDMEM VideoMemory
+    );
+#endif
+
+/* Map video memory. */
+gceSTATUS
+gckKERNEL_MapVideoMemory(
+    IN gckKERNEL Kernel,
+    IN gctBOOL InUserSpace,
+    IN gctUINT32 Address,
+#ifdef __QNXNTO__
+    IN gctUINT32 Pid,
+    IN gctUINT32 Bytes,
+#endif
+    OUT gctPOINTER * Logical
+    );
+
+/* Map video memory. */
+gceSTATUS
+gckKERNEL_MapVideoMemoryEx(
+    IN gckKERNEL Kernel,
+    IN gceCORE Core,
+    IN gctBOOL InUserSpace,
+    IN gctUINT32 Address,
+#ifdef __QNXNTO__
+    IN gctUINT32 Pid,
+    IN gctUINT32 Bytes,
+#endif
+    OUT gctPOINTER * Logical
+    );
+
+#ifdef __QNXNTO__
+/* Unmap video memory. */
+gceSTATUS
+gckKERNEL_UnmapVideoMemory(
+    IN gckKERNEL Kernel,
+    IN gctPOINTER Logical,
+    IN gctUINT32 Pid,
+    IN gctUINT32 Bytes
+    );
+#endif
+
+/* Map memory. */
+gceSTATUS
+gckKERNEL_MapMemory(
+    IN gckKERNEL Kernel,
+    IN gctPHYS_ADDR Physical,
+    IN gctSIZE_T Bytes,
+    OUT gctPOINTER * Logical
+    );
+
+/* Unmap memory. */
+gceSTATUS
+gckKERNEL_UnmapMemory(
+    IN gckKERNEL Kernel,
+    IN gctPHYS_ADDR Physical,
+    IN gctSIZE_T Bytes,
+    IN gctPOINTER Logical
+    );
+
+/* Notification of events. */
+gceSTATUS
+gckKERNEL_Notify(
+    IN gckKERNEL Kernel,
+    IN gceNOTIFY Notifcation,
+    IN gctBOOL Data
+    );
+
+gceSTATUS
+gckKERNEL_QuerySettings(
+    IN gckKERNEL Kernel,
+    OUT gcsKERNEL_SETTINGS * Settings
+    );
+
+/*******************************************************************************
+**
+**  gckKERNEL_Recovery
+**
+**  Try to recover the GPU from a fatal error.
+**
+**  INPUT:
+**
+**      gckKERNEL Kernel
+**          Pointer to an gckKERNEL object.
+**
+**  OUTPUT:
+**
+**      Nothing.
+*/
+gceSTATUS
+gckKERNEL_Recovery(
+    IN gckKERNEL Kernel
+    );
+
+/* Set the value of timeout on HW operation. */
+void
+gckKERNEL_SetTimeOut(
+    IN gckKERNEL Kernel,
+	IN gctUINT32 timeOut
+    );
+
+/* Get access to the user data. */
+gceSTATUS
+gckKERNEL_OpenUserData(
+    IN gckKERNEL Kernel,
+    IN gctBOOL NeedCopy,
+    IN gctPOINTER StaticStorage,
+    IN gctPOINTER UserPointer,
+    IN gctSIZE_T Size,
+    OUT gctPOINTER * KernelPointer
+    );
+
+/* Release resources associated with the user data connection. */
+gceSTATUS
+gckKERNEL_CloseUserData(
+    IN gckKERNEL Kernel,
+    IN gctBOOL NeedCopy,
+    IN gctBOOL FlushData,
+    IN gctPOINTER UserPointer,
+    IN gctSIZE_T Size,
+    OUT gctPOINTER * KernelPointer
+    );
+
+/******************************************************************************\
+******************************* gckHARDWARE Object *****************************
+\******************************************************************************/
+
+/* Construct a new gckHARDWARE object. */
+gceSTATUS
+gckHARDWARE_Construct(
+    IN gckOS Os,
+    IN gceCORE Core,
+    OUT gckHARDWARE * Hardware
+    );
+
+/* Destroy an gckHARDWARE object. */
+gceSTATUS
+gckHARDWARE_Destroy(
+    IN gckHARDWARE Hardware
+    );
+
+/* Get hardware type. */
+gceSTATUS
+gckHARDWARE_GetType(
+    IN gckHARDWARE Hardware,
+    OUT gceHARDWARE_TYPE * Type
+    );
+
+/* Query system memory requirements. */
+gceSTATUS
+gckHARDWARE_QuerySystemMemory(
+    IN gckHARDWARE Hardware,
+    OUT gctSIZE_T * SystemSize,
+    OUT gctUINT32 * SystemBaseAddress
+    );
+
+/* Build virtual address. */
+gceSTATUS
+gckHARDWARE_BuildVirtualAddress(
+    IN gckHARDWARE Hardware,
+    IN gctUINT32 Index,
+    IN gctUINT32 Offset,
+    OUT gctUINT32 * Address
+    );
+
+/* Query command buffer requirements. */
+gceSTATUS
+gckHARDWARE_QueryCommandBuffer(
+    IN gckHARDWARE Hardware,
+    OUT gctSIZE_T * Alignment,
+    OUT gctSIZE_T * ReservedHead,
+    OUT gctSIZE_T * ReservedTail
+    );
+
+/* Add a WAIT/LINK pair in the command queue. */
+gceSTATUS
+gckHARDWARE_WaitLink(
+    IN gckHARDWARE Hardware,
+    IN gctPOINTER Logical,
+    IN gctUINT32 Offset,
+    IN OUT gctSIZE_T * Bytes,
+    OUT gctUINT32 * WaitOffset,
+    OUT gctSIZE_T * WaitBytes
+    );
+
+/* Kickstart the command processor. */
+gceSTATUS
+gckHARDWARE_Execute(
+    IN gckHARDWARE Hardware,
+    IN gctPOINTER Logical,
+#ifdef __QNXNTO__
+    IN gctPOINTER Physical,
+    IN gctBOOL PhysicalAddresses,
+#endif
+    IN gctSIZE_T Bytes
+    );
+
+/* Add an END command in the command queue. */
+gceSTATUS
+gckHARDWARE_End(
+    IN gckHARDWARE Hardware,
+    IN gctPOINTER Logical,
+    IN OUT gctSIZE_T * Bytes
+    );
+
+/* Add a NOP command in the command queue. */
+gceSTATUS
+gckHARDWARE_Nop(
+    IN gckHARDWARE Hardware,
+    IN gctPOINTER Logical,
+    IN OUT gctSIZE_T * Bytes
+    );
+
+/* Add a WAIT command in the command queue. */
+gceSTATUS
+gckHARDWARE_Wait(
+    IN gckHARDWARE Hardware,
+    IN gctPOINTER Logical,
+    IN gctUINT32 Count,
+    IN OUT gctSIZE_T * Bytes
+    );
+
+/* Add a PIPESELECT command in the command queue. */
+gceSTATUS
+gckHARDWARE_PipeSelect(
+    IN gckHARDWARE Hardware,
+    IN gctPOINTER Logical,
+    IN gcePIPE_SELECT Pipe,
+    IN OUT gctSIZE_T * Bytes
+    );
+
+/* Add a LINK command in the command queue. */
+gceSTATUS
+gckHARDWARE_Link(
+    IN gckHARDWARE Hardware,
+    IN gctPOINTER Logical,
+    IN gctPOINTER FetchAddress,
+    IN gctSIZE_T FetchSize,
+    IN OUT gctSIZE_T * Bytes
+    );
+
+/* Add an EVENT command in the command queue. */
+gceSTATUS
+gckHARDWARE_Event(
+    IN gckHARDWARE Hardware,
+    IN gctPOINTER Logical,
+    IN gctUINT8 Event,
+    IN gceKERNEL_WHERE FromWhere,
+    IN OUT gctSIZE_T * Bytes
+    );
+
+/* Query the available memory. */
+gceSTATUS
+gckHARDWARE_QueryMemory(
+    IN gckHARDWARE Hardware,
+    OUT gctSIZE_T * InternalSize,
+    OUT gctUINT32 * InternalBaseAddress,
+    OUT gctUINT32 * InternalAlignment,
+    OUT gctSIZE_T * ExternalSize,
+    OUT gctUINT32 * ExternalBaseAddress,
+    OUT gctUINT32 * ExternalAlignment,
+    OUT gctUINT32 * HorizontalTileSize,
+    OUT gctUINT32 * VerticalTileSize
+    );
+
+/* Query the identity of the hardware. */
+gceSTATUS
+gckHARDWARE_QueryChipIdentity(
+    IN gckHARDWARE Hardware,
+    OUT gcsHAL_QUERY_CHIP_IDENTITY_PTR Identity
+    );
+
+/* Query the shader support. */
+gceSTATUS
+gckHARDWARE_QueryShaderCaps(
+    IN gckHARDWARE Hardware,
+    OUT gctUINT * VertexUniforms,
+    OUT gctUINT * FragmentUniforms,
+    OUT gctUINT * Varyings
+    );
+
+/* Split a harwdare specific address into API stuff. */
+gceSTATUS
+gckHARDWARE_SplitMemory(
+    IN gckHARDWARE Hardware,
+    IN gctUINT32 Address,
+    OUT gcePOOL * Pool,
+    OUT gctUINT32 * Offset
+    );
+
+/* Update command queue tail pointer. */
+gceSTATUS
+gckHARDWARE_UpdateQueueTail(
+    IN gckHARDWARE Hardware,
+    IN gctPOINTER Logical,
+    IN gctUINT32 Offset
+    );
+
+/* Convert logical address to hardware specific address. */
+gceSTATUS
+gckHARDWARE_ConvertLogical(
+    IN gckHARDWARE Hardware,
+    IN gctPOINTER Logical,
+    OUT gctUINT32 * Address
+    );
+
+#ifdef __QNXNTO__
+/* Convert physical address to hardware specific address. */
+gceSTATUS
+gckHARDWARE_ConvertPhysical(
+    IN gckHARDWARE Hardware,
+    IN gctPHYS_ADDR Physical,
+    OUT gctUINT32 * Address
+    );
+#endif
+
+/* Interrupt manager. */
+gceSTATUS
+gckHARDWARE_Interrupt(
+    IN gckHARDWARE Hardware,
+    IN gctBOOL InterruptValid
+    );
+
+/* Program MMU. */
+gceSTATUS
+gckHARDWARE_SetMMU(
+    IN gckHARDWARE Hardware,
+    IN gctPOINTER Logical
+    );
+
+/* Flush the MMU. */
+gceSTATUS
+gckHARDWARE_FlushMMU(
+    IN gckHARDWARE Hardware
+    );
+
+/* Set the page table base address. */
+gceSTATUS
+gckHARDWARE_SetMMUv2(
+    IN gckHARDWARE Hardware,
+    IN gctBOOL Enable,
+    IN gctPOINTER MtlbAddress,
+    IN gceMMU_MODE Mode,
+    IN gctPOINTER SafeAddress,
+    IN gctBOOL FromPower
+    );
+
+/* Get idle register. */
+gceSTATUS
+gckHARDWARE_GetIdle(
+    IN gckHARDWARE Hardware,
+    IN gctBOOL Wait,
+    OUT gctUINT32 * Data
+    );
+
+/* Flush the caches. */
+gceSTATUS
+gckHARDWARE_Flush(
+    IN gckHARDWARE Hardware,
+    IN gceKERNEL_FLUSH Flush,
+    IN gctPOINTER Logical,
+    IN OUT gctSIZE_T * Bytes
+    );
+
+/* Enable/disable fast clear. */
+gceSTATUS
+gckHARDWARE_SetFastClear(
+    IN gckHARDWARE Hardware,
+    IN gctINT Enable,
+    IN gctINT Compression
+    );
+
+gceSTATUS
+gckHARDWARE_ReadInterrupt(
+    IN gckHARDWARE Hardware,
+    OUT gctUINT32_PTR IDs
+    );
+
+/* Power management. */
+gceSTATUS
+gckHARDWARE_SetPowerManagementState(
+    IN gckHARDWARE Hardware,
+    IN gceCHIPPOWERSTATE State
+    );
+
+gceSTATUS
+gckHARDWARE_QueryPowerManagementState(
+    IN gckHARDWARE Hardware,
+    OUT gceCHIPPOWERSTATE* State
+    );
+
+#if gcdPOWEROFF_TIMEOUT
+gceSTATUS
+gckHARDWARE_SetPowerOffTimeout(
+    IN gckHARDWARE  Hardware,
+    IN gctUINT32    Timeout
+);
+
+gceSTATUS
+gckHARDWARE_QueryPowerOffTimeout(
+    IN gckHARDWARE  Hardware,
+    OUT gctUINT32*  Timeout
+);
+#endif
+
+/* Profile 2D Engine. */
+gceSTATUS
+gckHARDWARE_ProfileEngine2D(
+    IN gckHARDWARE Hardware,
+    OUT gcs2D_PROFILE_PTR Profile
+    );
+
+gceSTATUS
+gckHARDWARE_InitializeHardware(
+    IN gckHARDWARE Hardware
+    );
+
+gceSTATUS
+gckHARDWARE_Reset(
+    IN gckHARDWARE Hardware
+    );
+
+typedef gceSTATUS (*gctISRMANAGERFUNC)(gctPOINTER Context);
+
+gceSTATUS
+gckHARDWARE_SetIsrManager(
+    IN gckHARDWARE Hardware,
+    IN gctISRMANAGERFUNC StartIsr,
+    IN gctISRMANAGERFUNC StopIsr,
+    IN gctPOINTER Context
+    );
+
+/* Start a composition. */
+gceSTATUS
+gckHARDWARE_Compose(
+    IN gckHARDWARE Hardware,
+    IN gctUINT32 ProcessID,
+    IN gctPHYS_ADDR Physical,
+    IN gctPOINTER Logical,
+    IN gctSIZE_T Offset,
+    IN gctSIZE_T Size,
+    IN gctUINT8 EventID
+    );
+
+/* Check for Hardware features. */
+gceSTATUS
+gckHARDWARE_IsFeatureAvailable(
+    IN gckHARDWARE Hardware,
+    IN gceFEATURE Feature
+    );
+
+#if !gcdENABLE_VG
+/******************************************************************************\
+***************************** gckINTERRUPT Object ******************************
+\******************************************************************************/
+
+typedef struct _gckINTERRUPT *  gckINTERRUPT;
+
+typedef gceSTATUS (* gctINTERRUPT_HANDLER)(
+    IN gckKERNEL Kernel
+    );
+
+gceSTATUS
+gckINTERRUPT_Construct(
+    IN gckKERNEL Kernel,
+    OUT gckINTERRUPT * Interrupt
+    );
+
+gceSTATUS
+gckINTERRUPT_Destroy(
+    IN gckINTERRUPT Interrupt
+    );
+
+gceSTATUS
+gckINTERRUPT_SetHandler(
+    IN gckINTERRUPT Interrupt,
+    IN OUT gctINT32_PTR Id,
+    IN gctINTERRUPT_HANDLER Handler
+    );
+
+gceSTATUS
+gckINTERRUPT_Notify(
+    IN gckINTERRUPT Interrupt,
+    IN gctBOOL Valid
+    );
+#endif
+/******************************************************************************\
+******************************** gckEVENT Object *******************************
+\******************************************************************************/
+
+typedef struct _gckEVENT *      gckEVENT;
+
+/* Construct a new gckEVENT object. */
+gceSTATUS
+gckEVENT_Construct(
+    IN gckKERNEL Kernel,
+    OUT gckEVENT * Event
+    );
+
+/* Destroy an gckEVENT object. */
+gceSTATUS
+gckEVENT_Destroy(
+    IN gckEVENT Event
+    );
+
+/* Reserve the next available hardware event. */
+gceSTATUS
+gckEVENT_GetEvent(
+    IN gckEVENT Event,
+    IN gctBOOL Wait,
+    OUT gctUINT8 * EventID,
+    IN gceKERNEL_WHERE Source
+   );
+
+/* Add a new event to the list of events. */
+gceSTATUS
+gckEVENT_AddList(
+    IN gckEVENT Event,
+    IN gcsHAL_INTERFACE_PTR Interface,
+    IN gceKERNEL_WHERE FromWhere,
+    IN gctBOOL AllocateAllowed
+    );
+
+/* Schedule a FreeNonPagedMemory event. */
+gceSTATUS
+gckEVENT_FreeNonPagedMemory(
+    IN gckEVENT Event,
+    IN gctSIZE_T Bytes,
+    IN gctPHYS_ADDR Physical,
+    IN gctPOINTER Logical,
+    IN gceKERNEL_WHERE FromWhere
+    );
+
+/* Schedule a FreeContiguousMemory event. */
+gceSTATUS
+gckEVENT_FreeContiguousMemory(
+    IN gckEVENT Event,
+    IN gctSIZE_T Bytes,
+    IN gctPHYS_ADDR Physical,
+    IN gctPOINTER Logical,
+    IN gceKERNEL_WHERE FromWhere
+    );
+
+/* Schedule a FreeVideoMemory event. */
+gceSTATUS
+gckEVENT_FreeVideoMemory(
+    IN gckEVENT Event,
+    IN gcuVIDMEM_NODE_PTR VideoMemory,
+    IN gceKERNEL_WHERE FromWhere
+    );
+
+/* Schedule a signal event. */
+gceSTATUS
+gckEVENT_Signal(
+    IN gckEVENT Event,
+    IN gctSIGNAL Signal,
+    IN gceKERNEL_WHERE FromWhere
+    );
+
+/* Schedule an Unlock event. */
+gceSTATUS
+gckEVENT_Unlock(
+    IN gckEVENT Event,
+    IN gceKERNEL_WHERE FromWhere,
+    IN gcuVIDMEM_NODE_PTR Node,
+    IN gceSURF_TYPE Type
+    );
+
+gceSTATUS
+gckEVENT_CommitDone(
+    IN gckEVENT Event,
+    IN gceKERNEL_WHERE FromWhere
+    );
+
+gceSTATUS
+gckEVENT_Submit(
+    IN gckEVENT Event,
+    IN gctBOOL Wait,
+    IN gctBOOL FromPower
+    );
+
+/* Commit an event queue. */
+gceSTATUS
+gckEVENT_Commit(
+    IN gckEVENT Event,
+    IN gcsQUEUE_PTR Queue
+    );
+
+/* Schedule a composition event. */
+gceSTATUS
+gckEVENT_Compose(
+    IN gckEVENT Event,
+    IN gcsHAL_COMPOSE_PTR Info
+    );
+
+/* Event callback routine. */
+gceSTATUS
+gckEVENT_Notify(
+    IN gckEVENT Event,
+    IN gctUINT32 IDs
+    );
+
+/* Event callback routine. */
+gceSTATUS
+gckEVENT_Interrupt(
+    IN gckEVENT Event,
+    IN gctUINT32 IDs
+    );
+
+gceSTATUS
+gckEVENT_Dump(
+    IN gckEVENT Event
+    );
+/******************************************************************************\
+******************************* gckCOMMAND Object ******************************
+\******************************************************************************/
+
+typedef struct _gckCOMMAND *        gckCOMMAND;
+
+/* Construct a new gckCOMMAND object. */
+gceSTATUS
+gckCOMMAND_Construct(
+    IN gckKERNEL Kernel,
+    OUT gckCOMMAND * Command
+    );
+
+/* Destroy an gckCOMMAND object. */
+gceSTATUS
+gckCOMMAND_Destroy(
+    IN gckCOMMAND Command
+    );
+
+/* Acquire command queue synchronization objects. */
+gceSTATUS
+gckCOMMAND_EnterCommit(
+    IN gckCOMMAND Command,
+    IN gctBOOL FromPower
+    );
+
+/* Release command queue synchronization objects. */
+gceSTATUS
+gckCOMMAND_ExitCommit(
+    IN gckCOMMAND Command,
+    IN gctBOOL FromPower
+    );
+
+/* Start the command queue. */
+gceSTATUS
+gckCOMMAND_Start(
+    IN gckCOMMAND Command
+    );
+
+/* Stop the command queue. */
+gceSTATUS
+gckCOMMAND_Stop(
+    IN gckCOMMAND Command,
+    IN gctBOOL FromRecovery
+    );
+
+/* Commit a buffer to the command queue. */
+gceSTATUS
+gckCOMMAND_Commit(
+    IN gckCOMMAND Command,
+    IN gckCONTEXT Context,
+    IN gcoCMDBUF CommandBuffer,
+    IN gcsSTATE_DELTA_PTR StateDelta,
+    IN gcsQUEUE_PTR EventQueue,
+    IN gctUINT32 ProcessID
+    );
+
+/* Reserve space in the command buffer. */
+gceSTATUS
+gckCOMMAND_Reserve(
+    IN gckCOMMAND Command,
+    IN gctSIZE_T RequestedBytes,
+    OUT gctPOINTER * Buffer,
+    OUT gctSIZE_T * BufferSize
+    );
+
+/* Execute reserved space in the command buffer. */
+gceSTATUS
+gckCOMMAND_Execute(
+    IN gckCOMMAND Command,
+    IN gctSIZE_T RequstedBytes
+    );
+
+/* Stall the command queue. */
+gceSTATUS
+gckCOMMAND_Stall(
+    IN gckCOMMAND Command,
+    IN gctBOOL FromPower
+    );
+
+/* Attach user process. */
+gceSTATUS
+gckCOMMAND_Attach(
+    IN gckCOMMAND Command,
+    OUT gckCONTEXT * Context,
+    OUT gctSIZE_T * StateCount,
+    IN gctUINT32 ProcessID
+    );
+
+/* Detach user process. */
+gceSTATUS
+gckCOMMAND_Detach(
+    IN gckCOMMAND Command,
+    IN gckCONTEXT Context
+    );
+
+/******************************************************************************\
+********************************* gckMMU Object ********************************
+\******************************************************************************/
+
+typedef struct _gckMMU *            gckMMU;
+
+/* Construct a new gckMMU object. */
+gceSTATUS
+gckMMU_Construct(
+    IN gckKERNEL Kernel,
+    IN gctSIZE_T MmuSize,
+    OUT gckMMU * Mmu
+    );
+
+/* Destroy an gckMMU object. */
+gceSTATUS
+gckMMU_Destroy(
+    IN gckMMU Mmu
+    );
+
+/* Enable the MMU. */
+gceSTATUS
+gckMMU_Enable(
+    IN gckMMU Mmu,
+    IN gctUINT32 PhysBaseAddr,
+    IN gctUINT32 PhysSize
+    );
+
+/* Allocate pages inside the MMU. */
+gceSTATUS
+gckMMU_AllocatePages(
+    IN gckMMU Mmu,
+    IN gctSIZE_T PageCount,
+    OUT gctPOINTER * PageTable,
+    OUT gctUINT32 * Address
+    );
+
+/* Remove a page table from the MMU. */
+gceSTATUS
+gckMMU_FreePages(
+    IN gckMMU Mmu,
+    IN gctPOINTER PageTable,
+    IN gctSIZE_T PageCount
+    );
+
+/* Set the MMU page with info. */
+gceSTATUS
+gckMMU_SetPage(
+   IN gckMMU Mmu,
+   IN gctUINT32 PageAddress,
+   IN gctUINT32 *PageEntry
+   );
+
+#ifdef __QNXNTO__
+gceSTATUS
+gckMMU_InsertNode(
+    IN gckMMU Mmu,
+    IN gcuVIDMEM_NODE_PTR Node);
+
+gceSTATUS
+gckMMU_RemoveNode(
+    IN gckMMU Mmu,
+    IN gcuVIDMEM_NODE_PTR Node);
+#endif
+
+#ifdef __QNXNTO__
+gceSTATUS
+gckMMU_FreeHandleMemory(
+    IN gckKERNEL Kernel,
+    IN gckMMU Mmu,
+    IN gctUINT32 Pid
+    );
+#endif
+
+gceSTATUS
+gckMMU_Flush(
+    IN gckMMU Mmu
+    );
+
+
+#if VIVANTE_PROFILER
+gceSTATUS
+gckHARDWARE_QueryProfileRegisters(
+    IN gckHARDWARE Hardware,
+    OUT gcsPROFILER_COUNTERS * Counters
+    );
+#endif
+
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#if gcdENABLE_VG
+#include "gc_hal_vg.h"
+#endif
+
+#endif /* __gc_hal_h_ */
diff --git a/attic/gc_hal_base.h b/attic/gc_hal_base.h
new file mode 100644
index 0000000..72e23ad
--- /dev/null
+++ b/attic/gc_hal_base.h
@@ -0,0 +1,3612 @@
+/****************************************************************************
+*
+*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*
+*    This program is free software; you can redistribute it and/or modify
+*    it under the terms of the GNU General Public License as published by
+*    the Free Software Foundation; either version 2 of the license, or
+*    (at your option) any later version.
+*
+*    This program is distributed in the hope that it will be useful,
+*    but WITHOUT ANY WARRANTY; without even the implied warranty of
+*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+*    GNU General Public License for more details.
+*
+*    You should have received a copy of the GNU General Public License
+*    along with this program; if not write to the Free Software
+*    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*
+*****************************************************************************/
+
+
+
+
+#ifndef __gc_hal_base_h_
+#define __gc_hal_base_h_
+
+#include "gc_hal_enum.h"
+#include "gc_hal_types.h"
+
+#include "gc_hal_dump.h"
+#include "gc_hal_md5.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/******************************************************************************\
+****************************** Object Declarations *****************************
+\******************************************************************************/
+
+typedef struct _gckOS *                 gckOS;
+typedef struct _gcoHAL *                gcoHAL;
+typedef struct _gcoOS *                 gcoOS;
+typedef struct _gco2D *                 gco2D;
+
+#ifndef VIVANTE_NO_3D
+typedef struct _gco3D *                 gco3D;
+#endif
+
+typedef struct _gcoSURF *               gcoSURF;
+typedef struct _gcsSURF_INFO *          gcsSURF_INFO_PTR;
+typedef struct _gcsSURF_NODE *          gcsSURF_NODE_PTR;
+typedef struct _gcsSURF_FORMAT_INFO *   gcsSURF_FORMAT_INFO_PTR;
+typedef struct _gcsPOINT *              gcsPOINT_PTR;
+typedef struct _gcsSIZE *               gcsSIZE_PTR;
+typedef struct _gcsRECT *               gcsRECT_PTR;
+typedef struct _gcsBOUNDARY *           gcsBOUNDARY_PTR;
+typedef struct _gcoDUMP *               gcoDUMP;
+typedef struct _gcoHARDWARE *           gcoHARDWARE;
+typedef union  _gcuVIDMEM_NODE *        gcuVIDMEM_NODE_PTR;
+
+#if gcdENABLE_VG
+typedef struct _gcoVG *                 gcoVG;
+typedef struct _gcsCOMPLETION_SIGNAL *	gcsCOMPLETION_SIGNAL_PTR;
+typedef struct _gcsCONTEXT_MAP *		gcsCONTEXT_MAP_PTR;
+#else
+typedef void *                          gcoVG;
+#endif
+
+/******************************************************************************\
+******************************* Process local storage *************************
+\******************************************************************************/
+
+typedef struct _gcsPLS * gcsPLS_PTR;
+typedef struct _gcsPLS
+{
+    /* Global objects. */
+    gcoOS                       os;
+    gcoHAL                      hal;
+
+    /* Internal memory pool. */
+    gctSIZE_T                   internalSize;
+    gctPHYS_ADDR                internalPhysical;
+    gctPOINTER                  internalLogical;
+
+    /* External memory pool. */
+    gctSIZE_T                   externalSize;
+    gctPHYS_ADDR                externalPhysical;
+    gctPOINTER                  externalLogical;
+
+    /* Contiguous memory pool. */
+    gctSIZE_T                   contiguousSize;
+    gctPHYS_ADDR                contiguousPhysical;
+    gctPOINTER                  contiguousLogical;
+
+    /* EGL-specific process-wide objects. */
+    gctPOINTER                  eglDisplayInfo;
+    gctPOINTER                  eglSurfaceInfo;
+}
+gcsPLS;
+
+extern gcsPLS gcPLS;
+
+/******************************************************************************\
+******************************* Thread local storage *************************
+\******************************************************************************/
+
+typedef struct _gcsTLS * gcsTLS_PTR;
+
+typedef void (* gctTLS_DESTRUCTOR) (
+    gcsTLS_PTR TLS
+    );
+
+typedef struct _gcsTLS
+{
+    gceHARDWARE_TYPE            currentType;
+    gcoHARDWARE                 hardware;
+    /* Only for separated 3D and 2D */
+    gcoHARDWARE                 hardware2D;
+#if gcdENABLE_VG
+    gcoVGHARDWARE               vg;
+    gcoVG                       engineVG;
+#endif /* gcdENABLE_VG */
+    gctPOINTER                  context;
+    gctTLS_DESTRUCTOR           destructor;
+    gctBOOL                     ProcessExiting;
+
+#ifndef VIVANTE_NO_3D
+	gco3D						engine3D;
+#endif
+	gco2D						engine2D;
+}
+gcsTLS;
+
+/******************************************************************************\
+********************************* Enumerations *********************************
+\******************************************************************************/
+
+typedef enum _gcePLS_VALUE
+{
+  gcePLS_VALUE_EGL_DISPLAY_INFO,
+  gcePLS_VALUE_EGL_SURFACE_INFO
+}
+gcePLS_VALUE;
+
+/* Video memory pool type. */
+typedef enum _gcePOOL
+{
+    gcvPOOL_UNKNOWN = 0,
+    gcvPOOL_DEFAULT,
+    gcvPOOL_LOCAL,
+    gcvPOOL_LOCAL_INTERNAL,
+    gcvPOOL_LOCAL_EXTERNAL,
+    gcvPOOL_UNIFIED,
+    gcvPOOL_SYSTEM,
+    gcvPOOL_VIRTUAL,
+    gcvPOOL_USER,
+    gcvPOOL_CONTIGUOUS,
+
+    gcvPOOL_NUMBER_OF_POOLS
+}
+gcePOOL;
+
+#ifndef VIVANTE_NO_3D
+/* Blending functions. */
+typedef enum _gceBLEND_FUNCTION
+{
+    gcvBLEND_ZERO,
+    gcvBLEND_ONE,
+    gcvBLEND_SOURCE_COLOR,
+    gcvBLEND_INV_SOURCE_COLOR,
+    gcvBLEND_SOURCE_ALPHA,
+    gcvBLEND_INV_SOURCE_ALPHA,
+    gcvBLEND_TARGET_COLOR,
+    gcvBLEND_INV_TARGET_COLOR,
+    gcvBLEND_TARGET_ALPHA,
+    gcvBLEND_INV_TARGET_ALPHA,
+    gcvBLEND_SOURCE_ALPHA_SATURATE,
+    gcvBLEND_CONST_COLOR,
+    gcvBLEND_INV_CONST_COLOR,
+    gcvBLEND_CONST_ALPHA,
+    gcvBLEND_INV_CONST_ALPHA,
+}
+gceBLEND_FUNCTION;
+
+/* Blending modes. */
+typedef enum _gceBLEND_MODE
+{
+    gcvBLEND_ADD,
+    gcvBLEND_SUBTRACT,
+    gcvBLEND_REVERSE_SUBTRACT,
+    gcvBLEND_MIN,
+    gcvBLEND_MAX,
+}
+gceBLEND_MODE;
+
+/* API flags. */
+typedef enum _gceAPI
+{
+    gcvAPI_D3D                  = 0x1,
+    gcvAPI_OPENGL               = 0x2,
+    gcvAPI_OPENVG               = 0x3,
+    gcvAPI_OPENCL               = 0x4,
+}
+gceAPI;
+
+/* Depth modes. */
+typedef enum _gceDEPTH_MODE
+{
+    gcvDEPTH_NONE,
+    gcvDEPTH_Z,
+    gcvDEPTH_W,
+}
+gceDEPTH_MODE;
+#endif /* VIVANTE_NO_3D */
+
+typedef enum _gceWHERE
+{
+    gcvWHERE_COMMAND,
+    gcvWHERE_RASTER,
+    gcvWHERE_PIXEL,
+}
+gceWHERE;
+
+typedef enum _gceHOW
+{
+    gcvHOW_SEMAPHORE            = 0x1,
+    gcvHOW_STALL                = 0x2,
+    gcvHOW_SEMAPHORE_STALL      = 0x3,
+}
+gceHOW;
+
+typedef enum _gceSignalHandlerType
+{
+    gcvHANDLE_SIGFPE_WHEN_SIGNAL_CODE_IS_0        = 0x1,
+}
+gceSignalHandlerType;
+
+
+#if gcdENABLE_VG
+/* gcsHAL_Limits*/
+typedef struct _gcsHAL_LIMITS
+{
+    /* chip info */
+    gceCHIPMODEL    chipModel;
+    gctUINT32       chipRevision;
+    gctUINT32       featureCount;
+    gctUINT32       *chipFeatures;
+
+    /* target caps */
+	gctUINT32         maxWidth;
+	gctUINT32         maxHeight;
+	gctUINT32         multiTargetCount;
+	gctUINT32         maxSamples;
+
+}gcsHAL_LIMITS;
+#endif
+
+/******************************************************************************\
+*********** Generic Memory Allocation Optimization Using Containers ************
+\******************************************************************************/
+
+/* Generic container definition. */
+typedef struct _gcsCONTAINER_LINK * gcsCONTAINER_LINK_PTR;
+typedef struct _gcsCONTAINER_LINK
+{
+    /* Points to the next container. */
+    gcsCONTAINER_LINK_PTR           next;
+}
+gcsCONTAINER_LINK;
+
+typedef struct _gcsCONTAINER_RECORD * gcsCONTAINER_RECORD_PTR;
+typedef struct _gcsCONTAINER_RECORD
+{
+    gcsCONTAINER_RECORD_PTR         prev;
+    gcsCONTAINER_RECORD_PTR         next;
+}
+gcsCONTAINER_RECORD;
+
+typedef struct _gcsCONTAINER * gcsCONTAINER_PTR;
+typedef struct _gcsCONTAINER
+{
+    gctUINT                         containerSize;
+    gctUINT                         recordSize;
+    gctUINT                         recordCount;
+    gcsCONTAINER_LINK_PTR           containers;
+    gcsCONTAINER_RECORD             freeList;
+    gcsCONTAINER_RECORD             allocList;
+}
+gcsCONTAINER;
+
+gceSTATUS
+gcsCONTAINER_Construct(
+    IN gcsCONTAINER_PTR Container,
+    gctUINT RecordsPerContainer,
+    gctUINT RecordSize
+    );
+
+gceSTATUS
+gcsCONTAINER_Destroy(
+    IN gcsCONTAINER_PTR Container
+    );
+
+gceSTATUS
+gcsCONTAINER_AllocateRecord(
+    IN gcsCONTAINER_PTR Container,
+    OUT gctPOINTER * Record
+    );
+
+gceSTATUS
+gcsCONTAINER_FreeRecord(
+    IN gcsCONTAINER_PTR Container,
+    IN gctPOINTER Record
+    );
+
+gceSTATUS
+gcsCONTAINER_FreeAll(
+    IN gcsCONTAINER_PTR Container
+    );
+
+/******************************************************************************\
+********************************* gcoHAL Object *********************************
+\******************************************************************************/
+
+/* Construct a new gcoHAL object. */
+gceSTATUS
+gcoHAL_Construct(
+    IN gctPOINTER Context,
+    IN gcoOS Os,
+    OUT gcoHAL * Hal
+    );
+
+/* Destroy an gcoHAL object. */
+gceSTATUS
+gcoHAL_Destroy(
+    IN gcoHAL Hal
+    );
+
+/* Get pointer to gco2D object. */
+gceSTATUS
+gcoHAL_Get2DEngine(
+    IN gcoHAL Hal,
+    OUT gco2D * Engine
+    );
+
+#ifndef VIVANTE_NO_3D
+/* Get pointer to gco3D object. */
+gceSTATUS
+gcoHAL_Get3DEngine(
+    IN gcoHAL Hal,
+    OUT gco3D * Engine
+    );
+
+gceSTATUS
+gcoHAL_Query3DEngine(
+    IN gcoHAL Hal,
+    OUT gco3D * Engine
+    );
+
+gceSTATUS
+gcoHAL_Set3DEngine(
+    IN gcoHAL Hal,
+    IN gco3D Engine
+    );
+
+gceSTATUS
+gcoHAL_Get3DHardware(
+    IN gcoHAL Hal,
+    OUT gcoHARDWARE * Hardware
+    );
+
+gceSTATUS
+gcoHAL_Set3DHardware(
+    IN gcoHAL Hal,
+    IN gcoHARDWARE Hardware
+    );
+
+
+#endif /* VIVANTE_NO_3D */
+
+/* Verify whether the specified feature is available in hardware. */
+gceSTATUS
+gcoHAL_IsFeatureAvailable(
+    IN gcoHAL Hal,
+    IN gceFEATURE Feature
+    );
+
+/* Query the identity of the hardware. */
+gceSTATUS
+gcoHAL_QueryChipIdentity(
+    IN gcoHAL Hal,
+    OUT gceCHIPMODEL* ChipModel,
+    OUT gctUINT32* ChipRevision,
+    OUT gctUINT32* ChipFeatures,
+    OUT gctUINT32* ChipMinorFeatures
+    );
+
+/* Query the minor features of the hardware. */
+gceSTATUS gcoHAL_QueryChipMinorFeatures(
+    IN gcoHAL Hal,
+    OUT gctUINT32* NumFeatures,
+    OUT gctUINT32* ChipMinorFeatures
+    );
+
+/* Query the amount of video memory. */
+gceSTATUS
+gcoHAL_QueryVideoMemory(
+    IN gcoHAL Hal,
+    OUT gctPHYS_ADDR * InternalAddress,
+    OUT gctSIZE_T * InternalSize,
+    OUT gctPHYS_ADDR * ExternalAddress,
+    OUT gctSIZE_T * ExternalSize,
+    OUT gctPHYS_ADDR * ContiguousAddress,
+    OUT gctSIZE_T * ContiguousSize
+    );
+
+/* Map video memory. */
+gceSTATUS
+gcoHAL_MapMemory(
+    IN gcoHAL Hal,
+    IN gctPHYS_ADDR Physical,
+    IN gctSIZE_T NumberOfBytes,
+    OUT gctPOINTER * Logical
+    );
+
+/* Unmap video memory. */
+gceSTATUS
+gcoHAL_UnmapMemory(
+    IN gcoHAL Hal,
+    IN gctPHYS_ADDR Physical,
+    IN gctSIZE_T NumberOfBytes,
+    IN gctPOINTER Logical
+    );
+
+/* Schedule an unmap of a buffer mapped through its physical address. */
+gceSTATUS
+gcoHAL_ScheduleUnmapMemory(
+    IN gcoHAL Hal,
+    IN gctPHYS_ADDR Physical,
+    IN gctSIZE_T NumberOfBytes,
+    IN gctPOINTER Logical
+    );
+
+/* Schedule an unmap of a user buffer using event mechanism. */
+gceSTATUS
+gcoHAL_ScheduleUnmapUserMemory(
+    IN gcoHAL Hal,
+    IN gctPOINTER Info,
+    IN gctSIZE_T Size,
+    IN gctUINT32 Address,
+    IN gctPOINTER Memory
+    );
+
+/* Commit the current command buffer. */
+gceSTATUS
+gcoHAL_Commit(
+    IN gcoHAL Hal,
+    IN gctBOOL Stall
+    );
+
+/* Query the tile capabilities. */
+gceSTATUS
+gcoHAL_QueryTiled(
+    IN gcoHAL Hal,
+    OUT gctINT32 * TileWidth2D,
+    OUT gctINT32 * TileHeight2D,
+    OUT gctINT32 * TileWidth3D,
+    OUT gctINT32 * TileHeight3D
+    );
+
+gceSTATUS
+gcoHAL_Compact(
+    IN gcoHAL Hal
+    );
+
+#if VIVANTE_PROFILER /*gcdENABLE_PROFILING*/
+gceSTATUS
+gcoHAL_ProfileStart(
+    IN gcoHAL Hal
+    );
+
+gceSTATUS
+gcoHAL_ProfileEnd(
+    IN gcoHAL Hal,
+    IN gctCONST_STRING Title
+    );
+#endif
+
+/* Power Management */
+gceSTATUS
+gcoHAL_SetPowerManagementState(
+    IN gcoHAL Hal,
+    IN gceCHIPPOWERSTATE State
+    );
+
+gceSTATUS
+gcoHAL_QueryPowerManagementState(
+    IN gcoHAL Hal,
+    OUT gceCHIPPOWERSTATE *State
+    );
+
+/* Set the filter type for filter blit. */
+gceSTATUS
+gcoHAL_SetFilterType(
+    IN gcoHAL Hal,
+    IN gceFILTER_TYPE FilterType
+    );
+
+gceSTATUS
+gcoHAL_GetDump(
+    IN gcoHAL Hal,
+    OUT gcoDUMP * Dump
+    );
+
+/* Call the kernel HAL layer. */
+gceSTATUS
+gcoHAL_Call(
+    IN gcoHAL Hal,
+    IN OUT gcsHAL_INTERFACE_PTR Interface
+    );
+
+/* Schedule an event. */
+gceSTATUS
+gcoHAL_ScheduleEvent(
+    IN gcoHAL Hal,
+    IN OUT gcsHAL_INTERFACE_PTR Interface
+    );
+
+/* Destroy a surface. */
+gceSTATUS
+gcoHAL_DestroySurface(
+    IN gcoHAL Hal,
+    IN gcoSURF Surface
+    );
+
+/* Request a start/stop timestamp. */
+gceSTATUS
+gcoHAL_SetTimer(
+    IN gcoHAL Hal,
+    IN gctUINT32 Index,
+    IN gctBOOL Start
+    );
+
+/* Get Time delta from a Timer in microseconds. */
+gceSTATUS
+gcoHAL_GetTimerTime(
+    IN gcoHAL Hal,
+    IN gctUINT32 Timer,
+    OUT gctINT32_PTR TimeDelta
+    );
+
+/* set timeout value. */
+gceSTATUS
+gcoHAL_SetTimeOut(
+    IN gcoHAL Hal,
+    IN gctUINT32 timeOut
+    );
+
+gceSTATUS
+gcoHAL_SetHardwareType(
+    IN gcoHAL Hal,
+    IN gceHARDWARE_TYPE HardwardType
+    );
+
+gceSTATUS
+gcoHAL_GetHardwareType(
+    IN gcoHAL Hal,
+    OUT gceHARDWARE_TYPE * HardwardType
+    );
+
+gceSTATUS
+gcoHAL_QueryChipCount(
+    IN gcoHAL Hal,
+    OUT gctINT32 * Count
+    );
+
+gceSTATUS
+gcoHAL_QuerySeparated3D2D(
+    IN gcoHAL Hal
+    );
+
+/* Get pointer to gcoVG object. */
+gceSTATUS
+gcoHAL_GetVGEngine(
+    IN gcoHAL Hal,
+    OUT gcoVG * Engine
+    );
+
+#if gcdENABLE_VG
+gceSTATUS
+gcoHAL_QueryChipLimits(
+    IN gcoHAL           Hal,
+    IN gctINT32         Chip,
+    OUT gcsHAL_LIMITS   *Limits);
+
+gceSTATUS
+gcoHAL_QueryChipFeature(
+    IN gcoHAL       Hal,
+    IN gctINT32     Chip,
+    IN gceFEATURE   Feature);
+
+#endif
+/******************************************************************************\
+********************************** gcoOS Object *********************************
+\******************************************************************************/
+
+/* Get PLS value for given key */
+gctPOINTER
+gcoOS_GetPLSValue(
+    IN gcePLS_VALUE key
+    );
+
+/* Set PLS value of a given key */
+void
+gcoOS_SetPLSValue(
+    IN gcePLS_VALUE key,
+    OUT gctPOINTER value
+    );
+
+/* Get access to the thread local storage. */
+gceSTATUS
+gcoOS_GetTLS(
+    OUT gcsTLS_PTR * TLS
+    );
+
+/* Destroy the objects associated with the current thread. */
+void
+gcoOS_FreeThreadData(
+    IN gctBOOL ProcessExiting
+    );
+
+/* Construct a new gcoOS object. */
+gceSTATUS
+gcoOS_Construct(
+    IN gctPOINTER Context,
+    OUT gcoOS * Os
+    );
+
+/* Destroy an gcoOS object. */
+gceSTATUS
+gcoOS_Destroy(
+    IN gcoOS Os
+    );
+
+/* Get the base address for the physical memory. */
+gceSTATUS
+gcoOS_GetBaseAddress(
+    IN gcoOS Os,
+    OUT gctUINT32_PTR BaseAddress
+    );
+
+/* Allocate memory from the heap. */
+gceSTATUS
+gcoOS_Allocate(
+    IN gcoOS Os,
+    IN gctSIZE_T Bytes,
+    OUT gctPOINTER * Memory
+    );
+
+/* Get allocated memory size. */
+gceSTATUS
+gcoOS_GetMemorySize(
+    IN gcoOS Os,
+    IN gctPOINTER Memory,
+    OUT gctSIZE_T_PTR MemorySize
+    );
+
+/* Free allocated memory. */
+gceSTATUS
+gcoOS_Free(
+    IN gcoOS Os,
+    IN gctPOINTER Memory
+    );
+
+/* Allocate memory. */
+gceSTATUS
+gcoOS_AllocateMemory(
+    IN gcoOS Os,
+    IN gctSIZE_T Bytes,
+    OUT gctPOINTER * Memory
+    );
+
+/* Free memory. */
+gceSTATUS
+gcoOS_FreeMemory(
+    IN gcoOS Os,
+    IN gctPOINTER Memory
+    );
+
+/* Allocate contiguous memory. */
+gceSTATUS
+gcoOS_AllocateContiguous(
+    IN gcoOS Os,
+    IN gctBOOL InUserSpace,
+    IN OUT gctSIZE_T * Bytes,
+    OUT gctPHYS_ADDR * Physical,
+    OUT gctPOINTER * Logical
+    );
+
+/* Free contiguous memory. */
+gceSTATUS
+gcoOS_FreeContiguous(
+    IN gcoOS Os,
+    IN gctPHYS_ADDR Physical,
+    IN gctPOINTER Logical,
+    IN gctSIZE_T Bytes
+    );
+
+#if gcdENABLE_BANK_ALIGNMENT
+gceSTATUS
+gcoSURF_GetBankOffsetBytes(
+    IN gcoSURF Surfce,
+    IN gceSURF_TYPE Type,
+    IN gctUINT32 Stride,
+    IN gctUINT32_PTR Bytes
+    );
+#endif
+
+/* Map user memory. */
+gceSTATUS
+gcoOS_MapUserMemory(
+    IN gcoOS Os,
+    IN gctPOINTER Memory,
+    IN gctSIZE_T Size,
+    OUT gctPOINTER * Info,
+    OUT gctUINT32_PTR Address
+    );
+
+/* Unmap user memory. */
+gceSTATUS
+gcoOS_UnmapUserMemory(
+    IN gcoOS Os,
+    IN gctPOINTER Memory,
+    IN gctSIZE_T Size,
+    IN gctPOINTER Info,
+    IN gctUINT32 Address
+    );
+
+/* Device I/O Control call to the kernel HAL layer. */
+gceSTATUS
+gcoOS_DeviceControl(
+    IN gcoOS Os,
+    IN gctUINT32 IoControlCode,
+    IN gctPOINTER InputBuffer,
+    IN gctSIZE_T InputBufferSize,
+    IN gctPOINTER OutputBuffer,
+    IN gctSIZE_T OutputBufferSize
+    );
+
+/* Allocate non paged memory. */
+gceSTATUS
+gcoOS_AllocateNonPagedMemory(
+    IN gcoOS Os,
+    IN gctBOOL InUserSpace,
+    IN OUT gctSIZE_T * Bytes,
+    OUT gctPHYS_ADDR * Physical,
+    OUT gctPOINTER * Logical
+    );
+
+/* Free non paged memory. */
+gceSTATUS
+gcoOS_FreeNonPagedMemory(
+    IN gcoOS Os,
+    IN gctSIZE_T Bytes,
+    IN gctPHYS_ADDR Physical,
+    IN gctPOINTER Logical
+    );
+
+#define gcmOS_SAFE_FREE(os, mem) \
+	gcoOS_Free(os, mem); \
+	mem = gcvNULL
+
+#define gcmkOS_SAFE_FREE(os, mem) \
+    gckOS_Free(os, mem); \
+	mem = gcvNULL
+
+typedef enum _gceFILE_MODE
+{
+    gcvFILE_CREATE          = 0,
+    gcvFILE_APPEND,
+    gcvFILE_READ,
+    gcvFILE_CREATETEXT,
+    gcvFILE_APPENDTEXT,
+    gcvFILE_READTEXT,
+}
+gceFILE_MODE;
+
+/* Open a file. */
+gceSTATUS
+gcoOS_Open(
+    IN gcoOS Os,
+    IN gctCONST_STRING FileName,
+    IN gceFILE_MODE Mode,
+    OUT gctFILE * File
+    );
+
+/* Close a file. */
+gceSTATUS
+gcoOS_Close(
+    IN gcoOS Os,
+    IN gctFILE File
+    );
+
+/* Read data from a file. */
+gceSTATUS
+gcoOS_Read(
+    IN gcoOS Os,
+    IN gctFILE File,
+    IN gctSIZE_T ByteCount,
+    IN gctPOINTER Data,
+    OUT gctSIZE_T * ByteRead
+    );
+
+/* Write data to a file. */
+gceSTATUS
+gcoOS_Write(
+    IN gcoOS Os,
+    IN gctFILE File,
+    IN gctSIZE_T ByteCount,
+    IN gctCONST_POINTER Data
+    );
+
+/* Flush data to a file. */
+gceSTATUS
+gcoOS_Flush(
+    IN gcoOS Os,
+    IN gctFILE File
+    );
+
+/* Create an endpoint for communication. */
+gceSTATUS
+gcoOS_Socket(
+    IN gcoOS Os,
+    IN gctINT Domain,
+    IN gctINT Type,
+    IN gctINT Protocol,
+    OUT gctINT *SockFd
+    );
+
+/* Close a socket. */
+gceSTATUS
+gcoOS_CloseSocket(
+    IN gcoOS Os,
+    IN gctINT SockFd
+    );
+
+/* Initiate a connection on a socket. */
+gceSTATUS
+gcoOS_Connect(
+    IN gcoOS Os,
+    IN gctINT SockFd,
+    IN gctCONST_POINTER HostName,
+    IN gctUINT Port);
+
+/* Shut down part of connection on a socket. */
+gceSTATUS
+gcoOS_Shutdown(
+    IN gcoOS Os,
+    IN gctINT SockFd,
+    IN gctINT How
+    );
+
+/* Send a message on a socket. */
+gceSTATUS
+gcoOS_Send(
+    IN gcoOS Os,
+    IN gctINT SockFd,
+    IN gctSIZE_T ByteCount,
+    IN gctCONST_POINTER Data,
+    IN gctINT Flags
+    );
+
+/* Initiate a connection on a socket. */
+gceSTATUS
+gcoOS_WaitForSend(
+    IN gcoOS Os,
+    IN gctINT SockFd,
+    IN gctINT Seconds,
+    IN gctINT MicroSeconds);
+
+/* Get environment variable value. */
+gceSTATUS
+gcoOS_GetEnv(
+    IN gcoOS Os,
+    IN gctCONST_STRING VarName,
+    OUT gctSTRING * Value
+    );
+
+/* Get current working directory. */
+gceSTATUS
+gcoOS_GetCwd(
+    IN gcoOS Os,
+	IN gctINT SizeInBytes,
+    OUT gctSTRING Buffer
+    );
+
+/* Get file status info. */
+gceSTATUS
+gcoOS_Stat(
+    IN gcoOS Os,
+    IN gctCONST_STRING FileName,
+    OUT gctPOINTER Buffer
+    );
+
+typedef enum _gceFILE_WHENCE
+{
+    gcvFILE_SEEK_SET,
+    gcvFILE_SEEK_CUR,
+    gcvFILE_SEEK_END
+}
+gceFILE_WHENCE;
+
+/* Set the current position of a file. */
+gceSTATUS
+gcoOS_Seek(
+    IN gcoOS Os,
+    IN gctFILE File,
+    IN gctUINT32 Offset,
+    IN gceFILE_WHENCE Whence
+    );
+
+/* Set the current position of a file. */
+gceSTATUS
+gcoOS_SetPos(
+    IN gcoOS Os,
+    IN gctFILE File,
+    IN gctUINT32 Position
+    );
+
+/* Get the current position of a file. */
+gceSTATUS
+gcoOS_GetPos(
+    IN gcoOS Os,
+    IN gctFILE File,
+    OUT gctUINT32 * Position
+    );
+
+/* Perform a memory copy. */
+gceSTATUS
+gcoOS_MemCopy(
+    IN gctPOINTER Destination,
+    IN gctCONST_POINTER Source,
+    IN gctSIZE_T Bytes
+    );
+
+/* Perform a memory fill. */
+gceSTATUS
+gcoOS_MemFill(
+    IN gctPOINTER Destination,
+    IN gctUINT8 Filler,
+    IN gctSIZE_T Bytes
+    );
+
+/* Zero memory. */
+gceSTATUS
+gcoOS_ZeroMemory(
+    IN gctPOINTER Memory,
+    IN gctSIZE_T Bytes
+    );
+
+/* Same as strstr. */
+gceSTATUS
+gcoOS_StrStr(
+    IN gctCONST_STRING String,
+    IN gctCONST_STRING SubString,
+    OUT gctSTRING * Output
+    );
+
+/* Find the last occurance of a character inside a string. */
+gceSTATUS
+gcoOS_StrFindReverse(
+    IN gctCONST_STRING String,
+    IN gctINT8 Character,
+    OUT gctSTRING * Output
+    );
+
+gceSTATUS
+gcoOS_StrLen(
+    IN gctCONST_STRING String,
+    OUT gctSIZE_T * Length
+    );
+
+gceSTATUS
+gcoOS_StrDup(
+    IN gcoOS Os,
+    IN gctCONST_STRING String,
+    OUT gctSTRING * Target
+    );
+
+/* Copy a string. */
+gceSTATUS
+gcoOS_StrCopySafe(
+    IN gctSTRING Destination,
+    IN gctSIZE_T DestinationSize,
+    IN gctCONST_STRING Source
+    );
+
+/* Append a string. */
+gceSTATUS
+gcoOS_StrCatSafe(
+    IN gctSTRING Destination,
+    IN gctSIZE_T DestinationSize,
+    IN gctCONST_STRING Source
+    );
+
+/* Compare two strings. */
+gceSTATUS
+gcoOS_StrCmp(
+    IN gctCONST_STRING String1,
+    IN gctCONST_STRING String2
+    );
+
+/* Compare characters of two strings. */
+gceSTATUS
+gcoOS_StrNCmp(
+    IN gctCONST_STRING String1,
+    IN gctCONST_STRING String2,
+    IN gctSIZE_T Count
+    );
+
+/* Convert string to float. */
+gceSTATUS
+gcoOS_StrToFloat(
+    IN gctCONST_STRING String,
+    OUT gctFLOAT * Float
+    );
+
+/* Convert hex string to integer. */
+gceSTATUS gcoOS_HexStrToInt(
+	IN gctCONST_STRING String,
+	OUT gctINT * Int
+	);
+
+/* Convert hex string to float. */
+gceSTATUS gcoOS_HexStrToFloat(
+	IN gctCONST_STRING String,
+	OUT gctFLOAT * Float
+	);
+
+/* Convert string to integer. */
+gceSTATUS
+gcoOS_StrToInt(
+    IN gctCONST_STRING String,
+    OUT gctINT * Int
+    );
+
+gceSTATUS
+gcoOS_MemCmp(
+    IN gctCONST_POINTER Memory1,
+    IN gctCONST_POINTER Memory2,
+    IN gctSIZE_T Bytes
+    );
+
+gceSTATUS
+gcoOS_PrintStrSafe(
+    OUT gctSTRING String,
+    IN gctSIZE_T StringSize,
+    IN OUT gctUINT * Offset,
+    IN gctCONST_STRING Format,
+    ...
+    );
+
+gceSTATUS
+gcoOS_LoadLibrary(
+    IN gcoOS Os,
+    IN gctCONST_STRING Library,
+    OUT gctHANDLE * Handle
+    );
+
+gceSTATUS
+gcoOS_FreeLibrary(
+    IN gcoOS Os,
+    IN gctHANDLE Handle
+    );
+
+gceSTATUS
+gcoOS_GetProcAddress(
+    IN gcoOS Os,
+    IN gctHANDLE Handle,
+    IN gctCONST_STRING Name,
+    OUT gctPOINTER * Function
+    );
+
+gceSTATUS
+gcoOS_Compact(
+    IN gcoOS Os
+    );
+
+gceSTATUS
+gcoOS_AddSignalHandler (
+    IN gceSignalHandlerType SignalHandlerType
+    );
+
+#if VIVANTE_PROFILER /*gcdENABLE_PROFILING*/
+gceSTATUS
+gcoOS_ProfileStart(
+    IN gcoOS Os
+    );
+
+gceSTATUS
+gcoOS_ProfileEnd(
+    IN gcoOS Os,
+    IN gctCONST_STRING Title
+    );
+
+gceSTATUS
+gcoOS_SetProfileSetting(
+        IN gcoOS Os,
+        IN gctBOOL Enable,
+        IN gctCONST_STRING FileName
+        );
+#endif
+
+/* Query the video memory. */
+gceSTATUS
+gcoOS_QueryVideoMemory(
+    IN gcoOS Os,
+    OUT gctPHYS_ADDR * InternalAddress,
+    OUT gctSIZE_T * InternalSize,
+    OUT gctPHYS_ADDR * ExternalAddress,
+    OUT gctSIZE_T * ExternalSize,
+    OUT gctPHYS_ADDR * ContiguousAddress,
+    OUT gctSIZE_T * ContiguousSize
+    );
+
+/* Detect if the process is the executable specified. */
+gceSTATUS
+gcoOS_DetectProcessByName(
+    IN gctCONST_STRING Name
+    );
+
+/*----------------------------------------------------------------------------*/
+/*----- Atoms ----------------------------------------------------------------*/
+
+typedef struct gcsATOM * gcsATOM_PTR;
+
+/* Construct an atom. */
+gceSTATUS
+gcoOS_AtomConstruct(
+    IN gcoOS Os,
+    OUT gcsATOM_PTR * Atom
+    );
+
+/* Destroy an atom. */
+gceSTATUS
+gcoOS_AtomDestroy(
+    IN gcoOS Os,
+    IN gcsATOM_PTR Atom
+    );
+
+/* Increment an atom. */
+gceSTATUS
+gcoOS_AtomIncrement(
+    IN gcoOS Os,
+    IN gcsATOM_PTR Atom,
+    OUT gctINT32_PTR OldValue
+    );
+
+/* Decrement an atom. */
+gceSTATUS
+gcoOS_AtomDecrement(
+    IN gcoOS Os,
+    IN gcsATOM_PTR Atom,
+    OUT gctINT32_PTR OldValue
+    );
+
+gctHANDLE
+gcoOS_GetCurrentProcessID(
+    void
+    );
+
+gctHANDLE
+gcoOS_GetCurrentThreadID(
+    void
+    );
+
+/*----------------------------------------------------------------------------*/
+/*----- Time -----------------------------------------------------------------*/
+
+/* Get the number of milliseconds since the system started. */
+gctUINT32
+gcoOS_GetTicks(
+    void
+    );
+
+/* Get time in microseconds. */
+gceSTATUS
+gcoOS_GetTime(
+    gctUINT64_PTR Time
+    );
+
+/* Get CPU usage in microseconds. */
+gceSTATUS
+gcoOS_GetCPUTime(
+    gctUINT64_PTR CPUTime
+    );
+
+/* Get memory usage. */
+gceSTATUS
+gcoOS_GetMemoryUsage(
+    gctUINT32_PTR MaxRSS,
+    gctUINT32_PTR IxRSS,
+    gctUINT32_PTR IdRSS,
+    gctUINT32_PTR IsRSS
+    );
+
+/* Delay a number of microseconds. */
+gceSTATUS
+gcoOS_Delay(
+    IN gcoOS Os,
+    IN gctUINT32 Delay
+    );
+
+/*----------------------------------------------------------------------------*/
+/*----- Threads --------------------------------------------------------------*/
+
+#ifdef _WIN32
+/* Cannot include windows.h here becuase "near" and "far"
+ * which are used in gcsDEPTH_INFO, are defined to nothing in WinDef.h.
+ * So, use the real value of DWORD and WINAPI, instead.
+ * DWORD is unsigned long, and WINAPI is __stdcall.
+ * If these two are change in WinDef.h, the following two typdefs
+ * need to be changed, too.
+ */
+typedef unsigned long gctTHREAD_RETURN;
+typedef unsigned long (__stdcall * gcTHREAD_ROUTINE)(void * Argument);
+#else
+typedef void * gctTHREAD_RETURN;
+typedef void * (* gcTHREAD_ROUTINE)(void *);
+#endif
+
+/* Create a new thread. */
+gceSTATUS
+gcoOS_CreateThread(
+    IN gcoOS Os,
+    IN gcTHREAD_ROUTINE Worker,
+    IN gctPOINTER Argument,
+    OUT gctPOINTER * Thread
+    );
+
+/* Close a thread. */
+gceSTATUS
+gcoOS_CloseThread(
+    IN gcoOS Os,
+    IN gctPOINTER Thread
+    );
+
+/*----------------------------------------------------------------------------*/
+/*----- Mutexes --------------------------------------------------------------*/
+
+/* Create a new mutex. */
+gceSTATUS
+gcoOS_CreateMutex(
+    IN gcoOS Os,
+    OUT gctPOINTER * Mutex
+    );
+
+/* Delete a mutex. */
+gceSTATUS
+gcoOS_DeleteMutex(
+    IN gcoOS Os,
+    IN gctPOINTER Mutex
+    );
+
+/* Acquire a mutex. */
+gceSTATUS
+gcoOS_AcquireMutex(
+    IN gcoOS Os,
+    IN gctPOINTER Mutex,
+    IN gctUINT32 Timeout
+    );
+
+/* Release a mutex. */
+gceSTATUS
+gcoOS_ReleaseMutex(
+    IN gcoOS Os,
+    IN gctPOINTER Mutex
+    );
+
+/*----------------------------------------------------------------------------*/
+/*----- Signals --------------------------------------------------------------*/
+
+/* Create a signal. */
+gceSTATUS
+gcoOS_CreateSignal(
+    IN gcoOS Os,
+    IN gctBOOL ManualReset,
+    OUT gctSIGNAL * Signal
+    );
+
+/* Destroy a signal. */
+gceSTATUS
+gcoOS_DestroySignal(
+    IN gcoOS Os,
+    IN gctSIGNAL Signal
+    );
+
+/* Signal a signal. */
+gceSTATUS
+gcoOS_Signal(
+    IN gcoOS Os,
+    IN gctSIGNAL Signal,
+    IN gctBOOL State
+    );
+
+/* Wait for a signal. */
+gceSTATUS
+gcoOS_WaitSignal(
+    IN gcoOS Os,
+    IN gctSIGNAL Signal,
+    IN gctUINT32 Wait
+    );
+
+/* Map a signal from another process */
+gceSTATUS
+gcoOS_MapSignal(
+    IN gctSIGNAL  RemoteSignal,
+    OUT gctSIGNAL * LocalSignal
+    );
+
+/* Unmap a signal mapped from another process */
+gceSTATUS
+gcoOS_UnmapSignal(
+    IN gctSIGNAL Signal
+    );
+
+/* Write a register. */
+gceSTATUS
+gcoOS_WriteRegister(
+    IN gcoOS Os,
+    IN gctUINT32 Address,
+    IN gctUINT32 Data
+    );
+
+/* Read a register. */
+gceSTATUS
+gcoOS_ReadRegister(
+    IN gcoOS Os,
+    IN gctUINT32 Address,
+    OUT gctUINT32 * Data
+    );
+
+gceSTATUS
+gcoOS_CacheClean(
+    IN gcoOS Os,
+    IN gcuVIDMEM_NODE_PTR Node,
+    IN gctPOINTER Logical,
+    IN gctSIZE_T Bytes
+    );
+
+gceSTATUS
+gcoOS_CacheFlush(
+    IN gcoOS Os,
+    IN gcuVIDMEM_NODE_PTR Node,
+    IN gctPOINTER Logical,
+    IN gctSIZE_T Bytes
+    );
+
+gceSTATUS
+gcoOS_CacheInvalidate(
+    IN gcoOS Os,
+    IN gcuVIDMEM_NODE_PTR Node,
+    IN gctPOINTER Logical,
+    IN gctSIZE_T Bytes
+    );
+
+gceSTATUS
+gcoOS_MemoryBarrier(
+    IN gcoOS Os,
+    IN gctPOINTER Logical
+    );
+
+
+/*----------------------------------------------------------------------------*/
+/*----- Profile --------------------------------------------------------------*/
+
+gceSTATUS
+gckOS_GetProfileTick(
+    OUT gctUINT64_PTR Tick
+    );
+
+gceSTATUS
+gckOS_QueryProfileTickRate(
+    OUT gctUINT64_PTR TickRate
+    );
+
+gctUINT32
+gckOS_ProfileToMS(
+    IN gctUINT64 Ticks
+    );
+
+gceSTATUS
+gcoOS_GetProfileTick(
+    OUT gctUINT64_PTR Tick
+    );
+
+gceSTATUS
+gcoOS_QueryProfileTickRate(
+    OUT gctUINT64_PTR TickRate
+    );
+
+#define _gcmPROFILE_INIT(prefix, freq, start) \
+    do { \
+        prefix ## OS_QueryProfileTickRate(&(freq)); \
+        prefix ## OS_GetProfileTick(&(start)); \
+    } while (gcvFALSE)
+
+#define _gcmPROFILE_QUERY(prefix, start, ticks) \
+    do { \
+        prefix ## OS_GetProfileTick(&(ticks)); \
+        (ticks) = ((ticks) > (start)) ? ((ticks) - (start)) \
+                                      : (~0ull - (start) + (ticks) + 1); \
+    } while (gcvFALSE)
+
+#if gcdENABLE_PROFILING
+#   define gcmkPROFILE_INIT(freq, start)    _gcmPROFILE_INIT(gck, freq, start)
+#   define gcmkPROFILE_QUERY(start, ticks)  _gcmPROFILE_QUERY(gck, start, ticks)
+#   define gcmPROFILE_INIT(freq, start)     _gcmPROFILE_INIT(gco, freq, start)
+#   define gcmPROFILE_QUERY(start, ticks)   _gcmPROFILE_QUERY(gco, start, ticks)
+#   define gcmPROFILE_ONLY(x)               x
+#   define gcmPROFILE_ELSE(x)               do { } while (gcvFALSE)
+#   define gcmPROFILE_DECLARE_ONLY(x)       x
+#   define gcmPROFILE_DECLARE_ELSE(x)       typedef x
+#else
+#   define gcmkPROFILE_INIT(start, freq)    do { } while (gcvFALSE)
+#   define gcmkPROFILE_QUERY(start, ticks)  do { } while (gcvFALSE)
+#   define gcmPROFILE_INIT(start, freq)     do { } while (gcvFALSE)
+#   define gcmPROFILE_QUERY(start, ticks)   do { } while (gcvFALSE)
+#   define gcmPROFILE_ONLY(x)               do { } while (gcvFALSE)
+#   define gcmPROFILE_ELSE(x)               x
+#   define gcmPROFILE_DECLARE_ONLY(x)       typedef x
+#   define gcmPROFILE_DECLARE_ELSE(x)       x
+#endif
+
+/*******************************************************************************
+**  gcoMATH object
+*/
+
+#define gcdPI                   3.14159265358979323846f
+
+/* Kernel. */
+gctINT
+gckMATH_ModuloInt(
+    IN gctINT X,
+    IN gctINT Y
+    );
+
+/* User. */
+gctUINT32
+gcoMATH_Log2in5dot5(
+    IN gctINT X
+    );
+
+
+gctFLOAT
+gcoMATH_UIntAsFloat(
+    IN gctUINT32 X
+    );
+
+gctUINT32
+gcoMATH_FloatAsUInt(
+    IN gctFLOAT X
+    );
+
+gctBOOL
+gcoMATH_CompareEqualF(
+    IN gctFLOAT X,
+    IN gctFLOAT Y
+    );
+
+gctUINT16
+gcoMATH_UInt8AsFloat16(
+    IN gctUINT8 X
+    );
+
+/******************************************************************************\
+**************************** Coordinate Structures *****************************
+\******************************************************************************/
+
+typedef struct _gcsPOINT
+{
+    gctINT32                    x;
+    gctINT32                    y;
+}
+gcsPOINT;
+
+typedef struct _gcsSIZE
+{
+    gctINT32                    width;
+    gctINT32                    height;
+}
+gcsSIZE;
+
+typedef struct _gcsRECT
+{
+    gctINT32                    left;
+    gctINT32                    top;
+    gctINT32                    right;
+    gctINT32                    bottom;
+}
+gcsRECT;
+
+
+/******************************************************************************\
+********************************* gcoSURF Object ********************************
+\******************************************************************************/
+
+/*----------------------------------------------------------------------------*/
+/*------------------------------- gcoSURF Common ------------------------------*/
+
+/* Color format classes. */
+typedef enum _gceFORMAT_CLASS
+{
+    gcvFORMAT_CLASS_RGBA        = 4500,
+    gcvFORMAT_CLASS_YUV,
+    gcvFORMAT_CLASS_INDEX,
+    gcvFORMAT_CLASS_LUMINANCE,
+    gcvFORMAT_CLASS_BUMP,
+    gcvFORMAT_CLASS_DEPTH,
+}
+gceFORMAT_CLASS;
+
+/* Special enums for width field in gcsFORMAT_COMPONENT. */
+typedef enum _gceCOMPONENT_CONTROL
+{
+    gcvCOMPONENT_NOTPRESENT     = 0x00,
+    gcvCOMPONENT_DONTCARE       = 0x80,
+    gcvCOMPONENT_WIDTHMASK      = 0x7F,
+    gcvCOMPONENT_ODD            = 0x80
+}
+gceCOMPONENT_CONTROL;
+
+/* Color format component parameters. */
+typedef struct _gcsFORMAT_COMPONENT
+{
+    gctUINT8                    start;
+    gctUINT8                    width;
+}
+gcsFORMAT_COMPONENT;
+
+/* RGBA color format class. */
+typedef struct _gcsFORMAT_CLASS_TYPE_RGBA
+{
+    gcsFORMAT_COMPONENT         alpha;
+    gcsFORMAT_COMPONENT         red;
+    gcsFORMAT_COMPONENT         green;
+    gcsFORMAT_COMPONENT         blue;
+}
+gcsFORMAT_CLASS_TYPE_RGBA;
+
+/* YUV color format class. */
+typedef struct _gcsFORMAT_CLASS_TYPE_YUV
+{
+    gcsFORMAT_COMPONENT         y;
+    gcsFORMAT_COMPONENT         u;
+    gcsFORMAT_COMPONENT         v;
+}
+gcsFORMAT_CLASS_TYPE_YUV;
+
+/* Index color format class. */
+typedef struct _gcsFORMAT_CLASS_TYPE_INDEX
+{
+    gcsFORMAT_COMPONENT         value;
+}
+gcsFORMAT_CLASS_TYPE_INDEX;
+
+/* Luminance color format class. */
+typedef struct _gcsFORMAT_CLASS_TYPE_LUMINANCE
+{
+    gcsFORMAT_COMPONENT         alpha;
+    gcsFORMAT_COMPONENT         value;
+}
+gcsFORMAT_CLASS_TYPE_LUMINANCE;
+
+/* Bump map color format class. */
+typedef struct _gcsFORMAT_CLASS_TYPE_BUMP
+{
+    gcsFORMAT_COMPONENT         alpha;
+    gcsFORMAT_COMPONENT         l;
+    gcsFORMAT_COMPONENT         v;
+    gcsFORMAT_COMPONENT         u;
+    gcsFORMAT_COMPONENT         q;
+    gcsFORMAT_COMPONENT         w;
+}
+gcsFORMAT_CLASS_TYPE_BUMP;
+
+/* Depth and stencil format class. */
+typedef struct _gcsFORMAT_CLASS_TYPE_DEPTH
+{
+    gcsFORMAT_COMPONENT         depth;
+    gcsFORMAT_COMPONENT         stencil;
+}
+gcsFORMAT_CLASS_TYPE_DEPTH;
+
+/* Format parameters. */
+typedef struct _gcsSURF_FORMAT_INFO
+{
+    /* Format code and class. */
+    gceSURF_FORMAT              format;
+    gceFORMAT_CLASS             fmtClass;
+
+    /* The size of one pixel in bits. */
+    gctUINT8                    bitsPerPixel;
+
+    /* Component swizzle. */
+    gceSURF_SWIZZLE             swizzle;
+
+    /* Some formats have two neighbour pixels interleaved together. */
+    /* To describe such format, set the flag to 1 and add another   */
+    /* like this one describing the odd pixel format.               */
+    gctUINT8                    interleaved;
+
+    /* Format components. */
+    union
+    {
+        gcsFORMAT_CLASS_TYPE_BUMP       bump;
+        gcsFORMAT_CLASS_TYPE_RGBA       rgba;
+        gcsFORMAT_CLASS_TYPE_YUV        yuv;
+        gcsFORMAT_CLASS_TYPE_LUMINANCE  lum;
+        gcsFORMAT_CLASS_TYPE_INDEX      index;
+        gcsFORMAT_CLASS_TYPE_DEPTH      depth;
+    } u;
+}
+gcsSURF_FORMAT_INFO;
+
+/* Frame buffer information. */
+typedef struct _gcsSURF_FRAMEBUFFER
+{
+    gctPOINTER                  logical;
+    gctUINT                     width, height;
+    gctINT                      stride;
+    gceSURF_FORMAT              format;
+}
+gcsSURF_FRAMEBUFFER;
+
+typedef struct _gcsVIDMEM_NODE_SHARED_INFO
+{
+    gctBOOL                     tileStatusDisabled;
+    gcsPOINT                    SrcOrigin;
+    gcsPOINT                    DestOrigin;
+    gcsSIZE                     RectSize;
+    gctUINT32                   clearValue;
+}
+gcsVIDMEM_NODE_SHARED_INFO;
+
+/* Generic pixel component descriptors. */
+extern gcsFORMAT_COMPONENT gcvPIXEL_COMP_XXX8;
+extern gcsFORMAT_COMPONENT gcvPIXEL_COMP_XX8X;
+extern gcsFORMAT_COMPONENT gcvPIXEL_COMP_X8XX;
+extern gcsFORMAT_COMPONENT gcvPIXEL_COMP_8XXX;
+
+typedef enum _gceORIENTATION
+{
+    gcvORIENTATION_TOP_BOTTOM,
+    gcvORIENTATION_BOTTOM_TOP,
+}
+gceORIENTATION;
+
+
+/* Construct a new gcoSURF object. */
+gceSTATUS
+gcoSURF_Construct(
+    IN gcoHAL Hal,
+    IN gctUINT Width,
+    IN gctUINT Height,
+    IN gctUINT Depth,
+    IN gceSURF_TYPE Type,
+    IN gceSURF_FORMAT Format,
+    IN gcePOOL Pool,
+    OUT gcoSURF * Surface
+    );
+
+/* Destroy an gcoSURF object. */
+gceSTATUS
+gcoSURF_Destroy(
+    IN gcoSURF Surface
+    );
+
+/* Map user-allocated surface. */
+gceSTATUS
+gcoSURF_MapUserSurface(
+    IN gcoSURF Surface,
+    IN gctUINT Alignment,
+    IN gctPOINTER Logical,
+    IN gctUINT32 Physical
+    );
+
+/* Query vid mem node info. */
+gceSTATUS
+gcoSURF_QueryVidMemNode(
+    IN gcoSURF Surface,
+    OUT gcuVIDMEM_NODE_PTR * Node,
+    OUT gcePOOL * Pool,
+    OUT gctUINT_PTR Bytes
+    );
+
+/*  Set usage attribute of a surface. */
+gceSTATUS
+gcoSURF_SetUsage(
+    IN gcoSURF Surface,
+    IN gceSURF_USAGE Usage
+    );
+
+/*  Return usage attribute of a surface. */
+gceSTATUS
+gcoSURF_QueryUsage(
+    IN gcoSURF Surface,
+    OUT gceSURF_USAGE *Usage
+    );
+
+/* Set the color type of the surface. */
+gceSTATUS
+gcoSURF_SetColorType(
+    IN gcoSURF Surface,
+    IN gceSURF_COLOR_TYPE ColorType
+    );
+
+/* Get the color type of the surface. */
+gceSTATUS
+gcoSURF_GetColorType(
+    IN gcoSURF Surface,
+    OUT gceSURF_COLOR_TYPE *ColorType
+    );
+
+/* Set the surface ration angle. */
+gceSTATUS
+gcoSURF_SetRotation(
+    IN gcoSURF Surface,
+    IN gceSURF_ROTATION Rotation
+    );
+
+gceSTATUS
+gcoSURF_IsValid(
+    IN gcoSURF Surface
+    );
+
+#ifndef VIVANTE_NO_3D
+/* Verify and return the state of the tile status mechanism. */
+gceSTATUS
+gcoSURF_IsTileStatusSupported(
+    IN gcoSURF Surface
+    );
+
+/* Process tile status for the specified surface. */
+gceSTATUS
+gcoSURF_SetTileStatus(
+    IN gcoSURF Surface
+    );
+
+/* Enable tile status for the specified surface. */
+gceSTATUS
+gcoSURF_EnableTileStatus(
+    IN gcoSURF Surface
+    );
+
+/* Disable tile status for the specified surface. */
+gceSTATUS
+gcoSURF_DisableTileStatus(
+    IN gcoSURF Surface,
+    IN gctBOOL Decompress
+    );
+#endif /* VIVANTE_NO_3D */
+
+/* Get surface size. */
+gceSTATUS
+gcoSURF_GetSize(
+    IN gcoSURF Surface,
+    OUT gctUINT * Width,
+    OUT gctUINT * Height,
+    OUT gctUINT * Depth
+    );
+
+/* Get surface aligned sizes. */
+gceSTATUS
+gcoSURF_GetAlignedSize(
+    IN gcoSURF Surface,
+    OUT gctUINT * Width,
+    OUT gctUINT * Height,
+    OUT gctINT * Stride
+    );
+
+/* Get alignments. */
+gceSTATUS
+gcoSURF_GetAlignment(
+    IN gceSURF_TYPE Type,
+    IN gceSURF_FORMAT Format,
+    OUT gctUINT * AddressAlignment,
+    OUT gctUINT * XAlignment,
+    OUT gctUINT * YAlignment
+    );
+
+/* Get surface type and format. */
+gceSTATUS
+gcoSURF_GetFormat(
+    IN gcoSURF Surface,
+    OUT gceSURF_TYPE * Type,
+    OUT gceSURF_FORMAT * Format
+    );
+
+/* Get surface tiling. */
+gceSTATUS
+gcoSURF_GetTiling(
+    IN gcoSURF Surface,
+    OUT gceTILING * Tiling
+    );
+
+/* Lock the surface. */
+gceSTATUS
+gcoSURF_Lock(
+    IN gcoSURF Surface,
+    IN OUT gctUINT32 * Address,
+    IN OUT gctPOINTER * Memory
+    );
+
+/* Unlock the surface. */
+gceSTATUS
+gcoSURF_Unlock(
+    IN gcoSURF Surface,
+    IN gctPOINTER Memory
+    );
+
+/* Return pixel format parameters. */
+gceSTATUS
+gcoSURF_QueryFormat(
+    IN gceSURF_FORMAT Format,
+    OUT gcsSURF_FORMAT_INFO_PTR * Info
+    );
+
+/* Compute the color pixel mask. */
+gceSTATUS
+gcoSURF_ComputeColorMask(
+    IN gcsSURF_FORMAT_INFO_PTR Format,
+    OUT gctUINT32_PTR ColorMask
+    );
+
+/* Flush the surface. */
+gceSTATUS
+gcoSURF_Flush(
+    IN gcoSURF Surface
+    );
+
+/* Fill surface from it's tile status buffer. */
+gceSTATUS
+gcoSURF_FillFromTile(
+    IN gcoSURF Surface
+    );
+
+/* Fill surface with a value. */
+gceSTATUS
+gcoSURF_Fill(
+    IN gcoSURF Surface,
+    IN gcsPOINT_PTR Origin,
+    IN gcsSIZE_PTR Size,
+    IN gctUINT32 Value,
+    IN gctUINT32 Mask
+    );
+
+/* Alpha blend two surfaces together. */
+gceSTATUS
+gcoSURF_Blend(
+    IN gcoSURF SrcSurface,
+    IN gcoSURF DestSurface,
+    IN gcsPOINT_PTR SrcOrig,
+    IN gcsPOINT_PTR DestOrigin,
+    IN gcsSIZE_PTR Size,
+    IN gceSURF_BLEND_MODE Mode
+    );
+
+/* Create a new gcoSURF wrapper object. */
+gceSTATUS
+gcoSURF_ConstructWrapper(
+    IN gcoHAL Hal,
+    OUT gcoSURF * Surface
+    );
+
+/* Set the underlying buffer for the surface wrapper. */
+gceSTATUS
+gcoSURF_SetBuffer(
+    IN gcoSURF Surface,
+    IN gceSURF_TYPE Type,
+    IN gceSURF_FORMAT Format,
+    IN gctUINT Stride,
+    IN gctPOINTER Logical,
+    IN gctUINT32 Physical
+    );
+
+/* Set the size of the surface in pixels and map the underlying buffer. */
+gceSTATUS
+gcoSURF_SetWindow(
+    IN gcoSURF Surface,
+    IN gctUINT X,
+    IN gctUINT Y,
+    IN gctUINT Width,
+    IN gctUINT Height
+    );
+
+/* Increase reference count of the surface. */
+gceSTATUS
+gcoSURF_ReferenceSurface(
+    IN gcoSURF Surface
+    );
+
+/* Get surface reference count. */
+gceSTATUS
+gcoSURF_QueryReferenceCount(
+    IN gcoSURF Surface,
+    OUT gctINT32 * ReferenceCount
+    );
+
+/* Set surface orientation. */
+gceSTATUS
+gcoSURF_SetOrientation(
+    IN gcoSURF Surface,
+    IN gceORIENTATION Orientation
+    );
+
+/* Query surface orientation. */
+gceSTATUS
+gcoSURF_QueryOrientation(
+    IN gcoSURF Surface,
+    OUT gceORIENTATION * Orientation
+    );
+
+gceSTATUS
+gcoSURF_SetOffset(
+    IN gcoSURF Surface,
+    IN gctUINT Offset
+    );
+
+gceSTATUS
+gcoSURF_NODE_Cache(
+    IN gcsSURF_NODE_PTR Node,
+    IN gctPOINTER Logical,
+    IN gctSIZE_T Bytes,
+    IN gceCACHEOPERATION Operation
+    );
+
+/* Perform CPU cache operation on surface */
+gceSTATUS
+gcoSURF_CPUCacheOperation(
+    IN gcoSURF Surface,
+    IN gceCACHEOPERATION Operation
+    );
+
+
+gceSTATUS
+gcoSURF_SetLinearResolveAddress(
+    IN gcoSURF Surface,
+    IN gctUINT32 Address,
+    IN gctPOINTER Memory
+    );
+/******************************************************************************\
+********************************* gcoDUMP Object ********************************
+\******************************************************************************/
+
+/* Construct a new gcoDUMP object. */
+gceSTATUS
+gcoDUMP_Construct(
+    IN gcoOS Os,
+    IN gcoHAL Hal,
+    OUT gcoDUMP * Dump
+    );
+
+/* Destroy a gcoDUMP object. */
+gceSTATUS
+gcoDUMP_Destroy(
+    IN gcoDUMP Dump
+    );
+
+/* Enable/disable dumping. */
+gceSTATUS
+gcoDUMP_Control(
+    IN gcoDUMP Dump,
+    IN gctSTRING FileName
+    );
+
+gceSTATUS
+gcoDUMP_IsEnabled(
+    IN gcoDUMP Dump,
+    OUT gctBOOL * Enabled
+    );
+
+/* Add surface. */
+gceSTATUS
+gcoDUMP_AddSurface(
+    IN gcoDUMP Dump,
+    IN gctINT32 Width,
+    IN gctINT32 Height,
+    IN gceSURF_FORMAT PixelFormat,
+    IN gctUINT32 Address,
+    IN gctSIZE_T ByteCount
+    );
+
+/* Mark the beginning of a frame. */
+gceSTATUS
+gcoDUMP_FrameBegin(
+    IN gcoDUMP Dump
+    );
+
+/* Mark the end of a frame. */
+gceSTATUS
+gcoDUMP_FrameEnd(
+    IN gcoDUMP Dump
+    );
+
+/* Dump data. */
+gceSTATUS
+gcoDUMP_DumpData(
+    IN gcoDUMP Dump,
+    IN gceDUMP_TAG Type,
+    IN gctUINT32 Address,
+    IN gctSIZE_T ByteCount,
+    IN gctCONST_POINTER Data
+    );
+
+/* Delete an address. */
+gceSTATUS
+gcoDUMP_Delete(
+    IN gcoDUMP Dump,
+    IN gctUINT32 Address
+    );
+
+
+/******************************************************************************\
+******************************* gcsRECT Structure ******************************
+\******************************************************************************/
+
+/* Initialize rectangle structure. */
+gceSTATUS
+gcsRECT_Set(
+    OUT gcsRECT_PTR Rect,
+    IN gctINT32 Left,
+    IN gctINT32 Top,
+    IN gctINT32 Right,
+    IN gctINT32 Bottom
+    );
+
+/* Return the width of the rectangle. */
+gceSTATUS
+gcsRECT_Width(
+    IN gcsRECT_PTR Rect,
+    OUT gctINT32 * Width
+    );
+
+/* Return the height of the rectangle. */
+gceSTATUS
+gcsRECT_Height(
+    IN gcsRECT_PTR Rect,
+    OUT gctINT32 * Height
+    );
+
+/* Ensure that top left corner is to the left and above the right bottom. */
+gceSTATUS
+gcsRECT_Normalize(
+    IN OUT gcsRECT_PTR Rect
+    );
+
+/* Compare two rectangles. */
+gceSTATUS
+gcsRECT_IsEqual(
+    IN gcsRECT_PTR Rect1,
+    IN gcsRECT_PTR Rect2,
+    OUT gctBOOL * Equal
+    );
+
+/* Compare the sizes of two rectangles. */
+gceSTATUS
+gcsRECT_IsOfEqualSize(
+    IN gcsRECT_PTR Rect1,
+    IN gcsRECT_PTR Rect2,
+    OUT gctBOOL * EqualSize
+    );
+
+gceSTATUS
+gcsRECT_RelativeRotation(
+    IN gceSURF_ROTATION Orientation,
+    IN OUT gceSURF_ROTATION *Relation);
+
+gceSTATUS
+
+gcsRECT_Rotate(
+
+    IN OUT gcsRECT_PTR Rect,
+
+    IN gceSURF_ROTATION Rotation,
+
+    IN gceSURF_ROTATION toRotation,
+
+    IN gctINT32 SurfaceWidth,
+
+    IN gctINT32 SurfaceHeight
+
+    );
+
+/******************************************************************************\
+**************************** gcsBOUNDARY Structure *****************************
+\******************************************************************************/
+
+typedef struct _gcsBOUNDARY
+{
+    gctINT                      x;
+    gctINT                      y;
+    gctINT                      width;
+    gctINT                      height;
+}
+gcsBOUNDARY;
+
+/******************************************************************************\
+********************************* gcoHEAP Object ********************************
+\******************************************************************************/
+
+typedef struct _gcoHEAP *       gcoHEAP;
+
+/* Construct a new gcoHEAP object. */
+gceSTATUS
+gcoHEAP_Construct(
+    IN gcoOS Os,
+    IN gctSIZE_T AllocationSize,
+    OUT gcoHEAP * Heap
+    );
+
+/* Destroy an gcoHEAP object. */
+gceSTATUS
+gcoHEAP_Destroy(
+    IN gcoHEAP Heap
+    );
+
+/* Allocate memory. */
+gceSTATUS
+gcoHEAP_Allocate(
+    IN gcoHEAP Heap,
+    IN gctSIZE_T Bytes,
+    OUT gctPOINTER * Node
+    );
+
+gceSTATUS
+gcoHEAP_GetMemorySize(
+    IN gcoHEAP Heap,
+    IN gctPOINTER Memory,
+    OUT gctSIZE_T_PTR MemorySize
+    );
+
+/* Free memory. */
+gceSTATUS
+gcoHEAP_Free(
+    IN gcoHEAP Heap,
+    IN gctPOINTER Node
+    );
+
+#if (VIVANTE_PROFILER /*gcdENABLE_PROFILING*/ || gcdDEBUG)
+/* Profile the heap. */
+gceSTATUS
+gcoHEAP_ProfileStart(
+    IN gcoHEAP Heap
+    );
+
+gceSTATUS
+gcoHEAP_ProfileEnd(
+    IN gcoHEAP Heap,
+    IN gctCONST_STRING Title
+    );
+#endif
+
+
+/******************************************************************************\
+******************************* Debugging Macros *******************************
+\******************************************************************************/
+
+void
+gcoOS_SetDebugLevel(
+    IN gctUINT32 Level
+    );
+
+void
+gcoOS_GetDebugLevel(
+    OUT gctUINT32_PTR DebugLevel
+    );
+
+void
+gcoOS_SetDebugZone(
+    IN gctUINT32 Zone
+    );
+
+void
+gcoOS_GetDebugZone(
+    IN gctUINT32 Zone,
+    OUT gctUINT32_PTR DebugZone
+    );
+
+void
+gcoOS_SetDebugLevelZone(
+    IN gctUINT32 Level,
+    IN gctUINT32 Zone
+    );
+
+void
+gcoOS_SetDebugZones(
+    IN gctUINT32 Zones,
+    IN gctBOOL Enable
+    );
+
+void
+gcoOS_SetDebugFile(
+    IN gctCONST_STRING FileName
+    );
+
+gctFILE
+gcoOS_ReplaceDebugFile(
+    IN gctFILE fp
+	);
+
+/*******************************************************************************
+**
+**  gcmFATAL
+**
+**      Print a message to the debugger and execute a break point.
+**
+**  ARGUMENTS:
+**
+**      message Message.
+**      ...     Optional arguments.
+*/
+
+void
+gckOS_DebugFatal(
+    IN gctCONST_STRING Message,
+    ...
+    );
+
+void
+gcoOS_DebugFatal(
+    IN gctCONST_STRING Message,
+    ...
+    );
+
+#if gcmIS_DEBUG(gcdDEBUG_FATAL)
+#   define gcmFATAL             gcoOS_DebugFatal
+#   define gcmkFATAL            gckOS_DebugFatal
+#elif gcdHAS_ELLIPSES
+#   define gcmFATAL(...)
+#   define gcmkFATAL(...)
+#else
+    gcmINLINE static void
+    __dummy_fatal(
+        IN gctCONST_STRING Message,
+        ...
+        )
+    {
+    }
+#   define gcmFATAL             __dummy_fatal
+#   define gcmkFATAL            __dummy_fatal
+#endif
+
+#define gcmENUM2TEXT(e)         case e: return #e
+
+/*******************************************************************************
+**
+**  gcmTRACE
+**
+**      Print a message to the debugfer if the correct level has been set.  In
+**      retail mode this macro does nothing.
+**
+**  ARGUMENTS:
+**
+**      level   Level of message.
+**      message Message.
+**      ...     Optional arguments.
+*/
+#define gcvLEVEL_NONE           -1
+#define gcvLEVEL_ERROR          0
+#define gcvLEVEL_WARNING        1
+#define gcvLEVEL_INFO           2
+#define gcvLEVEL_VERBOSE        3
+
+void
+gckOS_DebugTrace(
+    IN gctUINT32 Level,
+    IN gctCONST_STRING Message,
+    ...
+    );
+
+void
+gckOS_DebugTraceN(
+    IN gctUINT32 Level,
+    IN gctUINT ArgumentSize,
+    IN gctCONST_STRING Message,
+    ...
+    );
+
+void
+gcoOS_DebugTrace(
+    IN gctUINT32 Level,
+    IN gctCONST_STRING Message,
+    ...
+    );
+
+#if gcmIS_DEBUG(gcdDEBUG_TRACE)
+#   define gcmTRACE             gcoOS_DebugTrace
+#   define gcmkTRACE            gckOS_DebugTrace
+#   define gcmkTRACE_N          gckOS_DebugTraceN
+#elif gcdHAS_ELLIPSES
+#   define gcmTRACE(...)
+#   define gcmkTRACE(...)
+#   define gcmkTRACE_N(...)
+#else
+    gcmINLINE static void
+    __dummy_trace(
+        IN gctUINT32 Level,
+        IN gctCONST_STRING Message,
+        ...
+        )
+    {
+    }
+
+    gcmINLINE static void
+    __dummy_trace_n(
+        IN gctUINT32 Level,
+        IN gctUINT ArgumentSize,
+        IN gctCONST_STRING Message,
+        ...
+        )
+    {
+    }
+
+#   define gcmTRACE             __dummy_trace
+#   define gcmkTRACE            __dummy_trace
+#   define gcmkTRACE_N          __dummy_trace_n
+#endif
+
+/* Zones common for kernel and user. */
+#define gcvZONE_OS              (1 << 0)
+#define gcvZONE_HARDWARE        (1 << 1)
+#define gcvZONE_HEAP            (1 << 2)
+#define gcvZONE_SIGNAL          (1 << 27)
+
+/* Kernel zones. */
+#define gcvZONE_KERNEL          (1 << 3)
+#define gcvZONE_VIDMEM          (1 << 4)
+#define gcvZONE_COMMAND         (1 << 5)
+#define gcvZONE_DRIVER          (1 << 6)
+#define gcvZONE_CMODEL          (1 << 7)
+#define gcvZONE_MMU             (1 << 8)
+#define gcvZONE_EVENT           (1 << 9)
+#define gcvZONE_DEVICE          (1 << 10)
+#define gcvZONE_DATABASE        (1 << 11)
+#define gcvZONE_INTERRUPT       (1 << 12)
+
+/* User zones. */
+#define gcvZONE_HAL             (1 << 3)
+#define gcvZONE_BUFFER          (1 << 4)
+#define gcvZONE_CONTEXT         (1 << 5)
+#define gcvZONE_SURFACE         (1 << 6)
+#define gcvZONE_INDEX           (1 << 7)
+#define gcvZONE_STREAM          (1 << 8)
+#define gcvZONE_TEXTURE         (1 << 9)
+#define gcvZONE_2D              (1 << 10)
+#define gcvZONE_3D              (1 << 11)
+#define gcvZONE_COMPILER        (1 << 12)
+#define gcvZONE_MEMORY          (1 << 13)
+#define gcvZONE_STATE           (1 << 14)
+#define gcvZONE_AUX             (1 << 15)
+#define gcvZONE_VERTEX          (1 << 16)
+#define gcvZONE_CL              (1 << 17)
+#define gcvZONE_COMPOSITION     (1 << 17)
+#define gcvZONE_VG              (1 << 18)
+#define gcvZONE_IMAGE           (1 << 19)
+#define gcvZONE_UTILITY         (1 << 20)
+#define gcvZONE_PARAMETERS      (1 << 21)
+
+/* API definitions. */
+#define gcvZONE_API_HAL         (1 << 28)
+#define gcvZONE_API_EGL         (2 << 28)
+#define gcvZONE_API_ES11        (3 << 28)
+#define gcvZONE_API_ES20        (4 << 28)
+#define gcvZONE_API_VG11        (5 << 28)
+#define gcvZONE_API_GL          (6 << 28)
+#define gcvZONE_API_DFB         (7 << 28)
+#define gcvZONE_API_GDI         (8 << 28)
+#define gcvZONE_API_D3D         (9 << 28)
+
+
+#define gcmZONE_GET_API(zone)   ((zone) >> 28)
+/*Set gcdZONE_MASE like 0x0 | gcvZONE_API_EGL
+will enable print EGL module debug info*/
+#define gcdZONE_MASK            0x0FFFFFFF
+
+/* Handy zones. */
+#define gcvZONE_NONE            0
+#define gcvZONE_ALL             0x0FFFFFFF
+
+/*Dump API depth set 1 for API, 2 for API and API behavior*/
+#define gcvDUMP_API_DEPTH       1
+
+/*******************************************************************************
+**
+**  gcmTRACE_ZONE
+**
+**      Print a message to the debugger if the correct level and zone has been
+**      set.  In retail mode this macro does nothing.
+**
+**  ARGUMENTS:
+**
+**      Level   Level of message.
+**      Zone    Zone of message.
+**      Message Message.
+**      ...     Optional arguments.
+*/
+
+void
+gckOS_DebugTraceZone(
+    IN gctUINT32 Level,
+    IN gctUINT32 Zone,
+    IN gctCONST_STRING Message,
+    ...
+    );
+
+void
+gckOS_DebugTraceZoneN(
+    IN gctUINT32 Level,
+    IN gctUINT32 Zone,
+    IN gctUINT ArgumentSize,
+    IN gctCONST_STRING Message,
+    ...
+    );
+
+void
+gcoOS_DebugTraceZone(
+    IN gctUINT32 Level,
+    IN gctUINT32 Zone,
+    IN gctCONST_STRING Message,
+    ...
+    );
+
+#if gcmIS_DEBUG(gcdDEBUG_TRACE)
+#   define gcmTRACE_ZONE            gcoOS_DebugTraceZone
+#   define gcmkTRACE_ZONE           gckOS_DebugTraceZone
+#   define gcmkTRACE_ZONE_N         gckOS_DebugTraceZoneN
+#elif gcdHAS_ELLIPSES
+#   define gcmTRACE_ZONE(...)
+#   define gcmkTRACE_ZONE(...)
+#   define gcmkTRACE_ZONE_N(...)
+#else
+    gcmINLINE static void
+    __dummy_trace_zone(
+        IN gctUINT32 Level,
+        IN gctUINT32 Zone,
+        IN gctCONST_STRING Message,
+        ...
+        )
+    {
+    }
+
+    gcmINLINE static void
+    __dummy_trace_zone_n(
+        IN gctUINT32 Level,
+        IN gctUINT32 Zone,
+        IN gctUINT ArgumentSize,
+        IN gctCONST_STRING Message,
+        ...
+        )
+    {
+    }
+
+#   define gcmTRACE_ZONE            __dummy_trace_zone
+#   define gcmkTRACE_ZONE           __dummy_trace_zone
+#   define gcmkTRACE_ZONE_N         __dummy_trace_zone_n
+#endif
+
+/*******************************************************************************
+**
+**  gcmDEBUG_ONLY
+**
+**      Execute a statement or function only in DEBUG mode.
+**
+**  ARGUMENTS:
+**
+**      f       Statement or function to execute.
+*/
+#if gcmIS_DEBUG(gcdDEBUG_CODE)
+#   define gcmDEBUG_ONLY(f)         f
+#else
+#   define gcmDEBUG_ONLY(f)
+#endif
+
+/*******************************************************************************
+**
+**  gcmSTACK_PUSH
+**  gcmSTACK_POP
+**  gcmSTACK_DUMP
+**
+**      Push or pop a function with entry arguments on the trace stack.
+**
+**  ARGUMENTS:
+**
+**      Function    Name of function.
+**      Line        Line number.
+**      Text        Optional text.
+**      ...         Optional arguments for text.
+*/
+#if gcmIS_DEBUG(gcdDEBUG_STACK)
+    void
+    gcoOS_StackPush(
+        IN gctCONST_STRING Function,
+        IN gctINT Line,
+        IN gctCONST_STRING Text,
+        ...
+        );
+    void
+    gcoOS_StackPop(
+        IN gctCONST_STRING Function
+        );
+    void
+    gcoOS_StackDump(
+        void
+        );
+#   define gcmSTACK_PUSH            gcoOS_StackPush
+#   define gcmSTACK_POP             gcoOS_StackPop
+#   define gcmSTACK_DUMP            gcoOS_StackDump
+#elif gcdHAS_ELLIPSES
+#   define gcmSTACK_PUSH(...)       do { } while (0)
+#   define gcmSTACK_POP(Function)   do { } while (0)
+#   define gcmSTACK_DUMP()          do { } while (0)
+#else
+    gcmINLINE static void
+    __dummy_stack_push(
+        IN gctCONST_STRING Function,
+        IN gctINT Line,
+        IN gctCONST_STRING Text, ...
+        )
+    {
+    }
+#   define gcmSTACK_PUSH            __dummy_stack_push
+#   define gcmSTACK_POP(Function)   do { } while (0)
+#   define gcmSTACK_DUMP()          do { } while (0)
+#endif
+
+/******************************************************************************\
+******************************** Logging Macros ********************************
+\******************************************************************************/
+
+#define gcdHEADER_LEVEL             gcvLEVEL_VERBOSE
+
+
+#if gcdENABLE_PROFILING
+void
+gcoOS_ProfileDB(
+    IN gctCONST_STRING Function,
+    IN OUT gctBOOL_PTR Initialized
+    );
+
+#define gcmHEADER() \
+    static gctBOOL __profile__initialized__ = gcvFALSE; \
+    gcmSTACK_PUSH(__FUNCTION__, __LINE__, gcvNULL, gcvNULL); \
+    gcoOS_ProfileDB(__FUNCTION__, &__profile__initialized__)
+#define gcmHEADER_ARG(...) \
+    static gctBOOL __profile__initialized__ = gcvFALSE; \
+    gcmSTACK_PUSH(__FUNCTION__, __LINE__, Text, __VA_ARGS__); \
+    gcoOS_ProfileDB(__FUNCTION__, &__profile__initialized__)
+#define gcmFOOTER() \
+    gcmSTACK_POP(__FUNCTION__); \
+    gcoOS_ProfileDB(__FUNCTION__, gcvNULL)
+#define gcmFOOTER_NO() \
+    gcmSTACK_POP(__FUNCTION__); \
+    gcoOS_ProfileDB(__FUNCTION__, gcvNULL)
+#define gcmFOOTER_ARG(...) \
+    gcmSTACK_POP(__FUNCTION__); \
+    gcoOS_ProfileDB(__FUNCTION__, gcvNULL)
+#define gcmFOOTER_KILL() \
+    gcmSTACK_POP(__FUNCTION__); \
+    gcoOS_ProfileDB(gcvNULL, gcvNULL)
+
+#else /* gcdENABLE_PROFILING */
+
+#if gcdHAS_ELLIPSES
+#define gcmHEADER() \
+    gctINT8 __user__ = 1; \
+    gctINT8_PTR __user_ptr__ = &__user__; \
+    gcmSTACK_PUSH(__FUNCTION__, __LINE__, gcvNULL, gcvNULL); \
+    gcmTRACE_ZONE(gcdHEADER_LEVEL, _GC_OBJ_ZONE, \
+                  "++%s(%d)", __FUNCTION__, __LINE__)
+#else
+    gcmINLINE static void
+    __dummy_header(void)
+    {
+    }
+#   define gcmHEADER                   __dummy_header
+#endif
+
+#if gcdHAS_ELLIPSES
+#   define gcmHEADER_ARG(Text, ...) \
+        gctINT8 __user__ = 1; \
+        gctINT8_PTR __user_ptr__ = &__user__; \
+        gcmSTACK_PUSH(__FUNCTION__, __LINE__, Text, __VA_ARGS__); \
+        gcmTRACE_ZONE(gcdHEADER_LEVEL, _GC_OBJ_ZONE, \
+                      "++%s(%d): " Text, __FUNCTION__, __LINE__, __VA_ARGS__)
+#else
+    gcmINLINE static void
+    __dummy_header_arg(
+        IN gctCONST_STRING Text,
+        ...
+        )
+    {
+    }
+#   define gcmHEADER_ARG                __dummy_header_arg
+#endif
+
+#if gcdHAS_ELLIPSES
+#   define gcmFOOTER() \
+    gcmSTACK_POP(__FUNCTION__); \
+    gcmPROFILE_ONLY(gcmTRACE_ZONE(gcdHEADER_LEVEL, _GC_OBJ_ZONE, \
+                                  "--%s(%d) [%llu,%llu]: status=%d(%s)", \
+                                  __FUNCTION__, __LINE__, \
+                                  __ticks__, __total__, \
+                                  status, gcoOS_DebugStatus2Name(status))); \
+    gcmPROFILE_ELSE(gcmTRACE_ZONE(gcdHEADER_LEVEL, _GC_OBJ_ZONE, \
+                                  "--%s(%d): status=%d(%s)", \
+                                  __FUNCTION__, __LINE__, \
+                                  status, gcoOS_DebugStatus2Name(status))); \
+    *__user_ptr__ -= 1
+#else
+    gcmINLINE static void
+    __dummy_footer(void)
+    {
+    }
+#   define gcmFOOTER                    __dummy_footer
+#endif
+
+#if gcdHAS_ELLIPSES
+#define gcmFOOTER_NO() \
+    gcmSTACK_POP(__FUNCTION__); \
+    gcmTRACE_ZONE(gcdHEADER_LEVEL, _GC_OBJ_ZONE, \
+                  "--%s(%d)", __FUNCTION__, __LINE__); \
+    *__user_ptr__ -= 1
+#else
+    gcmINLINE static void
+    __dummy_footer_no(void)
+    {
+    }
+#   define gcmFOOTER_NO                 __dummy_footer_no
+#endif
+
+#if gcdHAS_ELLIPSES
+#define gcmFOOTER_KILL() \
+    gcmSTACK_POP(__FUNCTION__); \
+    gcmTRACE_ZONE(gcdHEADER_LEVEL, _GC_OBJ_ZONE, \
+                  "--%s(%d)", __FUNCTION__, __LINE__); \
+    *__user_ptr__ -= 1
+#else
+    gcmINLINE static void
+    __dummy_footer_kill(void)
+    {
+    }
+#   define gcmFOOTER_KILL               __dummy_footer_kill
+#endif
+
+#if gcdHAS_ELLIPSES
+#   define gcmFOOTER_ARG(Text, ...) \
+        gcmSTACK_POP(__FUNCTION__); \
+        gcmTRACE_ZONE(gcdHEADER_LEVEL, _GC_OBJ_ZONE, \
+                      "--%s(%d): " Text, __FUNCTION__, __LINE__, __VA_ARGS__); \
+        *__user_ptr__ -= 1
+#else
+    gcmINLINE static void
+    __dummy_footer_arg(
+        IN gctCONST_STRING Text,
+        ...
+        )
+    {
+    }
+#   define gcmFOOTER_ARG                __dummy_footer_arg
+#endif
+
+#endif /* gcdENABLE_PROFILING */
+
+#if gcdHAS_ELLIPSES
+#define gcmkHEADER() \
+    gctINT8 __kernel__ = 1; \
+    gctINT8_PTR __kernel_ptr__ = &__kernel__; \
+    gcmkTRACE_ZONE(gcdHEADER_LEVEL, _GC_OBJ_ZONE, \
+                   "++%s(%d)", __FUNCTION__, __LINE__)
+#else
+    gcmINLINE static void
+    __dummy_kheader(void)
+    {
+    }
+#   define gcmkHEADER                  __dummy_kheader
+#endif
+
+#if gcdHAS_ELLIPSES
+#   define gcmkHEADER_ARG(Text, ...) \
+        gctINT8 __kernel__ = 1; \
+        gctINT8_PTR __kernel_ptr__ = &__kernel__; \
+        gcmkTRACE_ZONE(gcdHEADER_LEVEL, _GC_OBJ_ZONE, \
+                       "++%s(%d): " Text, __FUNCTION__, __LINE__, __VA_ARGS__)
+#else
+    gcmINLINE static void
+    __dummy_kheader_arg(
+        IN gctCONST_STRING Text,
+        ...
+        )
+    {
+    }
+#   define gcmkHEADER_ARG               __dummy_kheader_arg
+#endif
+
+#if gcdHAS_ELLIPSES
+#define gcmkFOOTER() \
+    gcmkTRACE_ZONE(gcdHEADER_LEVEL, _GC_OBJ_ZONE, \
+                   "--%s(%d): status=%d(%s)", \
+                   __FUNCTION__, __LINE__, status, gckOS_DebugStatus2Name(status)); \
+    *__kernel_ptr__ -= 1
+#else
+    gcmINLINE static void
+    __dummy_kfooter(void)
+    {
+    }
+#   define gcmkFOOTER                   __dummy_kfooter
+#endif
+
+#if gcdHAS_ELLIPSES
+#define gcmkFOOTER_NO() \
+    gcmkTRACE_ZONE(gcdHEADER_LEVEL, _GC_OBJ_ZONE, \
+                   "--%s(%d)", __FUNCTION__, __LINE__); \
+    *__kernel_ptr__ -= 1
+#else
+    gcmINLINE static void
+    __dummy_kfooter_no(void)
+    {
+    }
+#   define gcmkFOOTER_NO                __dummy_kfooter_no
+#endif
+
+#if gcdHAS_ELLIPSES
+#   define gcmkFOOTER_ARG(Text, ...) \
+        gcmkTRACE_ZONE(gcdHEADER_LEVEL, _GC_OBJ_ZONE, \
+                       "--%s(%d): " Text, \
+                       __FUNCTION__, __LINE__, __VA_ARGS__); \
+        *__kernel_ptr__ -= 1
+#else
+    gcmINLINE static void
+    __dummy_kfooter_arg(
+        IN gctCONST_STRING Text,
+        ...
+        )
+    {
+    }
+#   define gcmkFOOTER_ARG               __dummy_kfooter_arg
+#endif
+
+#define gcmOPT_VALUE(ptr)           (((ptr) == gcvNULL) ? 0 : *(ptr))
+#define gcmOPT_POINTER(ptr)         (((ptr) == gcvNULL) ? gcvNULL : *(ptr))
+#define gcmOPT_STRING(ptr)          (((ptr) == gcvNULL) ? "(nil)" : (ptr))
+
+void
+gckOS_Print(
+    IN gctCONST_STRING Message,
+    ...
+    );
+
+void
+gckOS_PrintN(
+    IN gctUINT ArgumentSize,
+    IN gctCONST_STRING Message,
+    ...
+    );
+
+void
+gckOS_CopyPrint(
+    IN gctCONST_STRING Message,
+    ...
+    );
+
+void
+gcoOS_Print(
+    IN gctCONST_STRING Message,
+    ...
+    );
+
+#define gcmPRINT                gcoOS_Print
+#define gcmkPRINT               gckOS_Print
+#define gcmkPRINT_N             gckOS_PrintN
+
+#if gcdPRINT_VERSION
+#   define gcmPRINT_VERSION()       do { \
+                                        _gcmPRINT_VERSION(gcm); \
+                                        gcmSTACK_DUMP(); \
+                                    } while (0)
+#   define gcmkPRINT_VERSION()      _gcmPRINT_VERSION(gcmk)
+#   define _gcmPRINT_VERSION(prefix) \
+        prefix##TRACE(gcvLEVEL_ERROR, \
+                      "Vivante HAL version %d.%d.%d build %d  %s  %s", \
+                      gcvVERSION_MAJOR, gcvVERSION_MINOR, gcvVERSION_PATCH, \
+                      gcvVERSION_BUILD, gcvVERSION_DATE, gcvVERSION_TIME )
+#else
+#   define gcmPRINT_VERSION()       do { gcmSTACK_DUMP(); } while (gcvFALSE)
+#   define gcmkPRINT_VERSION()      do { } while (gcvFALSE)
+#endif
+
+typedef enum _gceDUMP_BUFFER
+{
+    gceDUMP_BUFFER_CONTEXT,
+    gceDUMP_BUFFER_USER,
+    gceDUMP_BUFFER_KERNEL,
+    gceDUMP_BUFFER_LINK,
+    gceDUMP_BUFFER_WAITLINK,
+    gceDUMP_BUFFER_FROM_USER,
+}
+gceDUMP_BUFFER;
+
+void
+gckOS_DumpBuffer(
+    IN gckOS Os,
+    IN gctPOINTER Buffer,
+    IN gctUINT Size,
+    IN gceDUMP_BUFFER Type,
+    IN gctBOOL CopyMessage
+    );
+
+#define gcmkDUMPBUFFER          gckOS_DumpBuffer
+
+#if gcdDUMP_COMMAND
+#   define gcmkDUMPCOMMAND(Os, Buffer, Size, Type, CopyMessage) \
+        gcmkDUMPBUFFER(Os, Buffer, Size, Type, CopyMessage)
+#else
+#   define gcmkDUMPCOMMAND(Os, Buffer, Size, Type, CopyMessage)
+#endif
+
+#if gcmIS_DEBUG(gcdDEBUG_CODE)
+
+void
+gckOS_DebugFlush(
+    gctCONST_STRING CallerName,
+    gctUINT LineNumber,
+    gctUINT32 DmaAddress
+    );
+
+#   define gcmkDEBUGFLUSH(DmaAddress) \
+        gckOS_DebugFlush(__FUNCTION__, __LINE__, DmaAddress)
+#else
+#   define gcmkDEBUGFLUSH(DmaAddress)
+#endif
+
+/*******************************************************************************
+**
+**  gcmDUMP_FRAMERATE
+**
+**      Print average frame rate
+**
+*/
+#if gcdDUMP_FRAMERATE
+    gceSTATUS
+    gcfDumpFrameRate(
+        void
+    );
+#   define gcmDUMP_FRAMERATE        gcfDumpFrameRate
+#elif gcdHAS_ELLIPSES
+#   define gcmDUMP_FRAMERATE(...)
+#else
+    gcmINLINE static void
+    __dummy_dump_frame_rate(
+        void
+        )
+    {
+    }
+#   define gcmDUMP_FRAMERATE        __dummy_dump_frame_rate
+#endif
+
+
+/*******************************************************************************
+**
+**  gcmDUMP
+**
+**      Print a dump message.
+**
+**  ARGUMENTS:
+**
+**      gctSTRING   Message.
+**
+**      ...         Optional arguments.
+*/
+#if gcdDUMP
+    gceSTATUS
+    gcfDump(
+        IN gcoOS Os,
+        IN gctCONST_STRING String,
+        ...
+        );
+#  define gcmDUMP               gcfDump
+#elif gcdHAS_ELLIPSES
+#  define gcmDUMP(...)
+#else
+    gcmINLINE static void
+    __dummy_dump(
+        IN gcoOS Os,
+        IN gctCONST_STRING Message,
+        ...
+        )
+    {
+    }
+#  define gcmDUMP               __dummy_dump
+#endif
+
+/*******************************************************************************
+**
+**  gcmDUMP_DATA
+**
+**      Add data to the dump.
+**
+**  ARGUMENTS:
+**
+**      gctSTRING Tag
+**          Tag for dump.
+**
+**      gctPOINTER Logical
+**          Logical address of buffer.
+**
+**      gctSIZE_T Bytes
+**          Number of bytes.
+*/
+
+#if gcdDUMP || gcdDUMP_COMMAND
+    gceSTATUS
+    gcfDumpData(
+        IN gcoOS Os,
+        IN gctSTRING Tag,
+        IN gctPOINTER Logical,
+        IN gctSIZE_T Bytes
+        );
+#  define gcmDUMP_DATA          gcfDumpData
+#elif gcdHAS_ELLIPSES
+#  define gcmDUMP_DATA(...)
+#else
+    gcmINLINE static void
+    __dummy_dump_data(
+        IN gcoOS Os,
+        IN gctSTRING Tag,
+        IN gctPOINTER Logical,
+        IN gctSIZE_T Bytes
+        )
+    {
+    }
+#  define gcmDUMP_DATA          __dummy_dump_data
+#endif
+
+/*******************************************************************************
+**
+**  gcmDUMP_BUFFER
+**
+**      Print a buffer to the dump.
+**
+**  ARGUMENTS:
+**
+**      gctSTRING Tag
+**          Tag for dump.
+**
+**      gctUINT32 Physical
+**          Physical address of buffer.
+**
+**      gctPOINTER Logical
+**          Logical address of buffer.
+**
+**      gctUINT32 Offset
+**          Offset into buffer.
+**
+**      gctSIZE_T Bytes
+**          Number of bytes.
+*/
+
+#if gcdDUMP || gcdDUMP_COMMAND
+gceSTATUS
+gcfDumpBuffer(
+    IN gcoOS Os,
+    IN gctSTRING Tag,
+    IN gctUINT32 Physical,
+    IN gctPOINTER Logical,
+    IN gctUINT32 Offset,
+    IN gctSIZE_T Bytes
+    );
+#   define gcmDUMP_BUFFER       gcfDumpBuffer
+#elif gcdHAS_ELLIPSES
+#   define gcmDUMP_BUFFER(...)
+#else
+    gcmINLINE static void
+    __dummy_dump_buffer(
+        IN gcoOS Os,
+        IN gctSTRING Tag,
+        IN gctUINT32 Physical,
+        IN gctPOINTER Logical,
+        IN gctUINT32 Offset,
+        IN gctSIZE_T Bytes
+        )
+    {
+    }
+#   define gcmDUMP_BUFFER       __dummy_dump_buffer
+#endif
+
+/*******************************************************************************
+**
+**  gcmDUMP_API
+**
+**      Print a dump message for a high level API prefixed by the function name.
+**
+**  ARGUMENTS:
+**
+**      gctSTRING   Message.
+**
+**      ...         Optional arguments.
+*/
+#if gcdDUMP_API
+    gceSTATUS
+    gcfDumpApi(
+        IN gctCONST_STRING String,
+        ...
+        );
+#   define gcmDUMP_API           gcfDumpApi
+#elif gcdHAS_ELLIPSES
+#   define gcmDUMP_API(...)
+#else
+    gcmINLINE static void
+    __dummy_dump_api(
+        IN gctCONST_STRING Message,
+        ...
+        )
+    {
+    }
+#  define gcmDUMP_API           __dummy_dump_api
+#endif
+
+/*******************************************************************************
+**
+**  gcmDUMP_API_ARRAY
+**
+**      Print an array of data.
+**
+**  ARGUMENTS:
+**
+**      gctUINT32_PTR   Pointer to array.
+**      gctUINT32       Size.
+*/
+#if gcdDUMP_API
+    gceSTATUS
+    gcfDumpArray(
+        IN gctCONST_POINTER Data,
+        IN gctUINT32 Size
+    );
+#   define gcmDUMP_API_ARRAY        gcfDumpArray
+#elif gcdHAS_ELLIPSES
+#   define gcmDUMP_API_ARRAY(...)
+#else
+    gcmINLINE static void
+    __dummy_dump_api_array(
+        IN gctCONST_POINTER Data,
+        IN gctUINT32 Size
+        )
+    {
+    }
+#   define gcmDUMP_API_ARRAY        __dummy_dump_api_array
+#endif
+
+/*******************************************************************************
+**
+**  gcmDUMP_API_ARRAY_TOKEN
+**
+**      Print an array of data terminated by a token.
+**
+**  ARGUMENTS:
+**
+**      gctUINT32_PTR   Pointer to array.
+**      gctUINT32       Termination.
+*/
+#if gcdDUMP_API
+    gceSTATUS
+    gcfDumpArrayToken(
+        IN gctCONST_POINTER Data,
+        IN gctUINT32 Termination
+    );
+#   define gcmDUMP_API_ARRAY_TOKEN  gcfDumpArrayToken
+#elif gcdHAS_ELLIPSES
+#   define gcmDUMP_API_ARRAY_TOKEN(...)
+#else
+    gcmINLINE static void
+    __dummy_dump_api_array_token(
+        IN gctCONST_POINTER Data,
+        IN gctUINT32 Termination
+        )
+    {
+    }
+#   define gcmDUMP_API_ARRAY_TOKEN  __dummy_dump_api_array_token
+#endif
+
+/*******************************************************************************
+**
+**  gcmDUMP_API_DATA
+**
+**      Print an array of bytes.
+**
+**  ARGUMENTS:
+**
+**      gctCONST_POINTER    Pointer to array.
+**      gctSIZE_T           Size.
+*/
+#if gcdDUMP_API
+    gceSTATUS
+    gcfDumpApiData(
+        IN gctCONST_POINTER Data,
+        IN gctSIZE_T Size
+    );
+#   define gcmDUMP_API_DATA         gcfDumpApiData
+#elif gcdHAS_ELLIPSES
+#   define gcmDUMP_API_DATA(...)
+#else
+    gcmINLINE static void
+    __dummy_dump_api_data(
+        IN gctCONST_POINTER Data,
+        IN gctSIZE_T Size
+        )
+    {
+    }
+#   define gcmDUMP_API_DATA         __dummy_dump_api_data
+#endif
+
+/*******************************************************************************
+**
+**  gcmTRACE_RELEASE
+**
+**      Print a message to the shader debugger.
+**
+**  ARGUMENTS:
+**
+**      message Message.
+**      ...     Optional arguments.
+*/
+
+#define gcmTRACE_RELEASE                gcoOS_DebugShaderTrace
+
+void
+gcoOS_DebugShaderTrace(
+    IN gctCONST_STRING Message,
+    ...
+    );
+
+void
+gcoOS_SetDebugShaderFiles(
+    IN gctCONST_STRING VSFileName,
+    IN gctCONST_STRING FSFileName
+    );
+
+void
+gcoOS_SetDebugShaderFileType(
+    IN gctUINT32 ShaderType
+    );
+
+void
+gcoOS_EnableDebugBuffer(
+    IN gctBOOL Enable
+    );
+
+/*******************************************************************************
+**
+**  gcmBREAK
+**
+**      Break into the debugger.  In retail mode this macro does nothing.
+**
+**  ARGUMENTS:
+**
+**      None.
+*/
+
+void
+gcoOS_DebugBreak(
+    void
+    );
+
+void
+gckOS_DebugBreak(
+    void
+    );
+
+#if gcmIS_DEBUG(gcdDEBUG_BREAK)
+#   define gcmBREAK             gcoOS_DebugBreak
+#   define gcmkBREAK            gckOS_DebugBreak
+#else
+#   define gcmBREAK()
+#   define gcmkBREAK()
+#endif
+
+/*******************************************************************************
+**
+**  gcmASSERT
+**
+**      Evaluate an expression and break into the debugger if the expression
+**      evaluates to false.  In retail mode this macro does nothing.
+**
+**  ARGUMENTS:
+**
+**      exp     Expression to evaluate.
+*/
+#if gcmIS_DEBUG(gcdDEBUG_ASSERT)
+#   define _gcmASSERT(prefix, exp) \
+        do \
+        { \
+            if (!(exp)) \
+            { \
+                prefix##TRACE(gcvLEVEL_ERROR, \
+                              #prefix "ASSERT at %s(%d)", \
+                              __FUNCTION__, __LINE__); \
+                prefix##TRACE(gcvLEVEL_ERROR, \
+                              "(%s)", #exp); \
+                prefix##BREAK(); \
+            } \
+        } \
+        while (gcvFALSE)
+#   define gcmASSERT(exp)           _gcmASSERT(gcm, exp)
+#   define gcmkASSERT(exp)          _gcmASSERT(gcmk, exp)
+#else
+#   define gcmASSERT(exp)
+#   define gcmkASSERT(exp)
+#endif
+
+/*******************************************************************************
+**
+**  gcmVERIFY
+**
+**      Verify if an expression returns true.  If the expression does not
+**      evaluates to true, an assertion will happen in debug mode.
+**
+**  ARGUMENTS:
+**
+**      exp     Expression to evaluate.
+*/
+#if gcmIS_DEBUG(gcdDEBUG_ASSERT)
+#   define gcmVERIFY(exp)           gcmASSERT(exp)
+#   define gcmkVERIFY(exp)          gcmkASSERT(exp)
+#else
+#   define gcmVERIFY(exp)           exp
+#   define gcmkVERIFY(exp)          exp
+#endif
+
+/*******************************************************************************
+**
+**  gcmVERIFY_OK
+**
+**      Verify a fucntion returns gcvSTATUS_OK.  If the function does not return
+**      gcvSTATUS_OK, an assertion will happen in debug mode.
+**
+**  ARGUMENTS:
+**
+**      func    Function to evaluate.
+*/
+
+void
+gcoOS_Verify(
+    IN gceSTATUS Status
+    );
+
+void
+gckOS_Verify(
+    IN gceSTATUS Status
+    );
+
+#if gcmIS_DEBUG(gcdDEBUG_ASSERT)
+#   define gcmVERIFY_OK(func) \
+        do \
+        { \
+            gceSTATUS verifyStatus = func; \
+            gcoOS_Verify(verifyStatus); \
+            if (verifyStatus != gcvSTATUS_OK) \
+            { \
+                gcmTRACE( \
+                    gcvLEVEL_ERROR, \
+                    "gcmVERIFY_OK(%d): function returned %d", \
+                    __LINE__, verifyStatus \
+                    ); \
+            } \
+            gcmASSERT(verifyStatus == gcvSTATUS_OK); \
+        } \
+        while (gcvFALSE)
+#   define gcmkVERIFY_OK(func) \
+        do \
+        { \
+            gceSTATUS verifyStatus = func; \
+            if (verifyStatus != gcvSTATUS_OK) \
+            { \
+                gcmkTRACE( \
+                    gcvLEVEL_ERROR, \
+                    "gcmkVERIFY_OK(%d): function returned %d", \
+                    __LINE__, verifyStatus \
+                    ); \
+            } \
+            gckOS_Verify(verifyStatus); \
+            gcmkASSERT(verifyStatus == gcvSTATUS_OK); \
+        } \
+        while (gcvFALSE)
+#else
+#   define gcmVERIFY_OK(func)       func
+#   define gcmkVERIFY_OK(func)      func
+#endif
+
+gctCONST_STRING
+gcoOS_DebugStatus2Name(
+    gceSTATUS status
+    );
+
+gctCONST_STRING
+gckOS_DebugStatus2Name(
+    gceSTATUS status
+    );
+
+/*******************************************************************************
+**
+**  gcmERR_BREAK
+**
+**      Executes a break statement on error.
+**
+**  ASSUMPTIONS:
+**
+**      'status' variable of gceSTATUS type must be defined.
+**
+**  ARGUMENTS:
+**
+**      func    Function to evaluate.
+*/
+#define _gcmERR_BREAK(prefix, func) \
+    status = func; \
+    if (gcmIS_ERROR(status)) \
+    { \
+        prefix##PRINT_VERSION(); \
+        prefix##TRACE(gcvLEVEL_ERROR, \
+            #prefix "ERR_BREAK: status=%d(%s) @ %s(%d)", \
+            status, gcoOS_DebugStatus2Name(status), __FUNCTION__, __LINE__); \
+        break; \
+    } \
+    do { } while (gcvFALSE)
+#define _gcmkERR_BREAK(prefix, func) \
+    status = func; \
+    if (gcmIS_ERROR(status)) \
+    { \
+        prefix##PRINT_VERSION(); \
+        prefix##TRACE(gcvLEVEL_ERROR, \
+            #prefix "ERR_BREAK: status=%d(%s) @ %s(%d)", \
+            status, gckOS_DebugStatus2Name(status), __FUNCTION__, __LINE__); \
+        break; \
+    } \
+    do { } while (gcvFALSE)
+#define gcmERR_BREAK(func)          _gcmERR_BREAK(gcm, func)
+#define gcmkERR_BREAK(func)         _gcmkERR_BREAK(gcmk, func)
+
+/*******************************************************************************
+**
+**  gcmERR_RETURN
+**
+**      Executes a return on error.
+**
+**  ASSUMPTIONS:
+**
+**      'status' variable of gceSTATUS type must be defined.
+**
+**  ARGUMENTS:
+**
+**      func    Function to evaluate.
+*/
+#define _gcmERR_RETURN(prefix, func) \
+    status = func; \
+    if (gcmIS_ERROR(status)) \
+    { \
+        prefix##PRINT_VERSION(); \
+        prefix##TRACE(gcvLEVEL_ERROR, \
+            #prefix "ERR_RETURN: status=%d(%s) @ %s(%d)", \
+            status, gcoOS_DebugStatus2Name(status), __FUNCTION__, __LINE__); \
+        prefix##FOOTER(); \
+        return status; \
+    } \
+    do { } while (gcvFALSE)
+#define _gcmkERR_RETURN(prefix, func) \
+    status = func; \
+    if (gcmIS_ERROR(status)) \
+    { \
+        prefix##PRINT_VERSION(); \
+        prefix##TRACE(gcvLEVEL_ERROR, \
+            #prefix "ERR_RETURN: status=%d(%s) @ %s(%d)", \
+            status, gckOS_DebugStatus2Name(status), __FUNCTION__, __LINE__); \
+        prefix##FOOTER(); \
+        return status; \
+    } \
+    do { } while (gcvFALSE)
+#define gcmERR_RETURN(func)         _gcmERR_RETURN(gcm, func)
+#define gcmkERR_RETURN(func)        _gcmkERR_RETURN(gcmk, func)
+
+
+/*******************************************************************************
+**
+**  gcmONERROR
+**
+**      Jump to the error handler in case there is an error.
+**
+**  ASSUMPTIONS:
+**
+**      'status' variable of gceSTATUS type must be defined.
+**
+**  ARGUMENTS:
+**
+**      func    Function to evaluate.
+*/
+#define _gcmONERROR(prefix, func) \
+    do \
+    { \
+        status = func; \
+        if (gcmIS_ERROR(status)) \
+        { \
+            prefix##PRINT_VERSION(); \
+            prefix##TRACE(gcvLEVEL_ERROR, \
+                #prefix "ONERROR: status=%d(%s) @ %s(%d)", \
+                status, gcoOS_DebugStatus2Name(status), __FUNCTION__, __LINE__); \
+            goto OnError; \
+        } \
+    } \
+    while (gcvFALSE)
+#define _gcmkONERROR(prefix, func) \
+    do \
+    { \
+        status = func; \
+        if (gcmIS_ERROR(status)) \
+        { \
+            prefix##PRINT_VERSION(); \
+            prefix##TRACE(gcvLEVEL_ERROR, \
+                #prefix "ONERROR: status=%d(%s) @ %s(%d)", \
+                status, gckOS_DebugStatus2Name(status), __FUNCTION__, __LINE__); \
+            goto OnError; \
+        } \
+    } \
+    while (gcvFALSE)
+#define gcmONERROR(func)            _gcmONERROR(gcm, func)
+#define gcmkONERROR(func)           _gcmkONERROR(gcmk, func)
+
+/*******************************************************************************
+**
+**  gcmVERIFY_LOCK
+**
+**      Verifies whether the surface is locked.
+**
+**  ARGUMENTS:
+**
+**      surfaceInfo Pointer to the surface iniformational structure.
+*/
+#define gcmVERIFY_LOCK(surfaceInfo) \
+    if (!surfaceInfo->node.valid) \
+    { \
+        gcmONERROR(gcvSTATUS_MEMORY_UNLOCKED); \
+    } \
+
+/*******************************************************************************
+**
+**  gcmVERIFY_NODE_LOCK
+**
+**      Verifies whether the surface node is locked.
+**
+**  ARGUMENTS:
+**
+**      surfaceInfo Pointer to the surface iniformational structure.
+*/
+#define gcmVERIFY_NODE_LOCK(surfaceNode) \
+    if (!surfaceNode->valid) \
+    { \
+        status = gcvSTATUS_MEMORY_UNLOCKED; \
+        break; \
+    } \
+    do { } while (gcvFALSE)
+
+/*******************************************************************************
+**
+**  gcmBADOBJECT_BREAK
+**
+**      Executes a break statement on bad object.
+**
+**  ARGUMENTS:
+**
+**      obj     Object to test.
+**      t       Expected type of the object.
+*/
+#define gcmBADOBJECT_BREAK(obj, t) \
+    if ((obj == gcvNULL) \
+    ||  (((gcsOBJECT *)(obj))->type != t) \
+    ) \
+    { \
+        status = gcvSTATUS_INVALID_OBJECT; \
+        break; \
+    } \
+    do { } while (gcvFALSE)
+
+/*******************************************************************************
+**
+**  gcmCHECK_STATUS
+**
+**      Executes a break statement on error.
+**
+**  ASSUMPTIONS:
+**
+**      'status' variable of gceSTATUS type must be defined.
+**
+**  ARGUMENTS:
+**
+**      func    Function to evaluate.
+*/
+#define _gcmCHECK_STATUS(prefix, func) \
+    do \
+    { \
+        last = func; \
+        if (gcmIS_ERROR(last)) \
+        { \
+            prefix##TRACE(gcvLEVEL_ERROR, \
+                #prefix "CHECK_STATUS: status=%d(%s) @ %s(%d)", \
+                last, gcoOS_DebugStatus2Name(last), __FUNCTION__, __LINE__); \
+            status = last; \
+        } \
+    } \
+    while (gcvFALSE)
+#define _gcmkCHECK_STATUS(prefix, func) \
+    do \
+    { \
+        last = func; \
+        if (gcmIS_ERROR(last)) \
+        { \
+            prefix##TRACE(gcvLEVEL_ERROR, \
+                #prefix "CHECK_STATUS: status=%d(%s) @ %s(%d)", \
+                last, gckOS_DebugStatus2Name(last), __FUNCTION__, __LINE__); \
+            status = last; \
+        } \
+    } \
+    while (gcvFALSE)
+#define gcmCHECK_STATUS(func)       _gcmCHECK_STATUS(gcm, func)
+#define gcmkCHECK_STATUS(func)      _gcmkCHECK_STATUS(gcmk, func)
+
+/*******************************************************************************
+**
+**  gcmVERIFY_ARGUMENT
+**
+**      Assert if an argument does not apply to the specified expression.  If
+**      the argument evaluates to false, gcvSTATUS_INVALID_ARGUMENT will be
+**      returned from the current function.  In retail mode this macro does
+**      nothing.
+**
+**  ARGUMENTS:
+**
+**      arg     Argument to evaluate.
+*/
+#   define _gcmVERIFY_ARGUMENT(prefix, arg) \
+       do \
+       { \
+           if (!(arg)) \
+           { \
+               prefix##TRACE(gcvLEVEL_ERROR, #prefix "VERIFY_ARGUMENT failed:"); \
+               prefix##ASSERT(arg); \
+               prefix##FOOTER_ARG("status=%d", gcvSTATUS_INVALID_ARGUMENT); \
+               return gcvSTATUS_INVALID_ARGUMENT; \
+           } \
+       } \
+       while (gcvFALSE)
+#   define gcmVERIFY_ARGUMENT(arg)     _gcmVERIFY_ARGUMENT(gcm, arg)
+#   define gcmkVERIFY_ARGUMENT(arg)    _gcmVERIFY_ARGUMENT(gcmk, arg)
+
+/*******************************************************************************
+**
+**  gcmDEBUG_VERIFY_ARGUMENT
+**
+**      Works just like gcmVERIFY_ARGUMENT, but is only valid in debug mode.
+**      Use this to verify arguments inside non-public API functions.
+*/
+#if gcdDEBUG
+#   define gcmDEBUG_VERIFY_ARGUMENT(arg)    _gcmVERIFY_ARGUMENT(gcm, arg)
+#   define gcmkDEBUG_VERIFY_ARGUMENT(arg)   _gcmkVERIFY_ARGUMENT(gcm, arg)
+#else
+#   define gcmDEBUG_VERIFY_ARGUMENT(arg)
+#   define gcmkDEBUG_VERIFY_ARGUMENT(arg)
+#endif
+/*******************************************************************************
+**
+**  gcmVERIFY_ARGUMENT_RETURN
+**
+**      Assert if an argument does not apply to the specified expression.  If
+**      the argument evaluates to false, gcvSTATUS_INVALID_ARGUMENT will be
+**      returned from the current function.  In retail mode this macro does
+**      nothing.
+**
+**  ARGUMENTS:
+**
+**      arg     Argument to evaluate.
+*/
+#   define _gcmVERIFY_ARGUMENT_RETURN(prefix, arg, value) \
+       do \
+       { \
+           if (!(arg)) \
+           { \
+               prefix##TRACE(gcvLEVEL_ERROR, \
+                             #prefix "gcmVERIFY_ARGUMENT_RETURN failed:"); \
+               prefix##ASSERT(arg); \
+               prefix##FOOTER_ARG("value=%d", value); \
+               return value; \
+           } \
+       } \
+       while (gcvFALSE)
+#   define gcmVERIFY_ARGUMENT_RETURN(arg, value) \
+                _gcmVERIFY_ARGUMENT_RETURN(gcm, arg, value)
+#   define gcmkVERIFY_ARGUMENT_RETURN(arg, value) \
+                _gcmVERIFY_ARGUMENT_RETURN(gcmk, arg, value)
+
+#define MAX_LOOP_COUNT 0x7FFFFFFF
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __gc_hal_base_h_ */
diff --git a/attic/gc_hal_compiler.h b/attic/gc_hal_compiler.h
new file mode 100644
index 0000000..ecdb763
--- /dev/null
+++ b/attic/gc_hal_compiler.h
@@ -0,0 +1,3400 @@
+/****************************************************************************
+*
+*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*
+*    This program is free software; you can redistribute it and/or modify
+*    it under the terms of the GNU General Public License as published by
+*    the Free Software Foundation; either version 2 of the license, or
+*    (at your option) any later version.
+*
+*    This program is distributed in the hope that it will be useful,
+*    but WITHOUT ANY WARRANTY; without even the implied warranty of
+*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+*    GNU General Public License for more details.
+*
+*    You should have received a copy of the GNU General Public License
+*    along with this program; if not write to the Free Software
+*    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*
+*****************************************************************************/
+
+
+
+
+/*
+**	Include file the defines the front- and back-end compilers, as well as the
+**	objects they use.
+*/
+
+#ifndef __gc_hal_compiler_h_
+#define __gc_hal_compiler_h_
+
+#ifndef VIVANTE_NO_3D
+#include "gc_hal_types.h"
+#include "gc_hal_engine.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifndef GC_ENABLE_LOADTIME_OPT
+#define GC_ENABLE_LOADTIME_OPT      1
+#endif
+
+/******************************* IR VERSION ******************/
+#define gcdSL_IR_VERSION gcmCC('\0','\0','\0','\1')
+
+/******************************************************************************\
+|******************************* SHADER LANGUAGE ******************************|
+\******************************************************************************/
+
+/* Possible shader language opcodes. */
+typedef enum _gcSL_OPCODE
+{
+	gcSL_NOP,							/* 0x00 */
+	gcSL_MOV,							/* 0x01 */
+	gcSL_SAT,							/* 0x02 */
+	gcSL_DP3,							/* 0x03 */
+	gcSL_DP4,							/* 0x04 */
+	gcSL_ABS,							/* 0x05 */
+	gcSL_JMP,							/* 0x06 */
+	gcSL_ADD,							/* 0x07 */
+	gcSL_MUL,							/* 0x08 */
+	gcSL_RCP,							/* 0x09 */
+	gcSL_SUB,							/* 0x0A */
+	gcSL_KILL,							/* 0x0B */
+	gcSL_TEXLD,							/* 0x0C */
+	gcSL_CALL,							/* 0x0D */
+	gcSL_RET,							/* 0x0E */
+	gcSL_NORM,							/* 0x0F */
+	gcSL_MAX,							/* 0x10 */
+	gcSL_MIN,							/* 0x11 */
+	gcSL_POW,							/* 0x12 */
+	gcSL_RSQ,							/* 0x13 */
+	gcSL_LOG,							/* 0x14 */
+	gcSL_FRAC,							/* 0x15 */
+	gcSL_FLOOR,							/* 0x16 */
+	gcSL_CEIL,							/* 0x17 */
+	gcSL_CROSS,							/* 0x18 */
+	gcSL_TEXLDP,						/* 0x19 */
+	gcSL_TEXBIAS,						/* 0x1A */
+	gcSL_TEXGRAD,						/* 0x1B */
+	gcSL_TEXLOD,						/* 0x1C */
+	gcSL_SIN,							/* 0x1D */
+	gcSL_COS,							/* 0x1E */
+	gcSL_TAN,							/* 0x1F */
+	gcSL_EXP,							/* 0x20 */
+	gcSL_SIGN,							/* 0x21 */
+	gcSL_STEP,							/* 0x22 */
+	gcSL_SQRT,							/* 0x23 */
+	gcSL_ACOS,							/* 0x24 */
+	gcSL_ASIN,							/* 0x25 */
+	gcSL_ATAN,							/* 0x26 */
+	gcSL_SET,							/* 0x27 */
+	gcSL_DSX,							/* 0x28 */
+	gcSL_DSY,							/* 0x29 */
+	gcSL_FWIDTH,						/* 0x2A */
+	gcSL_DIV,   						/* 0x2B */
+	gcSL_MOD,   						/* 0x2C */
+	gcSL_AND_BITWISE,					/* 0x2D */
+	gcSL_OR_BITWISE,					/* 0x2E */
+	gcSL_XOR_BITWISE,					/* 0x2F */
+	gcSL_NOT_BITWISE,					/* 0x30 */
+	gcSL_LSHIFT,						/* 0x31 */
+	gcSL_RSHIFT,						/* 0x32 */
+	gcSL_ROTATE,						/* 0x33 */
+	gcSL_BITSEL,						/* 0x34 */
+	gcSL_LEADZERO,						/* 0x35 */
+	gcSL_LOAD,							/* 0x36 */
+	gcSL_STORE,							/* 0x37 */
+	gcSL_BARRIER,						/* 0x38 */
+	gcSL_STORE1,						/* 0x39 */
+	gcSL_ATOMADD,						/* 0x3A */
+	gcSL_ATOMSUB,						/* 0x3B */
+	gcSL_ATOMXCHG,						/* 0x3C */
+	gcSL_ATOMCMPXCHG,					/* 0x3D */
+	gcSL_ATOMMIN,						/* 0x3E */
+	gcSL_ATOMMAX,						/* 0x3F */
+	gcSL_ATOMOR,						/* 0x40 */
+	gcSL_ATOMAND,						/* 0x41 */
+	gcSL_ATOMXOR,						/* 0x42 */
+	/*gcSL_UNUSED,						 0x43 */
+	/*gcSL_UNUSED,						 0x44 */
+	/*gcSL_UNUSED,						 0x45 */
+	/*gcSL_UNUSED,						 0x46 */
+	/*gcSL_UNUSED,						 0x47 */
+	/*gcSL_UNUSED,						 0x48 */
+	/*gcSL_UNUSED,						 0x49 */
+	/*gcSL_UNUSED,						 0x4A */
+	/*gcSL_UNUSED,						 0x4B */
+	/*gcSL_UNUSED,					 	 0x4C */
+	/*gcSL_UNUSED,						 0x4D */
+	/*gcSL_UNUSED,						 0x4E */
+	/*gcSL_UNUSED,						 0x4F */
+	/*gcSL_UNUSED,						 0x50 */
+	/*gcSL_UNUSED,						 0x51 */
+	/*gcSL_UNUSED,						 0x52 */
+	gcSL_ADDLO = 0x53,					/* 0x53 */  /* Float only. */
+	gcSL_MULLO,							/* 0x54 */  /* Float only. */
+	gcSL_CONV,							/* 0x55 */
+	gcSL_GETEXP,						/* 0x56 */
+	gcSL_GETMANT,						/* 0x57 */
+	gcSL_MULHI,							/* 0x58 */  /* Integer only. */
+	gcSL_CMP,							/* 0x59 */
+	gcSL_I2F,							/* 0x5A */
+	gcSL_F2I,							/* 0x5B */
+	gcSL_ADDSAT,						/* 0x5C */  /* Integer only. */
+	gcSL_SUBSAT,						/* 0x5D */  /* Integer only. */
+	gcSL_MULSAT,						/* 0x5E */  /* Integer only. */
+}
+gcSL_OPCODE;
+
+typedef enum _gcSL_FORMAT
+{
+	gcSL_FLOAT = 0,						/* 0 */
+	gcSL_INTEGER = 1,				    /* 1 */
+	gcSL_INT32 = 1,					    /* 1 */
+	gcSL_BOOLEAN = 2,					/* 2 */
+	gcSL_UINT32 = 3,					/* 3 */
+	gcSL_INT8,						    /* 4 */
+	gcSL_UINT8,						    /* 5 */
+	gcSL_INT16,						    /* 6 */
+	gcSL_UINT16,						/* 7 */
+	gcSL_INT64,						    /* 8 */     /* Reserved for future enhancement. */
+	gcSL_UINT64,						/* 9 */     /* Reserved for future enhancement. */
+	gcSL_INT128,					    /* 10 */    /* Reserved for future enhancement. */
+	gcSL_UINT128,						/* 11 */    /* Reserved for future enhancement. */
+	gcSL_FLOAT16,					    /* 12 */
+	gcSL_FLOAT64,						/* 13 */    /* Reserved for future enhancement. */
+	gcSL_FLOAT128,						/* 14 */    /* Reserved for future enhancement. */
+}
+gcSL_FORMAT;
+
+/* Destination write enable bits. */
+typedef enum _gcSL_ENABLE
+{
+    gcSL_ENABLE_NONE                    = 0x0,     /* none is enabled, error/uninitialized state */
+	gcSL_ENABLE_X						= 0x1,
+	gcSL_ENABLE_Y						= 0x2,
+	gcSL_ENABLE_Z						= 0x4,
+	gcSL_ENABLE_W						= 0x8,
+	/* Combinations. */
+	gcSL_ENABLE_XY						= gcSL_ENABLE_X | gcSL_ENABLE_Y,
+	gcSL_ENABLE_XYZ						= gcSL_ENABLE_X | gcSL_ENABLE_Y | gcSL_ENABLE_Z,
+	gcSL_ENABLE_XYZW					= gcSL_ENABLE_X | gcSL_ENABLE_Y | gcSL_ENABLE_Z | gcSL_ENABLE_W,
+	gcSL_ENABLE_XYW						= gcSL_ENABLE_X | gcSL_ENABLE_Y | gcSL_ENABLE_W,
+	gcSL_ENABLE_XZ						= gcSL_ENABLE_X | gcSL_ENABLE_Z,
+	gcSL_ENABLE_XZW						= gcSL_ENABLE_X | gcSL_ENABLE_Z | gcSL_ENABLE_W,
+	gcSL_ENABLE_XW						= gcSL_ENABLE_X | gcSL_ENABLE_W,
+	gcSL_ENABLE_YZ						= gcSL_ENABLE_Y | gcSL_ENABLE_Z,
+	gcSL_ENABLE_YZW						= gcSL_ENABLE_Y | gcSL_ENABLE_Z | gcSL_ENABLE_W,
+	gcSL_ENABLE_YW						= gcSL_ENABLE_Y | gcSL_ENABLE_W,
+	gcSL_ENABLE_ZW						= gcSL_ENABLE_Z | gcSL_ENABLE_W,
+}
+gcSL_ENABLE;
+
+/* Possible indices. */
+typedef enum _gcSL_INDEXED
+{
+	gcSL_NOT_INDEXED,					/* 0 */
+	gcSL_INDEXED_X,						/* 1 */
+	gcSL_INDEXED_Y,						/* 2 */
+	gcSL_INDEXED_Z,						/* 3 */
+	gcSL_INDEXED_W,						/* 4 */
+}
+gcSL_INDEXED;
+
+/* Opcode conditions. */
+typedef enum _gcSL_CONDITION
+{
+	gcSL_ALWAYS,						/* 0x0 */
+	gcSL_NOT_EQUAL,						/* 0x1 */
+	gcSL_LESS_OR_EQUAL,					/* 0x2 */
+	gcSL_LESS,							/* 0x3 */
+	gcSL_EQUAL,							/* 0x4 */
+	gcSL_GREATER,						/* 0x5 */
+	gcSL_GREATER_OR_EQUAL,				/* 0x6 */
+	gcSL_AND,							/* 0x7 */
+	gcSL_OR,							/* 0x8 */
+	gcSL_XOR,							/* 0x9 */
+    gcSL_NOT_ZERO,                      /* 0xA */
+}
+gcSL_CONDITION;
+
+/* Possible source operand types. */
+typedef enum _gcSL_TYPE
+{
+	gcSL_NONE,							/* 0x0 */
+	gcSL_TEMP,							/* 0x1 */
+	gcSL_ATTRIBUTE,						/* 0x2 */
+	gcSL_UNIFORM,						/* 0x3 */
+	gcSL_SAMPLER,						/* 0x4 */
+	gcSL_CONSTANT,						/* 0x5 */
+	gcSL_OUTPUT,						/* 0x6 */
+	gcSL_PHYSICAL,						/* 0x7 */
+}
+gcSL_TYPE;
+
+/* Swizzle generator macro. */
+#define gcmSWIZZLE(Component1, Component2, Component3, Component4) \
+( \
+	(gcSL_SWIZZLE_ ## Component1 << 0) | \
+	(gcSL_SWIZZLE_ ## Component2 << 2) | \
+	(gcSL_SWIZZLE_ ## Component3 << 4) | \
+	(gcSL_SWIZZLE_ ## Component4 << 6)   \
+)
+
+#define gcmExtractSwizzle(Swizzle, Index) \
+    ((gcSL_SWIZZLE) ((((Swizzle) >> (Index * 2)) & 0x3)))
+
+#define gcmComposeSwizzle(SwizzleX, SwizzleY, SwizzleZ, SwizzleW) \
+( \
+	((SwizzleX) << 0) | \
+	((SwizzleY) << 2) | \
+	((SwizzleZ) << 4) | \
+	((SwizzleW) << 6)   \
+)
+
+/* Possible swizzle values. */
+typedef enum _gcSL_SWIZZLE
+{
+	gcSL_SWIZZLE_X,						/* 0x0 */
+	gcSL_SWIZZLE_Y,						/* 0x1 */
+	gcSL_SWIZZLE_Z,						/* 0x2 */
+	gcSL_SWIZZLE_W,						/* 0x3 */
+	/* Combinations. */
+	gcSL_SWIZZLE_XXXX = gcmSWIZZLE(X, X, X, X),
+	gcSL_SWIZZLE_YYYY = gcmSWIZZLE(Y, Y, Y, Y),
+	gcSL_SWIZZLE_ZZZZ = gcmSWIZZLE(Z, Z, Z, Z),
+	gcSL_SWIZZLE_WWWW = gcmSWIZZLE(W, W, W, W),
+	gcSL_SWIZZLE_XYYY = gcmSWIZZLE(X, Y, Y, Y),
+	gcSL_SWIZZLE_XZZZ = gcmSWIZZLE(X, Z, Z, Z),
+	gcSL_SWIZZLE_XWWW = gcmSWIZZLE(X, W, W, W),
+	gcSL_SWIZZLE_YZZZ = gcmSWIZZLE(Y, Z, Z, Z),
+	gcSL_SWIZZLE_YWWW = gcmSWIZZLE(Y, W, W, W),
+	gcSL_SWIZZLE_ZWWW = gcmSWIZZLE(Z, W, W, W),
+	gcSL_SWIZZLE_XYZZ = gcmSWIZZLE(X, Y, Z, Z),
+	gcSL_SWIZZLE_XYWW = gcmSWIZZLE(X, Y, W, W),
+	gcSL_SWIZZLE_XZWW = gcmSWIZZLE(X, Z, W, W),
+	gcSL_SWIZZLE_YZWW = gcmSWIZZLE(Y, Z, W, W),
+	gcSL_SWIZZLE_XXYZ = gcmSWIZZLE(X, X, Y, Z),
+	gcSL_SWIZZLE_XYZW = gcmSWIZZLE(X, Y, Z, W),
+	gcSL_SWIZZLE_XYXY = gcmSWIZZLE(X, Y, X, Y),
+	gcSL_SWIZZLE_YYZZ = gcmSWIZZLE(Y, Y, Z, Z),
+	gcSL_SWIZZLE_YYWW = gcmSWIZZLE(Y, Y, W, W),
+	gcSL_SWIZZLE_ZZZW = gcmSWIZZLE(Z, Z, Z, W),
+	gcSL_SWIZZLE_XZZW = gcmSWIZZLE(X, Z, Z, W),
+	gcSL_SWIZZLE_YYZW = gcmSWIZZLE(Y, Y, Z, W),
+
+    gcSL_SWIZZLE_INVALID = 0x7FFFFFFF
+}
+gcSL_SWIZZLE;
+
+typedef enum _gcSL_COMPONENT
+{
+	gcSL_COMPONENT_X,               /* 0x0 */
+	gcSL_COMPONENT_Y,               /* 0x1 */
+	gcSL_COMPONENT_Z,               /* 0x2 */
+	gcSL_COMPONENT_W,               /* 0x3 */
+    gcSL_COMPONENT_COUNT            /* 0x4 */
+} gcSL_COMPONENT;
+
+#define gcmIsComponentEnabled(Enable, Component) (((Enable) & (1 << (Component))) != 0)
+
+/******************************************************************************\
+|*********************************** SHADERS **********************************|
+\******************************************************************************/
+
+/* Shader types. */
+typedef enum _gcSHADER_KIND {
+    gcSHADER_TYPE_UNKNOWN = 0,
+    gcSHADER_TYPE_VERTEX,
+    gcSHADER_TYPE_FRAGMENT,
+    gcSHADER_TYPE_CL,
+    gcSHADER_TYPE_PRECOMPILED,
+    gcSHADER_KIND_COUNT
+} gcSHADER_KIND;
+
+typedef enum _gcGL_DRIVER_VERSION {
+    gcGL_DRIVER_ES11,    /* OpenGL ES 1.1 */
+    gcGL_DRIVER_ES20,    /* OpenGL ES 2.0 */
+    gcGL_DRIVER_ES30     /* OpenGL ES 3.0 */
+} gcGL_DRIVER_VERSION;
+
+#define gcm
+/* gcSHADER objects. */
+typedef struct _gcSHADER *			gcSHADER;
+typedef struct _gcATTRIBUTE *			gcATTRIBUTE;
+typedef struct _gcUNIFORM *			gcUNIFORM;
+typedef struct _gcOUTPUT *			gcOUTPUT;
+typedef struct _gcsFUNCTION *			gcFUNCTION;
+typedef struct _gcsKERNEL_FUNCTION *		gcKERNEL_FUNCTION;
+typedef struct _gcsHINT *			gcsHINT_PTR;
+typedef struct _gcSHADER_PROFILER *     	gcSHADER_PROFILER;
+typedef struct _gcVARIABLE *			gcVARIABLE;
+
+struct _gcsHINT
+{
+    /* Numbr of data transfers for Vertex Shader output. */
+    gctUINT32   vsOutputCount;
+
+    /* Flag whether the VS has point size or not. */
+    gctBOOL     vsHasPointSize;
+
+    /* Element count. */
+    gctUINT32   elementCount;
+
+    /* Component count. */
+    gctUINT32   componentCount;
+
+    /* Number of data transfers for Fragment Shader input. */
+    gctUINT32   fsInputCount;
+
+    /* Maximum number of temporary registers used in FS. */
+    gctUINT32   fsMaxTemp;
+
+	/* Maximum number of temporary registers used in VS. */
+	gctUINT32   vsMaxTemp;
+
+    /* Balance minimum. */
+    gctUINT32   balanceMin;
+
+    /* Balance maximum. */
+    gctUINT32   balanceMax;
+
+    /* Flag whether the PS outputs the depth value or not. */
+    gctBOOL     psHasFragDepthOut;
+
+	/* Flag whether the ThreadWalker is in PS. */
+	gctBOOL		threadWalkerInPS;
+
+};
+
+/* gcSHADER_TYPE enumeration. */
+typedef enum _gcSHADER_TYPE
+{
+	gcSHADER_FLOAT_X1,				/* 0x00 */
+	gcSHADER_FLOAT_X2,				/* 0x01 */
+	gcSHADER_FLOAT_X3,				/* 0x02 */
+	gcSHADER_FLOAT_X4,				/* 0x03 */
+	gcSHADER_FLOAT_2X2,				/* 0x04 */
+	gcSHADER_FLOAT_3X3,				/* 0x05 */
+	gcSHADER_FLOAT_4X4,				/* 0x06 */
+	gcSHADER_BOOLEAN_X1,			/* 0x07 */
+	gcSHADER_BOOLEAN_X2,			/* 0x08 */
+	gcSHADER_BOOLEAN_X3,			/* 0x09 */
+	gcSHADER_BOOLEAN_X4,			/* 0x0A */
+	gcSHADER_INTEGER_X1,			/* 0x0B */
+	gcSHADER_INTEGER_X2,			/* 0x0C */
+	gcSHADER_INTEGER_X3,			/* 0x0D */
+	gcSHADER_INTEGER_X4,			/* 0x0E */
+	gcSHADER_SAMPLER_1D,			/* 0x0F */
+	gcSHADER_SAMPLER_2D,			/* 0x10 */
+	gcSHADER_SAMPLER_3D,			/* 0x11 */
+	gcSHADER_SAMPLER_CUBIC,			/* 0x12 */
+	gcSHADER_FIXED_X1,				/* 0x13 */
+	gcSHADER_FIXED_X2,				/* 0x14 */
+	gcSHADER_FIXED_X3,				/* 0x15 */
+	gcSHADER_FIXED_X4,				/* 0x16 */
+	gcSHADER_IMAGE_2D,				/* 0x17 */  /* For OCL. */
+	gcSHADER_IMAGE_3D,				/* 0x18 */  /* For OCL. */
+	gcSHADER_SAMPLER,				/* 0x19 */  /* For OCL. */
+	gcSHADER_FLOAT_2X3,				/* 0x1A */
+	gcSHADER_FLOAT_2X4,				/* 0x1B */
+	gcSHADER_FLOAT_3X2,				/* 0x1C */
+	gcSHADER_FLOAT_3X4,				/* 0x1D */
+	gcSHADER_FLOAT_4X2,				/* 0x1E */
+	gcSHADER_FLOAT_4X3,				/* 0x1F */
+	gcSHADER_ISAMPLER_2D,			/* 0x20 */
+	gcSHADER_ISAMPLER_3D,			/* 0x21 */
+	gcSHADER_ISAMPLER_CUBIC,		/* 0x22 */
+	gcSHADER_USAMPLER_2D,			/* 0x23 */
+	gcSHADER_USAMPLER_3D,			/* 0x24 */
+	gcSHADER_USAMPLER_CUBIC,		/* 0x25 */
+	gcSHADER_SAMPLER_EXTERNAL_OES,		/* 0x26 */
+    gcSHADER_TYPE_COUNT
+}
+gcSHADER_TYPE;
+
+typedef enum _gcSHADER_VAR_CATEGORY
+{
+    gcSHADER_VAR_CATEGORY_NORMAL  =  0, /* primitive type and its array */
+    gcSHADER_VAR_CATEGORY_STRUCT  =  1  /* structure */
+}
+gcSHADER_VAR_CATEGORY;
+
+#if GC_ENABLE_LOADTIME_OPT
+
+typedef struct _gcSHADER_TYPE_INFO
+{
+    gcSHADER_TYPE    type;        /* eg. gcSHADER_FLOAT_2X3 is the type */
+    gctCONST_STRING  name;        /* the name of the type: "gcSHADER_FLOAT_2X3" */
+    gcSHADER_TYPE    baseType;    /* its base type is gcSHADER_FLOAT_2 */
+    gctINT           components;  /* it has 2 components */
+    gctINT           rows;        /* and 3 rows */
+    gctINT           size;        /* the size in byte */
+} gcSHADER_TYPE_INFO;
+
+enum gceLTCDumpOption {
+    gceLTC_DUMP_UNIFORM      = 0x0001,
+    gceLTC_DUMP_EVALUATION   = 0x0002,
+    gceLTC_DUMP_EXPESSION    = 0x0004,
+    gceLTC_DUMP_COLLECTING   = 0x0008,
+};
+
+gctBOOL gcDumpOption(gctINT Opt);
+
+extern gcSHADER_TYPE_INFO shader_type_info[];
+
+#endif /* GC_ENABLE_LOADTIME_OPT */
+
+
+#define IS_MATRIX_TYPE(type) \
+    (((type >= gcSHADER_FLOAT_2X2) && (type <= gcSHADER_FLOAT_4X4)) || \
+     ((type >= gcSHADER_FLOAT_2X3) && (type <= gcSHADER_FLOAT_4X3)))
+
+/* gcSHADER_PRECISION enumeration. */
+typedef enum _gcSHADER_PRECISION
+{
+	gcSHADER_PRECISION_DEFAULT,				/* 0x00 */
+	gcSHADER_PRECISION_HIGH,				/* 0x01 */
+	gcSHADER_PRECISION_MEDIUM,				/* 0x02 */
+	gcSHADER_PRECISION_LOW,				    /* 0x03 */
+}
+gcSHADER_PRECISION;
+
+/* Shader flags. */
+typedef enum _gceSHADER_FLAGS
+{
+    gcvSHADER_NO_OPTIMIZATION           = 0x00,
+	gcvSHADER_DEAD_CODE					= 0x01,
+	gcvSHADER_RESOURCE_USAGE			= 0x02,
+	gcvSHADER_OPTIMIZER					= 0x04,
+	gcvSHADER_USE_GL_Z					= 0x08,
+          /*
+                The GC family of GPU cores model GC860 and under require the Z
+                to be from 0 <= z <= w.
+                However, OpenGL specifies the Z to be from -w <= z <= w.  So we
+                have to a conversion here:
+
+                    z = (z + w) / 2.
+
+                So here we append two instructions to the vertex shader.
+            */
+	gcvSHADER_USE_GL_POSITION			= 0x10,
+	gcvSHADER_USE_GL_FACE				= 0x20,
+	gcvSHADER_USE_GL_POINT_COORD		= 0x40,
+	gcvSHADER_LOADTIME_OPTIMIZER		= 0x80,
+}
+gceSHADER_FLAGS;
+
+/* Function argument qualifier */
+typedef enum _gceINPUT_OUTPUT
+{
+	gcvFUNCTION_INPUT,
+	gcvFUNCTION_OUTPUT,
+	gcvFUNCTION_INOUT
+}
+gceINPUT_OUTPUT;
+
+/* Kernel function property flags. */
+typedef enum _gcePROPERTY_FLAGS
+{
+	gcvPROPERTY_REQD_WORK_GRP_SIZE	= 0x01
+}
+gceKERNEL_FUNCTION_PROPERTY_FLAGS;
+
+/* Uniform flags. */
+typedef enum _gceUNIFORM_FLAGS
+{
+	gcvUNIFORM_KERNEL_ARG			= 0x01,
+	gcvUNIFORM_KERNEL_ARG_LOCAL		= 0x02,
+	gcvUNIFORM_KERNEL_ARG_SAMPLER		= 0x04,
+	gcvUNIFORM_LOCAL_ADDRESS_SPACE		= 0x08,
+	gcvUNIFORM_PRIVATE_ADDRESS_SPACE	= 0x10,
+	gcvUNIFORM_CONSTANT_ADDRESS_SPACE	= 0x20,
+	gcvUNIFORM_GLOBAL_SIZE			= 0x40,
+	gcvUNIFORM_LOCAL_SIZE			= 0x80,
+	gcvUNIFORM_NUM_GROUPS			= 0x100,
+	gcvUNIFORM_GLOBAL_OFFSET		= 0x200,
+	gcvUNIFORM_WORK_DIM			= 0x400,
+	gcvUNIFORM_KERNEL_ARG_CONSTANT		= 0x800,
+	gcvUNIFORM_KERNEL_ARG_LOCAL_MEM_SIZE	= 0x1000,
+	gcvUNIFORM_KERNEL_ARG_PRIVATE		= 0x2000,
+	gcvUNIFORM_LOADTIME_CONSTANT		= 0x4000,
+}
+gceUNIFORM_FLAGS;
+
+#define gcdUNIFORM_KERNEL_ARG_MASK  (gcvUNIFORM_KERNEL_ARG         | \
+                                     gcvUNIFORM_KERNEL_ARG_LOCAL   | \
+									 gcvUNIFORM_KERNEL_ARG_SAMPLER | \
+									 gcvUNIFORM_KERNEL_ARG_PRIVATE | \
+									 gcvUNIFORM_KERNEL_ARG_CONSTANT)
+
+typedef enum _gceVARIABLE_UPDATE_FLAGS
+{
+    gceVARIABLE_UPDATE_NOUPDATE = 0,
+    gceVARIABLE_UPDATE_TEMPREG,
+}gceVARIABLE_UPDATE_FLAGS;
+
+/*******************************************************************************
+**  gcSHADER_SetCompilerVersion
+**
+**  Set the compiler version of a gcSHADER object.
+**
+**  INPUT:
+**
+**      gcSHADER Shader
+**          Pointer to gcSHADER object
+**
+**      gctINT *Version
+**          Pointer to a two word version
+*/
+gceSTATUS
+gcSHADER_SetCompilerVersion(
+    IN gcSHADER Shader,
+    IN gctUINT32 *Version
+    );
+
+/*******************************************************************************
+**  gcSHADER_GetCompilerVersion
+**
+**  Get the compiler version of a gcSHADER object.
+**
+**  INPUT:
+**
+**      gcSHADER Shader
+**          Pointer to a gcSHADER object.
+**
+**  OUTPUT:
+**
+**      gctUINT32_PTR *CompilerVersion.
+**          Pointer to holder of returned compilerVersion pointer
+*/
+gceSTATUS
+gcSHADER_GetCompilerVersion(
+    IN gcSHADER Shader,
+    OUT gctUINT32_PTR *CompilerVersion
+    );
+
+/*******************************************************************************
+**  gcSHADER_GetType
+**
+**  Get the gcSHADER object's type.
+**
+**  INPUT:
+**
+**      gcSHADER Shader
+**          Pointer to a gcSHADER object.
+**
+**  OUTPUT:
+**
+**      gctINT *Type.
+**          Pointer to return shader type.
+*/
+gceSTATUS
+gcSHADER_GetType(
+    IN gcSHADER Shader,
+    OUT gctINT *Type
+    );
+/*******************************************************************************
+**                             gcSHADER_Construct
+********************************************************************************
+**
+**	Construct a new gcSHADER object.
+**
+**	INPUT:
+**
+**		gcoOS Hal
+**			Pointer to an gcoHAL object.
+**
+**		gctINT ShaderType
+**			Type of gcSHADER object to cerate.  'ShaderType' can be one of the
+**			following:
+**
+**				gcSHADER_TYPE_VERTEX	Vertex shader.
+**				gcSHADER_TYPE_FRAGMENT	Fragment shader.
+**
+**	OUTPUT:
+**
+**		gcSHADER * Shader
+**			Pointer to a variable receiving the gcSHADER object pointer.
+*/
+gceSTATUS
+gcSHADER_Construct(
+	IN gcoHAL Hal,
+	IN gctINT ShaderType,
+	OUT gcSHADER * Shader
+	);
+
+/*******************************************************************************
+**                              gcSHADER_Destroy
+********************************************************************************
+**
+**	Destroy a gcSHADER object.
+**
+**	INPUT:
+**
+**		gcSHADER Shader
+**			Pointer to a gcSHADER object.
+**
+**	OUTPUT:
+**
+**		Nothing.
+*/
+gceSTATUS
+gcSHADER_Destroy(
+	IN gcSHADER Shader
+	);
+
+/*******************************************************************************
+**                              gcSHADER_Copy
+********************************************************************************
+**
+**	Copy a gcSHADER object.
+**
+**	INPUT:
+**
+**		gcSHADER Shader
+**			Pointer to a gcSHADER object.
+**
+**      gcSHADER Source
+**          Pointer to a gcSHADER object that will be copied.
+**
+**	OUTPUT:
+**
+**		Nothing.
+*/
+gceSTATUS
+gcSHADER_Copy(
+	IN gcSHADER Shader,
+	IN gcSHADER Source
+	);
+
+/*******************************************************************************
+**  gcSHADER_LoadHeader
+**
+**  Load a gcSHADER object from a binary buffer.  The binary buffer is layed out
+**  as follows:
+**      // Six word header
+**      // Signature, must be 'S','H','D','R'.
+**      gctINT8             signature[4];
+**      gctUINT32           binFileVersion;
+**      gctUINT32           compilerVersion[2];
+**      gctUINT32           gcSLVersion;
+**      gctUINT32           binarySize;
+**
+**  INPUT:
+**
+**      gcSHADER Shader
+**          Pointer to a gcSHADER object.
+**          Shader type will be returned if type in shader object is not gcSHADER_TYPE_PRECOMPILED
+**
+**      gctPOINTER Buffer
+**          Pointer to a binary buffer containing the shader data to load.
+**
+**      gctSIZE_T BufferSize
+**          Number of bytes inside the binary buffer pointed to by 'Buffer'.
+**
+**  OUTPUT:
+**      nothing
+**
+*/
+gceSTATUS
+gcSHADER_LoadHeader(
+    IN gcSHADER Shader,
+    IN gctPOINTER Buffer,
+    IN gctSIZE_T BufferSize,
+    OUT gctUINT32 * ShaderVersion
+    );
+
+/*******************************************************************************
+**  gcSHADER_LoadKernel
+**
+**  Load a kernel function given by name into gcSHADER object
+**
+**  INPUT:
+**
+**      gcSHADER Shader
+**          Pointer to a gcSHADER object.
+**
+**      gctSTRING KernelName
+**          Pointer to a kernel function name
+**
+**  OUTPUT:
+**      nothing
+**
+*/
+gceSTATUS
+gcSHADER_LoadKernel(
+    IN gcSHADER Shader,
+    IN gctSTRING KernelName
+    );
+
+/*******************************************************************************
+**                                gcSHADER_Load
+********************************************************************************
+**
+**	Load a gcSHADER object from a binary buffer.
+**
+**	INPUT:
+**
+**		gcSHADER Shader
+**			Pointer to a gcSHADER object.
+**
+**		gctPOINTER Buffer
+**			Pointer to a binary buffer containg the shader data to load.
+**
+**		gctSIZE_T BufferSize
+**			Number of bytes inside the binary buffer pointed to by 'Buffer'.
+**
+**	OUTPUT:
+**
+**		Nothing.
+*/
+gceSTATUS
+gcSHADER_Load(
+	IN gcSHADER Shader,
+	IN gctPOINTER Buffer,
+	IN gctSIZE_T BufferSize
+	);
+
+/*******************************************************************************
+**                                gcSHADER_Save
+********************************************************************************
+**
+**	Save a gcSHADER object to a binary buffer.
+**
+**	INPUT:
+**
+**		gcSHADER Shader
+**			Pointer to a gcSHADER object.
+**
+**		gctPOINTER Buffer
+**			Pointer to a binary buffer to be used as storage for the gcSHADER
+**			object.  If 'Buffer' is gcvNULL, the gcSHADER object will not be saved,
+**			but the number of bytes required to hold the binary output for the
+**			gcSHADER object will be returned.
+**
+**		gctSIZE_T * BufferSize
+**			Pointer to a variable holding the number of bytes allocated in
+**			'Buffer'.  Only valid if 'Buffer' is not gcvNULL.
+**
+**	OUTPUT:
+**
+**		gctSIZE_T * BufferSize
+**			Pointer to a variable receiving the number of bytes required to hold
+**			the binary form of the gcSHADER object.
+*/
+gceSTATUS
+gcSHADER_Save(
+	IN gcSHADER Shader,
+	IN gctPOINTER Buffer,
+	IN OUT gctSIZE_T * BufferSize
+	);
+
+/*******************************************************************************
+**                                gcSHADER_LoadEx
+********************************************************************************
+**
+**	Load a gcSHADER object from a binary buffer.
+**
+**	INPUT:
+**
+**		gcSHADER Shader
+**			Pointer to a gcSHADER object.
+**
+**		gctPOINTER Buffer
+**			Pointer to a binary buffer containg the shader data to load.
+**
+**		gctSIZE_T BufferSize
+**			Number of bytes inside the binary buffer pointed to by 'Buffer'.
+**
+**	OUTPUT:
+**
+**		Nothing.
+*/
+gceSTATUS
+gcSHADER_LoadEx(
+	IN gcSHADER Shader,
+	IN gctPOINTER Buffer,
+	IN gctSIZE_T BufferSize
+	);
+
+/*******************************************************************************
+**                                gcSHADER_SaveEx
+********************************************************************************
+**
+**	Save a gcSHADER object to a binary buffer.
+**
+**	INPUT:
+**
+**		gcSHADER Shader
+**			Pointer to a gcSHADER object.
+**
+**		gctPOINTER Buffer
+**			Pointer to a binary buffer to be used as storage for the gcSHADER
+**			object.  If 'Buffer' is gcvNULL, the gcSHADER object will not be saved,
+**			but the number of bytes required to hold the binary output for the
+**			gcSHADER object will be returned.
+**
+**		gctSIZE_T * BufferSize
+**			Pointer to a variable holding the number of bytes allocated in
+**			'Buffer'.  Only valid if 'Buffer' is not gcvNULL.
+**
+**	OUTPUT:
+**
+**		gctSIZE_T * BufferSize
+**			Pointer to a variable receiving the number of bytes required to hold
+**			the binary form of the gcSHADER object.
+*/
+gceSTATUS
+gcSHADER_SaveEx(
+	IN gcSHADER Shader,
+	IN gctPOINTER Buffer,
+	IN OUT gctSIZE_T * BufferSize
+	);
+
+/*******************************************************************************
+**  gcSHADER_ReallocateAttributes
+**
+**  Reallocate an array of pointers to gcATTRIBUTE objects.
+**
+**  INPUT:
+**
+**      gcSHADER Shader
+**          Pointer to a gcSHADER object.
+**
+**      gctSIZE_T Count
+**          Array count to reallocate.  'Count' must be at least 1.
+*/
+gceSTATUS
+gcSHADER_ReallocateAttributes(
+    IN gcSHADER Shader,
+    IN gctSIZE_T Count
+    );
+
+/*******************************************************************************
+**							  gcSHADER_AddAttribute
+********************************************************************************
+**
+**	Add an attribute to a gcSHADER object.
+**
+**	INPUT:
+**
+**		gcSHADER Shader
+**			Pointer to a gcSHADER object.
+**
+**		gctCONST_STRING Name
+**			Name of the attribute to add.
+**
+**		gcSHADER_TYPE Type
+**			Type of the attribute to add.
+**
+**		gctSIZE_T Length
+**			Array length of the attribute to add.  'Length' must be at least 1.
+**
+**		gctBOOL IsTexture
+**			gcvTRUE if the attribute is used as a texture coordinate, gcvFALSE if not.
+**
+**	OUTPUT:
+**
+**		gcATTRIBUTE * Attribute
+**			Pointer to a variable receiving the gcATTRIBUTE object pointer.
+*/
+gceSTATUS
+gcSHADER_AddAttribute(
+	IN gcSHADER Shader,
+	IN gctCONST_STRING Name,
+	IN gcSHADER_TYPE Type,
+	IN gctSIZE_T Length,
+	IN gctBOOL IsTexture,
+	OUT gcATTRIBUTE * Attribute
+	);
+
+/*******************************************************************************
+**                         gcSHADER_GetAttributeCount
+********************************************************************************
+**
+**	Get the number of attributes for this shader.
+**
+**	INPUT:
+**
+**		gcSHADER Shader
+**			Pointer to a gcSHADER object.
+**
+**	OUTPUT:
+**
+**		gctSIZE_T * Count
+**			Pointer to a variable receiving the number of attributes.
+*/
+gceSTATUS
+gcSHADER_GetAttributeCount(
+	IN gcSHADER Shader,
+	OUT gctSIZE_T * Count
+	);
+
+/*******************************************************************************
+**                            gcSHADER_GetAttribute
+********************************************************************************
+**
+**	Get the gcATTRIBUTE object poniter for an indexed attribute for this shader.
+**
+**	INPUT:
+**
+**		gcSHADER Shader
+**			Pointer to a gcSHADER object.
+**
+**		gctUINT Index
+**			Index of the attribute to retrieve.
+**
+**	OUTPUT:
+**
+**		gcATTRIBUTE * Attribute
+**			Pointer to a variable receiving the gcATTRIBUTE object pointer.
+*/
+gceSTATUS
+gcSHADER_GetAttribute(
+	IN gcSHADER Shader,
+	IN gctUINT Index,
+	OUT gcATTRIBUTE * Attribute
+	);
+
+/*******************************************************************************
+**  gcSHADER_ReallocateUniforms
+**
+**  Reallocate an array of pointers to gcUNIFORM objects.
+**
+**  INPUT:
+**
+**      gcSHADER Shader
+**          Pointer to a gcSHADER object.
+**
+**      gctSIZE_T Count
+**          Array count to reallocate.  'Count' must be at least 1.
+*/
+gceSTATUS
+gcSHADER_ReallocateUniforms(
+    IN gcSHADER Shader,
+    IN gctSIZE_T Count
+    );
+
+/*******************************************************************************
+**							   gcSHADER_AddUniform
+********************************************************************************
+**
+**	Add an uniform to a gcSHADER object.
+**
+**	INPUT:
+**
+**		gcSHADER Shader
+**			Pointer to a gcSHADER object.
+**
+**		gctCONST_STRING Name
+**			Name of the uniform to add.
+**
+**		gcSHADER_TYPE Type
+**			Type of the uniform to add.
+**
+**		gctSIZE_T Length
+**			Array length of the uniform to add.  'Length' must be at least 1.
+**
+**	OUTPUT:
+**
+**		gcUNIFORM * Uniform
+**			Pointer to a variable receiving the gcUNIFORM object pointer.
+*/
+gceSTATUS
+gcSHADER_AddUniform(
+	IN gcSHADER Shader,
+	IN gctCONST_STRING Name,
+	IN gcSHADER_TYPE Type,
+	IN gctSIZE_T Length,
+	OUT gcUNIFORM * Uniform
+	);
+
+
+/*******************************************************************************
+**							   gcSHADER_AddUniformEx
+********************************************************************************
+**
+**	Add an uniform to a gcSHADER object.
+**
+**	INPUT:
+**
+**		gcSHADER Shader
+**			Pointer to a gcSHADER object.
+**
+**		gctCONST_STRING Name
+**			Name of the uniform to add.
+**
+**		gcSHADER_TYPE Type
+**			Type of the uniform to add.
+**
+**      gcSHADER_PRECISION precision
+**          Precision of the uniform to add.
+**
+**		gctSIZE_T Length
+**			Array length of the uniform to add.  'Length' must be at least 1.
+**
+**	OUTPUT:
+**
+**		gcUNIFORM * Uniform
+**			Pointer to a variable receiving the gcUNIFORM object pointer.
+*/
+gceSTATUS
+gcSHADER_AddUniformEx(
+	IN gcSHADER Shader,
+	IN gctCONST_STRING Name,
+	IN gcSHADER_TYPE Type,
+    IN gcSHADER_PRECISION precision,
+	IN gctSIZE_T Length,
+	OUT gcUNIFORM * Uniform
+	);
+
+/*******************************************************************************
+**                          gcSHADER_GetUniformCount
+********************************************************************************
+**
+**	Get the number of uniforms for this shader.
+**
+**	INPUT:
+**
+**		gcSHADER Shader
+**			Pointer to a gcSHADER object.
+**
+**	OUTPUT:
+**
+**		gctSIZE_T * Count
+**			Pointer to a variable receiving the number of uniforms.
+*/
+gceSTATUS
+gcSHADER_GetUniformCount(
+	IN gcSHADER Shader,
+	OUT gctSIZE_T * Count
+	);
+
+/*******************************************************************************
+**                             gcSHADER_GetUniform
+********************************************************************************
+**
+**	Get the gcUNIFORM object pointer for an indexed uniform for this shader.
+**
+**	INPUT:
+**
+**		gcSHADER Shader
+**			Pointer to a gcSHADER object.
+**
+**		gctUINT Index
+**			Index of the uniform to retrieve.
+**
+**	OUTPUT:
+**
+**		gcUNIFORM * Uniform
+**			Pointer to a variable receiving the gcUNIFORM object pointer.
+*/
+gceSTATUS
+gcSHADER_GetUniform(
+	IN gcSHADER Shader,
+	IN gctUINT Index,
+	OUT gcUNIFORM * Uniform
+	);
+
+/*******************************************************************************
+**  gcSHADER_GetKernelFucntion
+**
+**  Get the gcKERNEL_FUNCTION object pointer for an indexed kernel function for this shader.
+**
+**  INPUT:
+**
+**      gcSHADER Shader
+**          Pointer to a gcSHADER object.
+**
+**      gctUINT Index
+**          Index of kernel function to retreive the name for.
+**
+**  OUTPUT:
+**
+**      gcKERNEL_FUNCTION * KernelFunction
+**          Pointer to a variable receiving the gcKERNEL_FUNCTION object pointer.
+*/
+gceSTATUS
+gcSHADER_GetKernelFunction(
+    IN gcSHADER Shader,
+    IN gctUINT Index,
+    OUT gcKERNEL_FUNCTION * KernelFunction
+    );
+
+gceSTATUS
+gcSHADER_GetKernelFunctionByName(
+	IN gcSHADER Shader,
+    IN gctSTRING KernelName,
+    OUT gcKERNEL_FUNCTION * KernelFunction
+    );
+/*******************************************************************************
+**  gcSHADER_GetKernelFunctionCount
+**
+**  Get the number of kernel functions for this shader.
+**
+**  INPUT:
+**
+**      gcSHADER Shader
+**          Pointer to a gcSHADER object.
+**
+**  OUTPUT:
+**
+**      gctSIZE_T * Count
+**          Pointer to a variable receiving the number of kernel functions.
+*/
+gceSTATUS
+gcSHADER_GetKernelFunctionCount(
+    IN gcSHADER Shader,
+    OUT gctSIZE_T * Count
+    );
+
+/*******************************************************************************
+**  gcSHADER_ReallocateOutputs
+**
+**  Reallocate an array of pointers to gcOUTPUT objects.
+**
+**  INPUT:
+**
+**      gcSHADER Shader
+**          Pointer to a gcSHADER object.
+**
+**      gctSIZE_T Count
+**          Array count to reallocate.  'Count' must be at least 1.
+*/
+gceSTATUS
+gcSHADER_ReallocateOutputs(
+    IN gcSHADER Shader,
+    IN gctSIZE_T Count
+    );
+
+/*******************************************************************************
+**							   gcSHADER_AddOutput
+********************************************************************************
+**
+**	Add an output to a gcSHADER object.
+**
+**	INPUT:
+**
+**		gcSHADER Shader
+**			Pointer to a gcSHADER object.
+**
+**		gctCONST_STRING Name
+**			Name of the output to add.
+**
+**		gcSHADER_TYPE Type
+**			Type of the output to add.
+**
+**		gctSIZE_T Length
+**			Array length of the output to add.  'Length' must be at least 1.
+**
+**		gctUINT16 TempRegister
+**			Temporary register index that holds the output value.
+**
+**	OUTPUT:
+**
+**		Nothing.
+*/
+gceSTATUS
+gcSHADER_AddOutput(
+	IN gcSHADER Shader,
+	IN gctCONST_STRING Name,
+	IN gcSHADER_TYPE Type,
+	IN gctSIZE_T Length,
+	IN gctUINT16 TempRegister
+	);
+
+gceSTATUS
+gcSHADER_AddOutputIndexed(
+	IN gcSHADER Shader,
+	IN gctCONST_STRING Name,
+	IN gctSIZE_T Index,
+	IN gctUINT16 TempIndex
+	);
+
+/*******************************************************************************
+**							 gcSHADER_GetOutputCount
+********************************************************************************
+**
+**	Get the number of outputs for this shader.
+**
+**	INPUT:
+**
+**		gcSHADER Shader
+**			Pointer to a gcSHADER object.
+**
+**	OUTPUT:
+**
+**		gctSIZE_T * Count
+**			Pointer to a variable receiving the number of outputs.
+*/
+gceSTATUS
+gcSHADER_GetOutputCount(
+	IN gcSHADER Shader,
+	OUT gctSIZE_T * Count
+	);
+
+/*******************************************************************************
+**							   gcSHADER_GetOutput
+********************************************************************************
+**
+**	Get the gcOUTPUT object pointer for an indexed output for this shader.
+**
+**	INPUT:
+**
+**		gcSHADER Shader
+**			Pointer to a gcSHADER object.
+**
+**		gctUINT Index
+**			Index of output to retrieve.
+**
+**	OUTPUT:
+**
+**		gcOUTPUT * Output
+**			Pointer to a variable receiving the gcOUTPUT object pointer.
+*/
+gceSTATUS
+gcSHADER_GetOutput(
+	IN gcSHADER Shader,
+	IN gctUINT Index,
+	OUT gcOUTPUT * Output
+	);
+
+
+/*******************************************************************************
+**							   gcSHADER_GetOutputByName
+********************************************************************************
+**
+**	Get the gcOUTPUT object pointer for this shader by output name.
+**
+**	INPUT:
+**
+**		gcSHADER Shader
+**			Pointer to a gcSHADER object.
+**
+**		gctSTRING name
+**			Name of output to retrieve.
+**
+**      gctSIZE_T nameLength
+**          Length of name to retrieve
+**
+**	OUTPUT:
+**
+**		gcOUTPUT * Output
+**			Pointer to a variable receiving the gcOUTPUT object pointer.
+*/
+gceSTATUS
+gcSHADER_GetOutputByName(
+	IN gcSHADER Shader,
+	IN gctSTRING name,
+    IN gctSIZE_T nameLength,
+	OUT gcOUTPUT * Output
+	);
+
+/*******************************************************************************
+**  gcSHADER_ReallocateVariables
+**
+**  Reallocate an array of pointers to gcVARIABLE objects.
+**
+**  INPUT:
+**
+**      gcSHADER Shader
+**          Pointer to a gcSHADER object.
+**
+**      gctSIZE_T Count
+**          Array count to reallocate.  'Count' must be at least 1.
+*/
+gceSTATUS
+gcSHADER_ReallocateVariables(
+    IN gcSHADER Shader,
+    IN gctSIZE_T Count
+    );
+
+/*******************************************************************************
+**							   gcSHADER_AddVariable
+********************************************************************************
+**
+**	Add a variable to a gcSHADER object.
+**
+**	INPUT:
+**
+**		gcSHADER Shader
+**			Pointer to a gcSHADER object.
+**
+**		gctCONST_STRING Name
+**			Name of the variable to add.
+**
+**		gcSHADER_TYPE Type
+**			Type of the variable to add.
+**
+**		gctSIZE_T Length
+**			Array length of the variable to add.  'Length' must be at least 1.
+**
+**		gctUINT16 TempRegister
+**			Temporary register index that holds the variable value.
+**
+**	OUTPUT:
+**
+**		Nothing.
+*/
+gceSTATUS
+gcSHADER_AddVariable(
+	IN gcSHADER Shader,
+	IN gctCONST_STRING Name,
+	IN gcSHADER_TYPE Type,
+	IN gctSIZE_T Length,
+	IN gctUINT16 TempRegister
+	);
+
+
+/*******************************************************************************
+**  gcSHADER_AddVariableEx
+********************************************************************************
+**
+**  Add a variable to a gcSHADER object.
+**
+**  INPUT:
+**
+**      gcSHADER Shader
+**          Pointer to a gcSHADER object.
+**
+**      gctCONST_STRING Name
+**          Name of the variable to add.
+**
+**      gcSHADER_TYPE Type
+**          Type of the variable to add.
+**
+**      gctSIZE_T Length
+**          Array length of the variable to add.  'Length' must be at least 1.
+**
+**      gctUINT16 TempRegister
+**          Temporary register index that holds the variable value.
+**
+**      gcSHADER_VAR_CATEGORY varCategory
+**          Variable category, normal or struct.
+**
+**      gctUINT16 numStructureElement
+**          If struct, its element number.
+**
+**      gctINT16 parent
+**          If struct, parent index in gcSHADER.variables.
+**
+**      gctINT16 preSibling
+**          If struct, previous sibling index in gcSHADER.variables.
+**
+**      gctINT16* ThisVarIndex
+**          Returned value about variable index in gcSHADER.
+**
+**  OUTPUT:
+**
+**      Nothing.
+*/
+gceSTATUS
+gcSHADER_AddVariableEx(
+    IN gcSHADER Shader,
+    IN gctCONST_STRING Name,
+    IN gcSHADER_TYPE Type,
+    IN gctSIZE_T Length,
+    IN gctUINT16 TempRegister,
+    IN gcSHADER_VAR_CATEGORY varCategory,
+    IN gctUINT16 numStructureElement,
+    IN gctINT16 parent,
+    IN gctINT16 preSibling,
+    OUT gctINT16* ThisVarIndex
+    );
+
+/*******************************************************************************
+**  gcSHADER_UpdateVariable
+********************************************************************************
+**
+**  Update a variable to a gcSHADER object.
+**
+**  INPUT:
+**
+**		gcSHADER Shader
+**			Pointer to a gcSHADER object.
+**
+**		gctUINT Index
+**			Index of variable to retrieve.
+**
+**		gceVARIABLE_UPDATE_FLAGS flag
+**			Flag which property of variable will be updated.
+**
+**      gctUINT16 newValue
+**          New value to update.
+**
+**  OUTPUT:
+**
+**      Nothing.
+*/
+gceSTATUS
+gcSHADER_UpdateVariable(
+    IN gcSHADER Shader,
+    IN gctUINT Index,
+    IN gceVARIABLE_UPDATE_FLAGS flag,
+    IN gctUINT16 newValue
+    );
+
+/*******************************************************************************
+**							 gcSHADER_GetVariableCount
+********************************************************************************
+**
+**	Get the number of variables for this shader.
+**
+**	INPUT:
+**
+**		gcSHADER Shader
+**			Pointer to a gcSHADER object.
+**
+**	OUTPUT:
+**
+**		gctSIZE_T * Count
+**			Pointer to a variable receiving the number of variables.
+*/
+gceSTATUS
+gcSHADER_GetVariableCount(
+	IN gcSHADER Shader,
+	OUT gctSIZE_T * Count
+	);
+
+/*******************************************************************************
+**							   gcSHADER_GetVariable
+********************************************************************************
+**
+**	Get the gcVARIABLE object pointer for an indexed variable for this shader.
+**
+**	INPUT:
+**
+**		gcSHADER Shader
+**			Pointer to a gcSHADER object.
+**
+**		gctUINT Index
+**			Index of variable to retrieve.
+**
+**	OUTPUT:
+**
+**		gcVARIABLE * Variable
+**			Pointer to a variable receiving the gcVARIABLE object pointer.
+*/
+gceSTATUS
+gcSHADER_GetVariable(
+	IN gcSHADER Shader,
+	IN gctUINT Index,
+	OUT gcVARIABLE * Variable
+	);
+
+/*******************************************************************************
+**							   gcSHADER_AddOpcode
+********************************************************************************
+**
+**	Add an opcode to a gcSHADER object.
+**
+**	INPUT:
+**
+**		gcSHADER Shader
+**			Pointer to a gcSHADER object.
+**
+**		gcSL_OPCODE Opcode
+**			Opcode to add.
+**
+**		gctUINT16 TempRegister
+**			Temporary register index that acts as the target of the opcode.
+**
+**		gctUINT8 Enable
+**			Write enable bits for the temporary register that acts as the target
+**			of the opcode.
+**
+**		gcSL_FORMAT Format
+**			Format of the temporary register.
+**
+**	OUTPUT:
+**
+**		Nothing.
+*/
+gceSTATUS
+gcSHADER_AddOpcode(
+	IN gcSHADER Shader,
+	IN gcSL_OPCODE Opcode,
+	IN gctUINT16 TempRegister,
+	IN gctUINT8 Enable,
+	IN gcSL_FORMAT Format
+	);
+
+gceSTATUS
+gcSHADER_AddOpcode2(
+	IN gcSHADER Shader,
+	IN gcSL_OPCODE Opcode,
+	IN gcSL_CONDITION Condition,
+	IN gctUINT16 TempRegister,
+	IN gctUINT8 Enable,
+	IN gcSL_FORMAT Format
+	);
+
+/*******************************************************************************
+**							gcSHADER_AddOpcodeIndexed
+********************************************************************************
+**
+**	Add an opcode to a gcSHADER object that writes to an dynamically indexed
+**	target.
+**
+**	INPUT:
+**
+**		gcSHADER Shader
+**			Pointer to a gcSHADER object.
+**
+**		gcSL_OPCODE Opcode
+**			Opcode to add.
+**
+**		gctUINT16 TempRegister
+**			Temporary register index that acts as the target of the opcode.
+**
+**		gctUINT8 Enable
+**			Write enable bits  for the temporary register that acts as the
+**			target of the opcode.
+**
+**		gcSL_INDEXED Mode
+**			Location of the dynamic index inside the temporary register.  Valid
+**			values can be:
+**
+**				gcSL_INDEXED_X - Use x component of the temporary register.
+**				gcSL_INDEXED_Y - Use y component of the temporary register.
+**				gcSL_INDEXED_Z - Use z component of the temporary register.
+**				gcSL_INDEXED_W - Use w component of the temporary register.
+**
+**		gctUINT16 IndexRegister
+**			Temporary register index that holds the dynamic index.
+**
+**		gcSL_FORMAT Format
+**			Format of the temporary register.
+**
+**	OUTPUT:
+**
+**		Nothing.
+*/
+gceSTATUS
+gcSHADER_AddOpcodeIndexed(
+	IN gcSHADER Shader,
+	IN gcSL_OPCODE Opcode,
+	IN gctUINT16 TempRegister,
+	IN gctUINT8 Enable,
+	IN gcSL_INDEXED Mode,
+	IN gctUINT16 IndexRegister,
+	IN gcSL_FORMAT Format
+	);
+
+/*******************************************************************************
+**  gcSHADER_AddOpcodeConditionIndexed
+**
+**  Add an opcode to a gcSHADER object that writes to an dynamically indexed
+**  target.
+**
+**  INPUT:
+**
+**      gcSHADER Shader
+**          Pointer to a gcSHADER object.
+**
+**      gcSL_OPCODE Opcode
+**          Opcode to add.
+**
+**      gcSL_CONDITION Condition
+**          Condition to check.
+**
+**      gctUINT16 TempRegister
+**          Temporary register index that acts as the target of the opcode.
+**
+**      gctUINT8 Enable
+**          Write enable bits  for the temporary register that acts as the
+**          target of the opcode.
+**
+**      gcSL_INDEXED Indexed
+**          Location of the dynamic index inside the temporary register.  Valid
+**          values can be:
+**
+**              gcSL_INDEXED_X - Use x component of the temporary register.
+**              gcSL_INDEXED_Y - Use y component of the temporary register.
+**              gcSL_INDEXED_Z - Use z component of the temporary register.
+**              gcSL_INDEXED_W - Use w component of the temporary register.
+**
+**      gctUINT16 IndexRegister
+**          Temporary register index that holds the dynamic index.
+**
+**  OUTPUT:
+**
+**      Nothing.
+*/
+gceSTATUS
+gcSHADER_AddOpcodeConditionIndexed(
+    IN gcSHADER Shader,
+    IN gcSL_OPCODE Opcode,
+    IN gcSL_CONDITION Condition,
+    IN gctUINT16 TempRegister,
+    IN gctUINT8 Enable,
+    IN gcSL_INDEXED Indexed,
+    IN gctUINT16 IndexRegister,
+    IN gcSL_FORMAT Format
+    );
+
+/*******************************************************************************
+**						  gcSHADER_AddOpcodeConditional
+********************************************************************************
+**
+**	Add an conditional opcode to a gcSHADER object.
+**
+**	INPUT:
+**
+**		gcSHADER Shader
+**			Pointer to a gcSHADER object.
+**
+**		gcSL_OPCODE Opcode
+**			Opcode to add.
+**
+**		gcSL_CONDITION Condition
+**			Condition that needs to evaluate to gcvTRUE in order for the opcode to
+**			execute.
+**
+**		gctUINT Label
+**			Target label if 'Condition' evaluates to gcvTRUE.
+**
+**	OUTPUT:
+**
+**		Nothing.
+*/
+gceSTATUS
+gcSHADER_AddOpcodeConditional(
+	IN gcSHADER Shader,
+	IN gcSL_OPCODE Opcode,
+	IN gcSL_CONDITION Condition,
+	IN gctUINT Label
+	);
+
+/*******************************************************************************
+**  gcSHADER_AddOpcodeConditionalFormatted
+**
+**  Add an conditional jump or call opcode to a gcSHADER object.
+**
+**  INPUT:
+**
+**      gcSHADER Shader
+**          Pointer to a gcSHADER object.
+**
+**      gcSL_OPCODE Opcode
+**          Opcode to add.
+**
+**      gcSL_CONDITION Condition
+**          Condition that needs to evaluate to gcvTRUE in order for the opcode to
+**          execute.
+**
+**      gcSL_FORMAT Format
+**          Format of conditional operands
+**
+**      gctUINT Label
+**          Target label if 'Condition' evaluates to gcvTRUE.
+**
+**  OUTPUT:
+**
+**      Nothing.
+*/
+gceSTATUS
+gcSHADER_AddOpcodeConditionalFormatted(
+    IN gcSHADER Shader,
+    IN gcSL_OPCODE Opcode,
+    IN gcSL_CONDITION Condition,
+    IN gcSL_FORMAT Format,
+    IN gctUINT Label
+    );
+
+/*******************************************************************************
+**  gcSHADER_AddOpcodeConditionalFormattedEnable
+**
+**  Add an conditional jump or call opcode to a gcSHADER object.
+**
+**  INPUT:
+**
+**      gcSHADER Shader
+**          Pointer to a gcSHADER object.
+**
+**      gcSL_OPCODE Opcode
+**          Opcode to add.
+**
+**      gcSL_CONDITION Condition
+**          Condition that needs to evaluate to gcvTRUE in order for the opcode to
+**          execute.
+**
+**      gcSL_FORMAT Format
+**          Format of conditional operands
+**
+**      gctUINT8 Enable
+**          Write enable value for the target of the opcode.
+**
+**      gctUINT Label
+**          Target label if 'Condition' evaluates to gcvTRUE.
+**
+**  OUTPUT:
+**
+**      Nothing.
+*/
+gceSTATUS
+gcSHADER_AddOpcodeConditionalFormattedEnable(
+    IN gcSHADER Shader,
+    IN gcSL_OPCODE Opcode,
+    IN gcSL_CONDITION Condition,
+    IN gcSL_FORMAT Format,
+    IN gctUINT8 Enable,
+    IN gctUINT Label
+    );
+
+/*******************************************************************************
+**								gcSHADER_AddLabel
+********************************************************************************
+**
+**	Define a label at the current instruction of a gcSHADER object.
+**
+**	INPUT:
+**
+**		gcSHADER Shader
+**			Pointer to a gcSHADER object.
+**
+**		gctUINT Label
+**			Label to define.
+**
+**	OUTPUT:
+**
+**		Nothing.
+*/
+gceSTATUS
+gcSHADER_AddLabel(
+	IN gcSHADER Shader,
+	IN gctUINT Label
+	);
+
+/*******************************************************************************
+**							   gcSHADER_AddSource
+********************************************************************************
+**
+**	Add a source operand to a gcSHADER object.
+**
+**	INPUT:
+**
+**		gcSHADER Shader
+**			Pointer to a gcSHADER object.
+**
+**		gcSL_TYPE Type
+**			Type of the source operand.
+**
+**		gctUINT16 SourceIndex
+**			Index of the source operand.
+**
+**		gctUINT8 Swizzle
+**			x, y, z, and w swizzle values packed into one 8-bit value.
+**
+**		gcSL_FORMAT Format
+**			Format of the source operand.
+**
+**	OUTPUT:
+**
+**		Nothing.
+*/
+gceSTATUS
+gcSHADER_AddSource(
+	IN gcSHADER Shader,
+	IN gcSL_TYPE Type,
+	IN gctUINT16 SourceIndex,
+	IN gctUINT8 Swizzle,
+	IN gcSL_FORMAT Format
+	);
+
+/*******************************************************************************
+**							gcSHADER_AddSourceIndexed
+********************************************************************************
+**
+**	Add a dynamically indexed source operand to a gcSHADER object.
+**
+**	INPUT:
+**
+**		gcSHADER Shader
+**			Pointer to a gcSHADER object.
+**
+**		gcSL_TYPE Type
+**			Type of the source operand.
+**
+**		gctUINT16 SourceIndex
+**			Index of the source operand.
+**
+**		gctUINT8 Swizzle
+**			x, y, z, and w swizzle values packed into one 8-bit value.
+**
+**		gcSL_INDEXED Mode
+**			Addressing mode for the index.
+**
+**		gctUINT16 IndexRegister
+**			Temporary register index that holds the dynamic index.
+**
+**		gcSL_FORMAT Format
+**			Format of the source operand.
+**
+**	OUTPUT:
+**
+**		Nothing.
+*/
+gceSTATUS
+gcSHADER_AddSourceIndexed(
+	IN gcSHADER Shader,
+	IN gcSL_TYPE Type,
+	IN gctUINT16 SourceIndex,
+	IN gctUINT8 Swizzle,
+	IN gcSL_INDEXED Mode,
+	IN gctUINT16 IndexRegister,
+	IN gcSL_FORMAT Format
+	);
+
+/*******************************************************************************
+**						   gcSHADER_AddSourceAttribute
+********************************************************************************
+**
+**	Add an attribute as a source operand to a gcSHADER object.
+**
+**	INPUT:
+**
+**		gcSHADER Shader
+**			Pointer to a gcSHADER object.
+**
+**		gcATTRIBUTE Attribute
+**			Pointer to a gcATTRIBUTE object.
+**
+**		gctUINT8 Swizzle
+**			x, y, z, and w swizzle values packed into one 8-bit value.
+**
+**		gctINT Index
+**			Static index into the attribute in case the attribute is a matrix
+**			or array.
+**
+**	OUTPUT:
+**
+**		Nothing.
+*/
+gceSTATUS
+gcSHADER_AddSourceAttribute(
+	IN gcSHADER Shader,
+	IN gcATTRIBUTE Attribute,
+	IN gctUINT8 Swizzle,
+	IN gctINT Index
+	);
+
+/*******************************************************************************
+**						   gcSHADER_AddSourceAttributeIndexed
+********************************************************************************
+**
+**	Add an indexed attribute as a source operand to a gcSHADER object.
+**
+**	INPUT:
+**
+**		gcSHADER Shader
+**			Pointer to a gcSHADER object.
+**
+**		gcATTRIBUTE Attribute
+**			Pointer to a gcATTRIBUTE object.
+**
+**		gctUINT8 Swizzle
+**			x, y, z, and w swizzle values packed into one 8-bit value.
+**
+**		gctINT Index
+**			Static index into the attribute in case the attribute is a matrix
+**			or array.
+**
+**		gcSL_INDEXED Mode
+**			Addressing mode of the dynamic index.
+**
+**		gctUINT16 IndexRegister
+**			Temporary register index that holds the dynamic index.
+**
+**	OUTPUT:
+**
+**		Nothing.
+*/
+gceSTATUS
+gcSHADER_AddSourceAttributeIndexed(
+	IN gcSHADER Shader,
+	IN gcATTRIBUTE Attribute,
+	IN gctUINT8 Swizzle,
+	IN gctINT Index,
+	IN gcSL_INDEXED Mode,
+	IN gctUINT16 IndexRegister
+	);
+
+/*******************************************************************************
+**							gcSHADER_AddSourceUniform
+********************************************************************************
+**
+**	Add a uniform as a source operand to a gcSHADER object.
+**
+**	INPUT:
+**
+**		gcSHADER Shader
+**			Pointer to a gcSHADER object.
+**
+**		gcUNIFORM Uniform
+**			Pointer to a gcUNIFORM object.
+**
+**		gctUINT8 Swizzle
+**			x, y, z, and w swizzle values packed into one 8-bit value.
+**
+**		gctINT Index
+**			Static index into the uniform in case the uniform is a matrix or
+**			array.
+**
+**	OUTPUT:
+**
+**		Nothing.
+*/
+gceSTATUS
+gcSHADER_AddSourceUniform(
+	IN gcSHADER Shader,
+	IN gcUNIFORM Uniform,
+	IN gctUINT8 Swizzle,
+	IN gctINT Index
+	);
+
+/*******************************************************************************
+**						gcSHADER_AddSourceUniformIndexed
+********************************************************************************
+**
+**	Add an indexed uniform as a source operand to a gcSHADER object.
+**
+**	INPUT:
+**
+**		gcSHADER Shader
+**			Pointer to a gcSHADER object.
+**
+**		gcUNIFORM Uniform
+**			Pointer to a gcUNIFORM object.
+**
+**		gctUINT8 Swizzle
+**			x, y, z, and w swizzle values packed into one 8-bit value.
+**
+**		gctINT Index
+**			Static index into the uniform in case the uniform is a matrix or
+**			array.
+**
+**		gcSL_INDEXED Mode
+**			Addressing mode of the dynamic index.
+**
+**		gctUINT16 IndexRegister
+**			Temporary register index that holds the dynamic index.
+**
+**	OUTPUT:
+**
+**		Nothing.
+*/
+gceSTATUS
+gcSHADER_AddSourceUniformIndexed(
+	IN gcSHADER Shader,
+	IN gcUNIFORM Uniform,
+	IN gctUINT8 Swizzle,
+	IN gctINT Index,
+	IN gcSL_INDEXED Mode,
+	IN gctUINT16 IndexRegister
+	);
+
+gceSTATUS
+gcSHADER_AddSourceSamplerIndexed(
+	IN gcSHADER Shader,
+	IN gctUINT8 Swizzle,
+	IN gcSL_INDEXED Mode,
+	IN gctUINT16 IndexRegister
+	);
+
+gceSTATUS
+gcSHADER_AddSourceAttributeFormatted(
+    IN gcSHADER Shader,
+    IN gcATTRIBUTE Attribute,
+    IN gctUINT8 Swizzle,
+    IN gctINT Index,
+    IN gcSL_FORMAT Format
+    );
+
+gceSTATUS
+gcSHADER_AddSourceAttributeIndexedFormatted(
+    IN gcSHADER Shader,
+    IN gcATTRIBUTE Attribute,
+    IN gctUINT8 Swizzle,
+    IN gctINT Index,
+    IN gcSL_INDEXED Mode,
+    IN gctUINT16 IndexRegister,
+    IN gcSL_FORMAT Format
+    );
+
+gceSTATUS
+gcSHADER_AddSourceUniformFormatted(
+    IN gcSHADER Shader,
+    IN gcUNIFORM Uniform,
+    IN gctUINT8 Swizzle,
+    IN gctINT Index,
+    IN gcSL_FORMAT Format
+    );
+
+gceSTATUS
+gcSHADER_AddSourceUniformIndexedFormatted(
+    IN gcSHADER Shader,
+    IN gcUNIFORM Uniform,
+    IN gctUINT8 Swizzle,
+    IN gctINT Index,
+    IN gcSL_INDEXED Mode,
+    IN gctUINT16 IndexRegister,
+    IN gcSL_FORMAT Format
+    );
+
+gceSTATUS
+gcSHADER_AddSourceSamplerIndexedFormatted(
+    IN gcSHADER Shader,
+    IN gctUINT8 Swizzle,
+    IN gcSL_INDEXED Mode,
+    IN gctUINT16 IndexRegister,
+    IN gcSL_FORMAT Format
+    );
+
+/*******************************************************************************
+**						   gcSHADER_AddSourceConstant
+********************************************************************************
+**
+**	Add a constant floating point value as a source operand to a gcSHADER
+**	object.
+**
+**	INPUT:
+**
+**		gcSHADER Shader
+**			Pointer to a gcSHADER object.
+**
+**		gctFLOAT Constant
+**			Floating point constant.
+**
+**	OUTPUT:
+**
+**		Nothing.
+*/
+gceSTATUS
+gcSHADER_AddSourceConstant(
+	IN gcSHADER Shader,
+	IN gctFLOAT Constant
+	);
+
+/*******************************************************************************
+**			                   gcSHADER_AddSourceConstantFormatted
+********************************************************************************
+**
+**	Add a constant value as a source operand to a gcSHADER
+**	object.
+**
+**	INPUT:
+**
+**		gcSHADER Shader
+**			Pointer to a gcSHADER object.
+**
+**		void * Constant
+**			Pointer to constant.
+**
+**		gcSL_FORMAT Format
+**
+**	OUTPUT:
+**
+**		Nothing.
+*/
+gceSTATUS
+gcSHADER_AddSourceConstantFormatted(
+	IN gcSHADER Shader,
+	IN void *Constant,
+	IN gcSL_FORMAT Format
+	);
+
+/*******************************************************************************
+**								  gcSHADER_Pack
+********************************************************************************
+**
+**	Pack a dynamically created gcSHADER object by trimming the allocated arrays
+**	and resolving all the labeling.
+**
+**	INPUT:
+**
+**		gcSHADER Shader
+**			Pointer to a gcSHADER object.
+**
+**	OUTPUT:
+**
+**		Nothing.
+*/
+gceSTATUS
+gcSHADER_Pack(
+	IN gcSHADER Shader
+	);
+
+/*******************************************************************************
+**								gcSHADER_SetOptimizationOption
+********************************************************************************
+**
+**	Set optimization option of a gcSHADER object.
+**
+**	INPUT:
+**
+**		gcSHADER Shader
+**			Pointer to a gcSHADER object.
+**
+**		gctUINT OptimizationOption
+**			Optimization option.  Can be one of the following:
+**
+**				0						- No optimization.
+**				1						- Full optimization.
+**				Other value				- For optimizer testing.
+**
+**	OUTPUT:
+**
+**		Nothing.
+*/
+gceSTATUS
+gcSHADER_SetOptimizationOption(
+	IN gcSHADER Shader,
+	IN gctUINT OptimizationOption
+	);
+
+/*******************************************************************************
+**  gcSHADER_ReallocateFunctions
+**
+**  Reallocate an array of pointers to gcFUNCTION objects.
+**
+**  INPUT:
+**
+**      gcSHADER Shader
+**          Pointer to a gcSHADER object.
+**
+**      gctSIZE_T Count
+**          Array count to reallocate.  'Count' must be at least 1.
+*/
+gceSTATUS
+gcSHADER_ReallocateFunctions(
+    IN gcSHADER Shader,
+    IN gctSIZE_T Count
+    );
+
+gceSTATUS
+gcSHADER_AddFunction(
+	IN gcSHADER Shader,
+	IN gctCONST_STRING Name,
+	OUT gcFUNCTION * Function
+	);
+
+gceSTATUS
+gcSHADER_ReallocateKernelFunctions(
+    IN gcSHADER Shader,
+    IN gctSIZE_T Count
+    );
+
+gceSTATUS
+gcSHADER_AddKernelFunction(
+	IN gcSHADER Shader,
+	IN gctCONST_STRING Name,
+	OUT gcKERNEL_FUNCTION * KernelFunction
+	);
+
+gceSTATUS
+gcSHADER_BeginFunction(
+	IN gcSHADER Shader,
+	IN gcFUNCTION Function
+	);
+
+gceSTATUS
+gcSHADER_EndFunction(
+	IN gcSHADER Shader,
+	IN gcFUNCTION Function
+	);
+
+gceSTATUS
+gcSHADER_BeginKernelFunction(
+	IN gcSHADER Shader,
+	IN gcKERNEL_FUNCTION KernelFunction
+	);
+
+gceSTATUS
+gcSHADER_EndKernelFunction(
+	IN gcSHADER Shader,
+	IN gcKERNEL_FUNCTION KernelFunction,
+	IN gctSIZE_T LocalMemorySize
+	);
+
+gceSTATUS
+gcSHADER_SetMaxKernelFunctionArgs(
+    IN gcSHADER Shader,
+    IN gctUINT32 MaxKernelFunctionArgs
+    );
+
+/*******************************************************************************
+**  gcSHADER_SetConstantMemorySize
+**
+**  Set the constant memory address space size of a gcSHADER object.
+**
+**  INPUT:
+**
+**      gcSHADER Shader
+**          Pointer to a gcSHADER object.
+**
+**      gctSIZE_T ConstantMemorySize
+**          Constant memory size in bytes
+**
+**      gctCHAR *ConstantMemoryBuffer
+**          Constant memory buffer
+*/
+gceSTATUS
+gcSHADER_SetConstantMemorySize(
+    IN gcSHADER Shader,
+    IN gctSIZE_T ConstantMemorySize,
+    IN gctCHAR * ConstantMemoryBuffer
+    );
+
+/*******************************************************************************
+**  gcSHADER_GetConstantMemorySize
+**
+**  Set the constant memory address space size of a gcSHADER object.
+**
+**  INPUT:
+**
+**      gcSHADER Shader
+**          Pointer to a gcSHADER object.
+**
+**  OUTPUT:
+**
+**      gctSIZE_T * ConstantMemorySize
+**          Pointer to a variable receiving constant memory size in bytes
+**
+**      gctCHAR **ConstantMemoryBuffer.
+**          Pointer to a variable for returned shader constant memory buffer.
+*/
+gceSTATUS
+gcSHADER_GetConstantMemorySize(
+    IN gcSHADER Shader,
+    OUT gctSIZE_T * ConstantMemorySize,
+    OUT gctCHAR ** ConstantMemoryBuffer
+    );
+
+/*******************************************************************************
+**  gcSHADER_SetPrivateMemorySize
+**
+**  Set the private memory address space size of a gcSHADER object.
+**
+**  INPUT:
+**
+**      gcSHADER Shader
+**          Pointer to a gcSHADER object.
+**
+**      gctSIZE_T PrivateMemorySize
+**          Private memory size in bytes
+*/
+gceSTATUS
+gcSHADER_SetPrivateMemorySize(
+    IN gcSHADER Shader,
+    IN gctSIZE_T PrivateMemorySize
+    );
+
+/*******************************************************************************
+**  gcSHADER_GetPrivateMemorySize
+**
+**  Set the private memory address space size of a gcSHADER object.
+**
+**  INPUT:
+**
+**      gcSHADER Shader
+**          Pointer to a gcSHADER object.
+**
+**  OUTPUT:
+**
+**      gctSIZE_T * PrivateMemorySize
+**          Pointer to a variable receiving private memory size in bytes
+*/
+gceSTATUS
+gcSHADER_GetPrivateMemorySize(
+    IN gcSHADER Shader,
+    OUT gctSIZE_T * PrivateMemorySize
+    );
+
+/*******************************************************************************
+**  gcSHADER_SetLocalMemorySize
+**
+**  Set the local memory address space size of a gcSHADER object.
+**
+**  INPUT:
+**
+**      gcSHADER Shader
+**          Pointer to a gcSHADER object.
+**
+**      gctSIZE_T LocalMemorySize
+**          Local memory size in bytes
+*/
+gceSTATUS
+gcSHADER_SetLocalMemorySize(
+    IN gcSHADER Shader,
+    IN gctSIZE_T LocalMemorySize
+    );
+
+/*******************************************************************************
+**  gcSHADER_GetLocalMemorySize
+**
+**  Set the local memory address space size of a gcSHADER object.
+**
+**  INPUT:
+**
+**      gcSHADER Shader
+**          Pointer to a gcSHADER object.
+**
+**  OUTPUT:
+**
+**      gctSIZE_T * LocalMemorySize
+**          Pointer to a variable receiving lcoal memory size in bytes
+*/
+gceSTATUS
+gcSHADER_GetLocalMemorySize(
+    IN gcSHADER Shader,
+    OUT gctSIZE_T * LocalMemorySize
+    );
+
+
+/*******************************************************************************
+**  gcSHADER_CheckValidity
+**
+**  Check validity for a gcSHADER object.
+**
+**  INPUT:
+**
+**      gcSHADER Shader
+**          Pointer to a gcSHADER object.
+**
+*/
+gceSTATUS
+gcSHADER_CheckValidity(
+    IN gcSHADER Shader
+    );
+
+/*******************************************************************************
+**                             gcATTRIBUTE_GetType
+********************************************************************************
+**
+**	Get the type and array length of a gcATTRIBUTE object.
+**
+**	INPUT:
+**
+**		gcATTRIBUTE Attribute
+**			Pointer to a gcATTRIBUTE object.
+**
+**	OUTPUT:
+**
+**		gcSHADER_TYPE * Type
+**			Pointer to a variable receiving the type of the attribute.  'Type'
+**			can be gcvNULL, in which case no type will be returned.
+**
+**		gctSIZE_T * ArrayLength
+**			Pointer to a variable receiving the length of the array if the
+**			attribute was declared as an array.  If the attribute was not
+**			declared as an array, the array length will be 1.  'ArrayLength' can
+**			be gcvNULL, in which case no array length will be returned.
+*/
+gceSTATUS
+gcATTRIBUTE_GetType(
+	IN gcATTRIBUTE Attribute,
+	OUT gcSHADER_TYPE * Type,
+	OUT gctSIZE_T * ArrayLength
+	);
+
+/*******************************************************************************
+**                            gcATTRIBUTE_GetName
+********************************************************************************
+**
+**	Get the name of a gcATTRIBUTE object.
+**
+**	INPUT:
+**
+**		gcATTRIBUTE Attribute
+**			Pointer to a gcATTRIBUTE object.
+**
+**	OUTPUT:
+**
+**		gctSIZE_T * Length
+**			Pointer to a variable receiving the length of the attribute name.
+**			'Length' can be gcvNULL, in which case no length will be returned.
+**
+**		gctCONST_STRING * Name
+**			Pointer to a variable receiving the pointer to the attribute name.
+**			'Name' can be gcvNULL, in which case no name will be returned.
+*/
+gceSTATUS
+gcATTRIBUTE_GetName(
+	IN gcATTRIBUTE Attribute,
+	OUT gctSIZE_T * Length,
+	OUT gctCONST_STRING * Name
+	);
+
+/*******************************************************************************
+**                            gcATTRIBUTE_IsEnabled
+********************************************************************************
+**
+**	Query the enabled state of a gcATTRIBUTE object.
+**
+**	INPUT:
+**
+**		gcATTRIBUTE Attribute
+**			Pointer to a gcATTRIBUTE object.
+**
+**	OUTPUT:
+**
+**		gctBOOL * Enabled
+**			Pointer to a variable receiving the enabled state of the attribute.
+*/
+gceSTATUS
+gcATTRIBUTE_IsEnabled(
+	IN gcATTRIBUTE Attribute,
+	OUT gctBOOL * Enabled
+	);
+
+/*******************************************************************************
+**                              gcUNIFORM_GetType
+********************************************************************************
+**
+**	Get the type and array length of a gcUNIFORM object.
+**
+**	INPUT:
+**
+**		gcUNIFORM Uniform
+**			Pointer to a gcUNIFORM object.
+**
+**	OUTPUT:
+**
+**		gcSHADER_TYPE * Type
+**			Pointer to a variable receiving the type of the uniform.  'Type' can
+**			be gcvNULL, in which case no type will be returned.
+**
+**		gctSIZE_T * ArrayLength
+**			Pointer to a variable receiving the length of the array if the
+**			uniform was declared as an array.  If the uniform was not declared
+**			as an array, the array length will be 1.  'ArrayLength' can be gcvNULL,
+**			in which case no array length will be returned.
+*/
+gceSTATUS
+gcUNIFORM_GetType(
+	IN gcUNIFORM Uniform,
+	OUT gcSHADER_TYPE * Type,
+	OUT gctSIZE_T * ArrayLength
+	);
+
+/*******************************************************************************
+**                              gcUNIFORM_GetTypeEx
+********************************************************************************
+**
+**	Get the type and array length of a gcUNIFORM object.
+**
+**	INPUT:
+**
+**		gcUNIFORM Uniform
+**			Pointer to a gcUNIFORM object.
+**
+**	OUTPUT:
+**
+**		gcSHADER_TYPE * Type
+**			Pointer to a variable receiving the type of the uniform.  'Type' can
+**			be gcvNULL, in which case no type will be returned.
+**
+**		gcSHADER_PRECISION * Precision
+**			Pointer to a variable receiving the precision of the uniform.  'Precision' can
+**			be gcvNULL, in which case no type will be returned.
+**
+**		gctSIZE_T * ArrayLength
+**			Pointer to a variable receiving the length of the array if the
+**			uniform was declared as an array.  If the uniform was not declared
+**			as an array, the array length will be 1.  'ArrayLength' can be gcvNULL,
+**			in which case no array length will be returned.
+*/
+gceSTATUS
+gcUNIFORM_GetTypeEx(
+	IN gcUNIFORM Uniform,
+	OUT gcSHADER_TYPE * Type,
+    OUT gcSHADER_PRECISION * Precision,
+	OUT gctSIZE_T * ArrayLength
+	);
+
+/*******************************************************************************
+**                              gcUNIFORM_GetFlags
+********************************************************************************
+**
+**	Get the flags of a gcUNIFORM object.
+**
+**	INPUT:
+**
+**		gcUNIFORM Uniform
+**			Pointer to a gcUNIFORM object.
+**
+**	OUTPUT:
+**
+**		gceUNIFORM_FLAGS * Flags
+**			Pointer to a variable receiving the flags of the uniform.
+**
+*/
+gceSTATUS
+gcUNIFORM_GetFlags(
+	IN gcUNIFORM Uniform,
+	OUT gceUNIFORM_FLAGS * Flags
+	);
+
+/*******************************************************************************
+**                              gcUNIFORM_SetFlags
+********************************************************************************
+**
+**	Set the flags of a gcUNIFORM object.
+**
+**	INPUT:
+**
+**		gcUNIFORM Uniform
+**			Pointer to a gcUNIFORM object.
+**
+**		gceUNIFORM_FLAGS Flags
+**			Flags of the uniform to be set.
+**
+**	OUTPUT:
+**			Nothing.
+**
+*/
+gceSTATUS
+gcUNIFORM_SetFlags(
+	IN gcUNIFORM Uniform,
+	IN gceUNIFORM_FLAGS Flags
+	);
+
+/*******************************************************************************
+**                              gcUNIFORM_GetName
+********************************************************************************
+**
+**	Get the name of a gcUNIFORM object.
+**
+**	INPUT:
+**
+**		gcUNIFORM Uniform
+**			Pointer to a gcUNIFORM object.
+**
+**	OUTPUT:
+**
+**		gctSIZE_T * Length
+**			Pointer to a variable receiving the length of the uniform name.
+**			'Length' can be gcvNULL, in which case no length will be returned.
+**
+**		gctCONST_STRING * Name
+**			Pointer to a variable receiving the pointer to the uniform name.
+**			'Name' can be gcvNULL, in which case no name will be returned.
+*/
+gceSTATUS
+gcUNIFORM_GetName(
+	IN gcUNIFORM Uniform,
+	OUT gctSIZE_T * Length,
+	OUT gctCONST_STRING * Name
+	);
+
+/*******************************************************************************
+**                              gcUNIFORM_GetSampler
+********************************************************************************
+**
+**	Get the physical sampler number for a sampler gcUNIFORM object.
+**
+**	INPUT:
+**
+**		gcUNIFORM Uniform
+**			Pointer to a gcUNIFORM object.
+**
+**	OUTPUT:
+**
+**		gctUINT32 * Sampler
+**			Pointer to a variable receiving the physical sampler.
+*/
+gceSTATUS
+gcUNIFORM_GetSampler(
+	IN gcUNIFORM Uniform,
+	OUT gctUINT32 * Sampler
+	);
+
+/*******************************************************************************
+**  gcUNIFORM_GetFormat
+**
+**  Get the type and array length of a gcUNIFORM object.
+**
+**  INPUT:
+**
+**      gcUNIFORM Uniform
+**          Pointer to a gcUNIFORM object.
+**
+**  OUTPUT:
+**
+**      gcSL_FORMAT * Format
+**          Pointer to a variable receiving the format of element of the uniform.
+**          'Type' can be gcvNULL, in which case no type will be returned.
+**
+**      gctBOOL * IsPointer
+**          Pointer to a variable receiving the state wheter the uniform is a pointer.
+**          'IsPointer' can be gcvNULL, in which case no array length will be returned.
+*/
+gceSTATUS
+gcUNIFORM_GetFormat(
+    IN gcUNIFORM Uniform,
+    OUT gcSL_FORMAT * Format,
+    OUT gctBOOL * IsPointer
+    );
+
+/*******************************************************************************
+**  gcUNIFORM_SetFormat
+**
+**  Set the format and isPointer of a uniform.
+**
+**  INPUT:
+**
+**      gcUNIFORM Uniform
+**          Pointer to a gcUNIFORM object.
+**
+**      gcSL_FORMAT Format
+**          Format of element of the uniform shaderType.
+**
+**      gctBOOL IsPointer
+**          Wheter the uniform is a pointer.
+**
+**  OUTPUT:
+**
+**      Nothing.
+*/
+gceSTATUS
+gcUNIFORM_SetFormat(
+    IN gcUNIFORM Uniform,
+    IN gcSL_FORMAT Format,
+    IN gctBOOL IsPointer
+    );
+
+/*******************************************************************************
+**							   gcUNIFORM_SetValue
+********************************************************************************
+**
+**	Set the value of a uniform in integer.
+**
+**	INPUT:
+**
+**		gcUNIFORM Uniform
+**			Pointer to a gcUNIFORM object.
+**
+**		gctSIZE_T Count
+**			Number of entries to program if the uniform has been declared as an
+**			array.
+**
+**		const gctINT * Value
+**			Pointer to a buffer holding the integer values for the uniform.
+**
+**	OUTPUT:
+**
+**		Nothing.
+*/
+gceSTATUS
+gcUNIFORM_SetValue(
+	IN gcUNIFORM Uniform,
+	IN gctSIZE_T Count,
+	IN const gctINT * Value
+	);
+
+/*******************************************************************************
+**							   gcUNIFORM_SetValueX
+********************************************************************************
+**
+**	Set the value of a uniform in fixed point.
+**
+**	INPUT:
+**
+**		gcUNIFORM Uniform
+**			Pointer to a gcUNIFORM object.
+**
+**		gctSIZE_T Count
+**			Number of entries to program if the uniform has been declared as an
+**			array.
+**
+**		const gctFIXED_POINT * Value
+**			Pointer to a buffer holding the fixed point values for the uniform.
+**
+**	OUTPUT:
+**
+**		Nothing.
+*/
+gceSTATUS
+gcUNIFORM_SetValueX(
+	IN gcUNIFORM Uniform,
+	IN gctSIZE_T Count,
+	IN gctFIXED_POINT * Value
+	);
+
+/*******************************************************************************
+**							   gcUNIFORM_SetValueF
+********************************************************************************
+**
+**	Set the value of a uniform in floating point.
+**
+**	INPUT:
+**
+**		gcUNIFORM Uniform
+**			Pointer to a gcUNIFORM object.
+**
+**		gctSIZE_T Count
+**			Number of entries to program if the uniform has been declared as an
+**			array.
+**
+**		const gctFLOAT * Value
+**			Pointer to a buffer holding the floating point values for the
+**			uniform.
+**
+**	OUTPUT:
+**
+**		Nothing.
+*/
+gceSTATUS
+gcUNIFORM_SetValueF(
+	IN gcUNIFORM Uniform,
+	IN gctSIZE_T Count,
+	IN const gctFLOAT * Value
+	);
+
+/*******************************************************************************
+**								gcOUTPUT_GetType
+********************************************************************************
+**
+**	Get the type and array length of a gcOUTPUT object.
+**
+**	INPUT:
+**
+**		gcOUTPUT Output
+**			Pointer to a gcOUTPUT object.
+**
+**	OUTPUT:
+**
+**		gcSHADER_TYPE * Type
+**			Pointer to a variable receiving the type of the output.  'Type' can
+**			be gcvNULL, in which case no type will be returned.
+**
+**		gctSIZE_T * ArrayLength
+**			Pointer to a variable receiving the length of the array if the
+**			output was declared as an array.  If the output was not declared
+**			as an array, the array length will be 1.  'ArrayLength' can be gcvNULL,
+**			in which case no array length will be returned.
+*/
+gceSTATUS
+gcOUTPUT_GetType(
+	IN gcOUTPUT Output,
+	OUT gcSHADER_TYPE * Type,
+	OUT gctSIZE_T * ArrayLength
+	);
+
+/*******************************************************************************
+**							   gcOUTPUT_GetIndex
+********************************************************************************
+**
+**	Get the index of a gcOUTPUT object.
+**
+**	INPUT:
+**
+**		gcOUTPUT Output
+**			Pointer to a gcOUTPUT object.
+**
+**	OUTPUT:
+**
+**		gctUINT * Index
+**			Pointer to a variable receiving the temporary register index of the
+**			output.  'Index' can be gcvNULL,. in which case no index will be
+**			returned.
+*/
+gceSTATUS
+gcOUTPUT_GetIndex(
+	IN gcOUTPUT Output,
+	OUT gctUINT * Index
+	);
+
+/*******************************************************************************
+**								gcOUTPUT_GetName
+********************************************************************************
+**
+**	Get the name of a gcOUTPUT object.
+**
+**	INPUT:
+**
+**		gcOUTPUT Output
+**			Pointer to a gcOUTPUT object.
+**
+**	OUTPUT:
+**
+**		gctSIZE_T * Length
+**			Pointer to a variable receiving the length of the output name.
+**			'Length' can be gcvNULL, in which case no length will be returned.
+**
+**		gctCONST_STRING * Name
+**			Pointer to a variable receiving the pointer to the output name.
+**			'Name' can be gcvNULL, in which case no name will be returned.
+*/
+gceSTATUS
+gcOUTPUT_GetName(
+	IN gcOUTPUT Output,
+	OUT gctSIZE_T * Length,
+	OUT gctCONST_STRING * Name
+	);
+
+/*******************************************************************************
+*********************************************************** F U N C T I O N S **
+*******************************************************************************/
+
+/*******************************************************************************
+**  gcFUNCTION_ReallocateArguments
+**
+**  Reallocate an array of gcsFUNCTION_ARGUMENT objects.
+**
+**  INPUT:
+**
+**      gcFUNCTION Function
+**          Pointer to a gcFUNCTION object.
+**
+**      gctSIZE_T Count
+**          Array count to reallocate.  'Count' must be at least 1.
+*/
+gceSTATUS
+gcFUNCTION_ReallocateArguments(
+    IN gcFUNCTION Function,
+    IN gctSIZE_T Count
+    );
+
+gceSTATUS
+gcFUNCTION_AddArgument(
+	IN gcFUNCTION Function,
+	IN gctUINT16 TempIndex,
+	IN gctUINT8 Enable,
+	IN gctUINT8 Qualifier
+	);
+
+gceSTATUS
+gcFUNCTION_GetArgument(
+	IN gcFUNCTION Function,
+	IN gctUINT16 Index,
+	OUT gctUINT16_PTR Temp,
+	OUT gctUINT8_PTR Enable,
+	OUT gctUINT8_PTR Swizzle
+	);
+
+gceSTATUS
+gcFUNCTION_GetLabel(
+	IN gcFUNCTION Function,
+	OUT gctUINT_PTR Label
+	);
+
+/*******************************************************************************
+************************* K E R N E L    P R O P E R T Y    F U N C T I O N S **
+*******************************************************************************/
+/*******************************************************************************/
+gceSTATUS
+gcKERNEL_FUNCTION_AddKernelFunctionProperties(
+	    IN gcKERNEL_FUNCTION KernelFunction,
+		IN gctINT propertyType,
+		IN gctSIZE_T propertySize,
+		IN gctINT * values
+		);
+
+gceSTATUS
+gcKERNEL_FUNCTION_GetPropertyCount(
+    IN gcKERNEL_FUNCTION KernelFunction,
+    OUT gctSIZE_T * Count
+    );
+
+gceSTATUS
+gcKERNEL_FUNCTION_GetProperty(
+    IN gcKERNEL_FUNCTION KernelFunction,
+    IN gctUINT Index,
+	OUT gctSIZE_T * propertySize,
+	OUT gctINT * propertyType,
+	OUT gctINT * propertyValues
+    );
+
+
+/*******************************************************************************
+*******************************I M A G E   S A M P L E R    F U N C T I O N S **
+*******************************************************************************/
+/*******************************************************************************
+**  gcKERNEL_FUNCTION_ReallocateImageSamplers
+**
+**  Reallocate an array of pointers to image sampler pair.
+**
+**  INPUT:
+**
+**      gcKERNEL_FUNCTION KernelFunction
+**          Pointer to a gcKERNEL_FUNCTION object.
+**
+**      gctSIZE_T Count
+**          Array count to reallocate.  'Count' must be at least 1.
+*/
+gceSTATUS
+gcKERNEL_FUNCTION_ReallocateImageSamplers(
+    IN gcKERNEL_FUNCTION KernelFunction,
+    IN gctSIZE_T Count
+    );
+
+gceSTATUS
+gcKERNEL_FUNCTION_AddImageSampler(
+    IN gcKERNEL_FUNCTION KernelFunction,
+    IN gctUINT8 ImageNum,
+    IN gctBOOL IsConstantSamplerType,
+    IN gctUINT32 SamplerType
+    );
+
+gceSTATUS
+gcKERNEL_FUNCTION_GetImageSamplerCount(
+    IN gcKERNEL_FUNCTION KernelFunction,
+    OUT gctSIZE_T * Count
+    );
+
+gceSTATUS
+gcKERNEL_FUNCTION_GetImageSampler(
+    IN gcKERNEL_FUNCTION KernelFunction,
+    IN gctUINT Index,
+    OUT gctUINT8 *ImageNum,
+    OUT gctBOOL *IsConstantSamplerType,
+    OUT gctUINT32 *SamplerType
+    );
+
+/*******************************************************************************
+*********************************************K E R N E L    F U N C T I O N S **
+*******************************************************************************/
+
+/*******************************************************************************
+**  gcKERNEL_FUNCTION_ReallocateArguments
+**
+**  Reallocate an array of gcsFUNCTION_ARGUMENT objects.
+**
+**  INPUT:
+**
+**      gcKERNEL_FUNCTION Function
+**          Pointer to a gcKERNEL_FUNCTION object.
+**
+**      gctSIZE_T Count
+**          Array count to reallocate.  'Count' must be at least 1.
+*/
+gceSTATUS
+gcKERNEL_FUNCTION_ReallocateArguments(
+    IN gcKERNEL_FUNCTION Function,
+    IN gctSIZE_T Count
+    );
+
+gceSTATUS
+gcKERNEL_FUNCTION_AddArgument(
+	IN gcKERNEL_FUNCTION Function,
+	IN gctUINT16 TempIndex,
+	IN gctUINT8 Enable,
+	IN gctUINT8 Qualifier
+	);
+
+gceSTATUS
+gcKERNEL_FUNCTION_GetArgument(
+	IN gcKERNEL_FUNCTION Function,
+	IN gctUINT16 Index,
+	OUT gctUINT16_PTR Temp,
+	OUT gctUINT8_PTR Enable,
+	OUT gctUINT8_PTR Swizzle
+	);
+
+gceSTATUS
+gcKERNEL_FUNCTION_GetLabel(
+	IN gcKERNEL_FUNCTION Function,
+	OUT gctUINT_PTR Label
+	);
+
+gceSTATUS
+gcKERNEL_FUNCTION_GetName(
+    IN gcKERNEL_FUNCTION KernelFunction,
+    OUT gctSIZE_T * Length,
+    OUT gctCONST_STRING * Name
+    );
+
+gceSTATUS
+gcKERNEL_FUNCTION_ReallocateUniformArguments(
+    IN gcKERNEL_FUNCTION KernelFunction,
+    IN gctSIZE_T Count
+    );
+
+gceSTATUS
+gcKERNEL_FUNCTION_AddUniformArgument(
+    IN gcKERNEL_FUNCTION KernelFunction,
+    IN gctCONST_STRING Name,
+    IN gcSHADER_TYPE Type,
+    IN gctSIZE_T Length,
+    OUT gcUNIFORM * UniformArgument
+    );
+
+gceSTATUS
+gcKERNEL_FUNCTION_GetUniformArgumentCount(
+    IN gcKERNEL_FUNCTION KernelFunction,
+    OUT gctSIZE_T * Count
+    );
+
+gceSTATUS
+gcKERNEL_FUNCTION_GetUniformArgument(
+    IN gcKERNEL_FUNCTION KernelFunction,
+    IN gctUINT Index,
+    OUT gcUNIFORM * UniformArgument
+    );
+
+gceSTATUS
+gcKERNEL_FUNCTION_SetCodeEnd(
+    IN gcKERNEL_FUNCTION KernelFunction
+    );
+
+/*******************************************************************************
+**                              gcCompileShader
+********************************************************************************
+**
+**	Compile a shader.
+**
+**	INPUT:
+**
+**		gcoOS Hal
+**			Pointer to an gcoHAL object.
+**
+**		gctINT ShaderType
+**			Shader type to compile.  Can be one of the following values:
+**
+**				gcSHADER_TYPE_VERTEX
+**					Compile a vertex shader.
+**
+**				gcSHADER_TYPE_FRAGMENT
+**					Compile a fragment shader.
+**
+**		gctSIZE_T SourceSize
+**			Size of the source buffer in bytes.
+**
+**		gctCONST_STRING Source
+**			Pointer to the buffer containing the shader source code.
+**
+**	OUTPUT:
+**
+**		gcSHADER * Binary
+**			Pointer to a variable receiving the pointer to a gcSHADER object
+**			containg the compiled shader code.
+**
+**		gctSTRING * Log
+**			Pointer to a variable receiving a string pointer containging the
+**			compile log.
+*/
+gceSTATUS
+gcCompileShader(
+	IN gcoHAL Hal,
+	IN gctINT ShaderType,
+	IN gctSIZE_T SourceSize,
+	IN gctCONST_STRING Source,
+	OUT gcSHADER * Binary,
+	OUT gctSTRING * Log
+	);
+
+/*******************************************************************************
+**                              gcOptimizeShader
+********************************************************************************
+**
+**	Optimize a shader.
+**
+**	INPUT:
+**
+**		gcSHADER Shader
+**			Pointer to a gcSHADER object holding information about the compiled
+**			shader.
+**
+**		gctFILE LogFile
+**			Pointer to an open FILE object.
+*/
+gceSTATUS
+gcOptimizeShader(
+	IN gcSHADER Shader,
+	IN gctFILE LogFile
+	);
+
+/*******************************************************************************
+**                                gcLinkShaders
+********************************************************************************
+**
+**	Link two shaders and generate a harwdare specific state buffer by compiling
+**	the compiler generated code through the resource allocator and code
+**	generator.
+**
+**	INPUT:
+**
+**		gcSHADER VertexShader
+**			Pointer to a gcSHADER object holding information about the compiled
+**			vertex shader.
+**
+**		gcSHADER FragmentShader
+**			Pointer to a gcSHADER object holding information about the compiled
+**			fragment shader.
+**
+**		gceSHADER_FLAGS Flags
+**			Compiler flags.  Can be any of the following:
+**
+**				gcvSHADER_DEAD_CODE       - Dead code elimination.
+**				gcvSHADER_RESOURCE_USAGE  - Resource usage optimizaion.
+**				gcvSHADER_OPTIMIZER       - Full optimization.
+**				gcvSHADER_USE_GL_Z        - Use OpenGL ES Z coordinate.
+**				gcvSHADER_USE_GL_POSITION - Use OpenGL ES gl_Position.
+**				gcvSHADER_USE_GL_FACE     - Use OpenGL ES gl_FaceForward.
+**
+**	OUTPUT:
+**
+**		gctSIZE_T * StateBufferSize
+**			Pointer to a variable receicing the number of bytes in the buffer
+**			returned in 'StateBuffer'.
+**
+**		gctPOINTER * StateBuffer
+**			Pointer to a variable receiving a buffer pointer that contains the
+**			states required to download the shaders into the hardware.
+**
+**		gcsHINT_PTR * Hints
+**			Pointer to a variable receiving a gcsHINT structure pointer that
+**			contains information required when loading the shader states.
+*/
+gceSTATUS
+gcLinkShaders(
+	IN gcSHADER VertexShader,
+	IN gcSHADER FragmentShader,
+	IN gceSHADER_FLAGS Flags,
+	OUT gctSIZE_T * StateBufferSize,
+	OUT gctPOINTER * StateBuffer,
+	OUT gcsHINT_PTR * Hints
+	);
+
+/*******************************************************************************
+**                                gcLoadShaders
+********************************************************************************
+**
+**	Load a pre-compiled and pre-linked shader program into the hardware.
+**
+**	INPUT:
+**
+**		gcoHAL Hal
+**			Pointer to a gcoHAL object.
+**
+**		gctSIZE_T StateBufferSize
+**			The number of bytes in the 'StateBuffer'.
+**
+**		gctPOINTER StateBuffer
+**			Pointer to the states that make up the shader program.
+**
+**		gcsHINT_PTR Hints
+**			Pointer to a gcsHINT structure that contains information required
+**			when loading the shader states.
+*/
+gceSTATUS
+gcLoadShaders(
+	IN gcoHAL Hal,
+	IN gctSIZE_T StateBufferSize,
+	IN gctPOINTER StateBuffer,
+	IN gcsHINT_PTR Hints
+	);
+
+/*******************************************************************************
+**                                gcSaveProgram
+********************************************************************************
+**
+**	Save pre-compiled shaders and pre-linked programs to a binary file.
+**
+**	INPUT:
+**
+**		gcSHADER VertexShader
+**			Pointer to vertex shader object.
+**
+**		gcSHADER FragmentShader
+**			Pointer to fragment shader object.
+**
+**		gctSIZE_T ProgramBufferSize
+**			Number of bytes in 'ProgramBuffer'.
+**
+**		gctPOINTER ProgramBuffer
+**			Pointer to buffer containing the program states.
+**
+**		gcsHINT_PTR Hints
+**			Pointer to HINTS structure for program states.
+**
+**	OUTPUT:
+**
+**		gctPOINTER * Binary
+**			Pointer to a variable receiving the binary data to be saved.
+**
+**		gctSIZE_T * BinarySize
+**			Pointer to a variable receiving the number of bytes inside 'Binary'.
+*/
+gceSTATUS
+gcSaveProgram(
+	IN gcSHADER VertexShader,
+	IN gcSHADER FragmentShader,
+	IN gctSIZE_T ProgramBufferSize,
+	IN gctPOINTER ProgramBuffer,
+	IN gcsHINT_PTR Hints,
+	OUT gctPOINTER * Binary,
+	OUT gctSIZE_T * BinarySize
+	);
+
+/*******************************************************************************
+**                                gcLoadProgram
+********************************************************************************
+**
+**	Load pre-compiled shaders and pre-linked programs from a binary file.
+**
+**	INPUT:
+**
+**		gctPOINTER Binary
+**			Pointer to the binary data loaded.
+**
+**		gctSIZE_T BinarySize
+**			Number of bytes in 'Binary'.
+**
+**	OUTPUT:
+**
+**		gcSHADER VertexShader
+**			Pointer to a vertex shader object.
+**
+**		gcSHADER FragmentShader
+**			Pointer to a fragment shader object.
+**
+**		gctSIZE_T * ProgramBufferSize
+**			Pointer to a variable receicing the number of bytes in the buffer
+**			returned in 'ProgramBuffer'.
+**
+**		gctPOINTER * ProgramBuffer
+**			Pointer to a variable receiving a buffer pointer that contains the
+**			states required to download the shaders into the hardware.
+**
+**		gcsHINT_PTR * Hints
+**			Pointer to a variable receiving a gcsHINT structure pointer that
+**			contains information required when loading the shader states.
+*/
+gceSTATUS
+gcLoadProgram(
+	IN gctPOINTER Binary,
+	IN gctSIZE_T BinarySize,
+	OUT gcSHADER VertexShader,
+	OUT gcSHADER FragmentShader,
+	OUT gctSIZE_T * ProgramBufferSize,
+	OUT gctPOINTER * ProgramBuffer,
+	OUT gcsHINT_PTR * Hints
+	);
+
+/*******************************************************************************
+**                              gcCompileKernel
+********************************************************************************
+**
+**	Compile a OpenCL kernel shader.
+**
+**	INPUT:
+**
+**		gcoOS Hal
+**			Pointer to an gcoHAL object.
+**
+**		gctSIZE_T SourceSize
+**			Size of the source buffer in bytes.
+**
+**		gctCONST_STRING Source
+**			Pointer to the buffer containing the shader source code.
+**
+**	OUTPUT:
+**
+**		gcSHADER * Binary
+**			Pointer to a variable receiving the pointer to a gcSHADER object
+**			containg the compiled shader code.
+**
+**		gctSTRING * Log
+**			Pointer to a variable receiving a string pointer containging the
+**			compile log.
+*/
+gceSTATUS
+gcCompileKernel(
+	IN gcoHAL Hal,
+	IN gctSIZE_T SourceSize,
+	IN gctCONST_STRING Source,
+	IN gctCONST_STRING Options,
+	OUT gcSHADER * Binary,
+	OUT gctSTRING * Log
+	);
+
+/*******************************************************************************
+**                                gcLinkKernel
+********************************************************************************
+**
+**	Link OpenCL kernel and generate a harwdare specific state buffer by compiling
+**	the compiler generated code through the resource allocator and code
+**	generator.
+**
+**	INPUT:
+**
+**		gcSHADER Kernel
+**			Pointer to a gcSHADER object holding information about the compiled
+**			OpenCL kernel.
+**
+**		gceSHADER_FLAGS Flags
+**			Compiler flags.  Can be any of the following:
+**
+**				gcvSHADER_DEAD_CODE       - Dead code elimination.
+**				gcvSHADER_RESOURCE_USAGE  - Resource usage optimizaion.
+**				gcvSHADER_OPTIMIZER       - Full optimization.
+**				gcvSHADER_USE_GL_Z        - Use OpenGL ES Z coordinate.
+**				gcvSHADER_USE_GL_POSITION - Use OpenGL ES gl_Position.
+**				gcvSHADER_USE_GL_FACE     - Use OpenGL ES gl_FaceForward.
+**
+**	OUTPUT:
+**
+**		gctSIZE_T * StateBufferSize
+**			Pointer to a variable receiving the number of bytes in the buffer
+**			returned in 'StateBuffer'.
+**
+**		gctPOINTER * StateBuffer
+**			Pointer to a variable receiving a buffer pointer that contains the
+**			states required to download the shaders into the hardware.
+**
+**		gcsHINT_PTR * Hints
+**			Pointer to a variable receiving a gcsHINT structure pointer that
+**			contains information required when loading the shader states.
+*/
+gceSTATUS
+gcLinkKernel(
+	IN gcSHADER Kernel,
+	IN gceSHADER_FLAGS Flags,
+	OUT gctSIZE_T * StateBufferSize,
+	OUT gctPOINTER * StateBuffer,
+	OUT gcsHINT_PTR * Hints
+	);
+
+/*******************************************************************************
+**                                gcLoadKernel
+********************************************************************************
+**
+**  Load a pre-compiled and pre-linked kernel program into the hardware.
+**
+**  INPUT:
+**
+**      gctSIZE_T StateBufferSize
+**          The number of bytes in the 'StateBuffer'.
+**
+**      gctPOINTER StateBuffer
+**          Pointer to the states that make up the shader program.
+**
+**      gcsHINT_PTR Hints
+**          Pointer to a gcsHINT structure that contains information required
+**          when loading the shader states.
+*/
+gceSTATUS
+gcLoadKernel(
+    IN gctSIZE_T StateBufferSize,
+    IN gctPOINTER StateBuffer,
+    IN gcsHINT_PTR Hints
+    );
+
+gceSTATUS
+gcInvokeThreadWalker(
+    IN gcsTHREAD_WALKER_INFO_PTR Info
+    );
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* VIVANTE_NO_3D */
+#endif /* __gc_hal_compiler_h_ */
diff --git a/attic/gc_hal_driver.h b/attic/gc_hal_driver.h
new file mode 100644
index 0000000..7c9d163
--- /dev/null
+++ b/attic/gc_hal_driver.h
@@ -0,0 +1,901 @@
+/****************************************************************************
+*
+*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*
+*    This program is free software; you can redistribute it and/or modify
+*    it under the terms of the GNU General Public License as published by
+*    the Free Software Foundation; either version 2 of the license, or
+*    (at your option) any later version.
+*
+*    This program is distributed in the hope that it will be useful,
+*    but WITHOUT ANY WARRANTY; without even the implied warranty of
+*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+*    GNU General Public License for more details.
+*
+*    You should have received a copy of the GNU General Public License
+*    along with this program; if not write to the Free Software
+*    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*
+*****************************************************************************/
+
+
+
+
+#ifndef __gc_hal_driver_h_
+#define __gc_hal_driver_h_
+
+#include "gc_hal_enum.h"
+#include "gc_hal_types.h"
+
+#if gcdENABLE_VG
+#include "gc_hal_driver_vg.h"
+#endif
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/******************************************************************************\
+******************************* I/O Control Codes ******************************
+\******************************************************************************/
+
+#define gcvHAL_CLASS                    "galcore"
+#define IOCTL_GCHAL_INTERFACE           30000
+#define IOCTL_GCHAL_KERNEL_INTERFACE    30001
+#define IOCTL_GCHAL_TERMINATE           30002
+
+/******************************************************************************\
+********************************* Command Codes ********************************
+\******************************************************************************/
+
+typedef enum _gceHAL_COMMAND_CODES
+{
+    /* Generic query. */
+    gcvHAL_QUERY_VIDEO_MEMORY,
+    gcvHAL_QUERY_CHIP_IDENTITY,
+
+    /* Contiguous memory. */
+    gcvHAL_ALLOCATE_NON_PAGED_MEMORY,
+    gcvHAL_FREE_NON_PAGED_MEMORY,
+    gcvHAL_ALLOCATE_CONTIGUOUS_MEMORY,
+    gcvHAL_FREE_CONTIGUOUS_MEMORY,
+
+    /* Video memory allocation. */
+    gcvHAL_ALLOCATE_VIDEO_MEMORY,           /* Enforced alignment. */
+    gcvHAL_ALLOCATE_LINEAR_VIDEO_MEMORY,    /* No alignment. */
+    gcvHAL_FREE_VIDEO_MEMORY,
+
+    /* Physical-to-logical mapping. */
+    gcvHAL_MAP_MEMORY,
+    gcvHAL_UNMAP_MEMORY,
+
+    /* Logical-to-physical mapping. */
+    gcvHAL_MAP_USER_MEMORY,
+    gcvHAL_UNMAP_USER_MEMORY,
+
+    /* Surface lock/unlock. */
+    gcvHAL_LOCK_VIDEO_MEMORY,
+    gcvHAL_UNLOCK_VIDEO_MEMORY,
+
+    /* Event queue. */
+    gcvHAL_EVENT_COMMIT,
+
+    gcvHAL_USER_SIGNAL,
+    gcvHAL_SIGNAL,
+    gcvHAL_WRITE_DATA,
+
+    gcvHAL_COMMIT,
+    gcvHAL_STALL,
+
+    gcvHAL_READ_REGISTER,
+    gcvHAL_WRITE_REGISTER,
+
+    gcvHAL_GET_PROFILE_SETTING,
+    gcvHAL_SET_PROFILE_SETTING,
+
+    gcvHAL_READ_ALL_PROFILE_REGISTERS,
+    gcvHAL_PROFILE_REGISTERS_2D,
+
+    /* Power management. */
+    gcvHAL_SET_POWER_MANAGEMENT_STATE,
+    gcvHAL_QUERY_POWER_MANAGEMENT_STATE,
+
+    gcvHAL_GET_BASE_ADDRESS,
+
+    gcvHAL_SET_IDLE, /* reserved */
+
+    /* Queries. */
+    gcvHAL_QUERY_KERNEL_SETTINGS,
+
+    /* Reset. */
+    gcvHAL_RESET,
+
+    /* Map physical address into handle. */
+    gcvHAL_MAP_PHYSICAL,
+
+    /* Debugger stuff. */
+    gcvHAL_DEBUG,
+
+    /* Cache stuff. */
+    gcvHAL_CACHE,
+
+    /* TimeStamp */
+    gcvHAL_TIMESTAMP,
+
+    /* Database. */
+    gcvHAL_DATABASE,
+
+    /* Version. */
+    gcvHAL_VERSION,
+
+    /* Chip info */
+    gcvHAL_CHIP_INFO,
+
+    /* Process attaching/detaching. */
+    gcvHAL_ATTACH,
+    gcvHAL_DETACH,
+
+    /* Composition. */
+    gcvHAL_COMPOSE,
+
+    /* Set timeOut value */
+    gcvHAL_SET_TIMEOUT,
+
+    /* Frame database. */
+    gcvHAL_GET_FRAME_INFO,
+
+    /* Shared info for each process */
+    gcvHAL_GET_SHARED_INFO,
+    gcvHAL_SET_SHARED_INFO,
+    gcvHAL_QUERY_COMMAND_BUFFER,
+
+    gcvHAL_COMMIT_DONE,
+
+    /* GPU and event dump */
+    gcvHAL_DUMP_GPU_STATE,
+    gcvHAL_DUMP_EVENT
+}
+gceHAL_COMMAND_CODES;
+
+/******************************************************************************\
+****************************** Interface Structure *****************************
+\******************************************************************************/
+
+#define gcdMAX_PROFILE_FILE_NAME    128
+
+/* Kernel settings. */
+typedef struct _gcsKERNEL_SETTINGS
+{
+    /* Used RealTime signal between kernel and user. */
+    gctINT signal;
+}
+gcsKERNEL_SETTINGS;
+
+
+/* gcvHAL_QUERY_CHIP_IDENTITY */
+typedef struct _gcsHAL_QUERY_CHIP_IDENTITY * gcsHAL_QUERY_CHIP_IDENTITY_PTR;
+typedef struct _gcsHAL_QUERY_CHIP_IDENTITY
+{
+
+    /* Chip model. */
+    gceCHIPMODEL                chipModel;
+
+    /* Revision value.*/
+    gctUINT32                   chipRevision;
+
+    /* Supported feature fields. */
+    gctUINT32                   chipFeatures;
+
+    /* Supported minor feature fields. */
+    gctUINT32                   chipMinorFeatures;
+
+    /* Supported minor feature 1 fields. */
+    gctUINT32                   chipMinorFeatures1;
+
+    /* Supported minor feature 2 fields. */
+    gctUINT32                   chipMinorFeatures2;
+
+    /* Supported minor feature 3 fields. */
+    gctUINT32                   chipMinorFeatures3;
+
+    /* Number of streams supported. */
+    gctUINT32                   streamCount;
+
+    /* Total number of temporary registers per thread. */
+    gctUINT32                   registerMax;
+
+    /* Maximum number of threads. */
+    gctUINT32                   threadCount;
+
+    /* Number of shader cores. */
+    gctUINT32                   shaderCoreCount;
+
+    /* Size of the vertex cache. */
+    gctUINT32                   vertexCacheSize;
+
+    /* Number of entries in the vertex output buffer. */
+    gctUINT32                   vertexOutputBufferSize;
+
+    /* Number of pixel pipes. */
+    gctUINT32                   pixelPipes;
+
+    /* Number of instructions. */
+	gctUINT32                   instructionCount;
+
+    /* Number of constants. */
+	gctUINT32                   numConstants;
+
+	/* Buffer size */
+	gctUINT32                   bufferSize;
+
+}
+gcsHAL_QUERY_CHIP_IDENTITY;
+
+/* gcvHAL_COMPOSE. */
+typedef struct _gcsHAL_COMPOSE * gcsHAL_COMPOSE_PTR;
+typedef struct _gcsHAL_COMPOSE
+{
+    /* Composition state buffer. */
+    gctPHYS_ADDR                physical;
+    gctPOINTER                  logical;
+    gctSIZE_T                   offset;
+    gctSIZE_T                   size;
+
+    /* Composition end signal. */
+    gctHANDLE                   process;
+    gctSIGNAL                   signal;
+
+    /* User signals. */
+    gctHANDLE                   userProcess;
+    gctSIGNAL                   userSignal1;
+    gctSIGNAL                   userSignal2;
+
+#if defined(__QNXNTO__)
+    /* Client pulse side-channel connection ID. */
+    gctINT32                    coid;
+
+    /* Set by server. */
+    gctINT32                    rcvid;
+#endif
+}
+gcsHAL_COMPOSE;
+
+typedef struct _gcsHAL_INTERFACE
+{
+    /* Command code. */
+    gceHAL_COMMAND_CODES        command;
+
+    /* Hardware type. */
+    gceHARDWARE_TYPE            hardwareType;
+
+    /* Status value. */
+    gceSTATUS                   status;
+
+    /* Handle to this interface channel. */
+    gctHANDLE                   handle;
+
+    /* Pid of the client. */
+    gctUINT32                   pid;
+
+    /* Union of command structures. */
+    union _u
+    {
+        /* gcvHAL_GET_BASE_ADDRESS */
+        struct _gcsHAL_GET_BASE_ADDRESS
+        {
+            /* Physical memory address of internal memory. */
+            OUT gctUINT32               baseAddress;
+        }
+        GetBaseAddress;
+
+        /* gcvHAL_QUERY_VIDEO_MEMORY */
+        struct _gcsHAL_QUERY_VIDEO_MEMORY
+        {
+            /* Physical memory address of internal memory. */
+            OUT gctPHYS_ADDR            internalPhysical;
+
+            /* Size in bytes of internal memory.*/
+            OUT gctSIZE_T               internalSize;
+
+            /* Physical memory address of external memory. */
+            OUT gctPHYS_ADDR            externalPhysical;
+
+            /* Size in bytes of external memory.*/
+            OUT gctSIZE_T               externalSize;
+
+            /* Physical memory address of contiguous memory. */
+            OUT gctPHYS_ADDR            contiguousPhysical;
+
+            /* Size in bytes of contiguous memory.*/
+            OUT gctSIZE_T               contiguousSize;
+        }
+        QueryVideoMemory;
+
+        /* gcvHAL_QUERY_CHIP_IDENTITY */
+        gcsHAL_QUERY_CHIP_IDENTITY      QueryChipIdentity;
+
+        /* gcvHAL_MAP_MEMORY */
+        struct _gcsHAL_MAP_MEMORY
+        {
+            /* Physical memory address to map. */
+            IN gctPHYS_ADDR             physical;
+
+            /* Number of bytes in physical memory to map. */
+            IN gctSIZE_T                bytes;
+
+            /* Address of mapped memory. */
+            OUT gctPOINTER              logical;
+        }
+        MapMemory;
+
+        /* gcvHAL_UNMAP_MEMORY */
+        struct _gcsHAL_UNMAP_MEMORY
+        {
+            /* Physical memory address to unmap. */
+            IN gctPHYS_ADDR             physical;
+
+            /* Number of bytes in physical memory to unmap. */
+            IN gctSIZE_T                bytes;
+
+            /* Address of mapped memory to unmap. */
+            IN gctPOINTER               logical;
+        }
+        UnmapMemory;
+
+        /* gcvHAL_ALLOCATE_LINEAR_VIDEO_MEMORY */
+        struct _gcsHAL_ALLOCATE_LINEAR_VIDEO_MEMORY
+        {
+            /* Number of bytes to allocate. */
+            IN OUT gctUINT              bytes;
+
+            /* Buffer alignment. */
+            IN gctUINT                  alignment;
+
+            /* Type of allocation. */
+            IN gceSURF_TYPE             type;
+
+            /* Memory pool to allocate from. */
+            IN OUT gcePOOL              pool;
+
+            /* Allocated video memory. */
+            OUT gcuVIDMEM_NODE_PTR      node;
+        }
+        AllocateLinearVideoMemory;
+
+        /* gcvHAL_ALLOCATE_VIDEO_MEMORY */
+        struct _gcsHAL_ALLOCATE_VIDEO_MEMORY
+        {
+            /* Width of rectangle to allocate. */
+            IN OUT gctUINT              width;
+
+            /* Height of rectangle to allocate. */
+            IN OUT gctUINT              height;
+
+            /* Depth of rectangle to allocate. */
+            IN gctUINT                  depth;
+
+            /* Format rectangle to allocate in gceSURF_FORMAT. */
+            IN gceSURF_FORMAT           format;
+
+            /* Type of allocation. */
+            IN gceSURF_TYPE             type;
+
+            /* Memory pool to allocate from. */
+            IN OUT gcePOOL              pool;
+
+            /* Allocated video memory. */
+            OUT gcuVIDMEM_NODE_PTR      node;
+        }
+        AllocateVideoMemory;
+
+        /* gcvHAL_FREE_VIDEO_MEMORY */
+        struct _gcsHAL_FREE_VIDEO_MEMORY
+        {
+            /* Allocated video memory. */
+            IN gcuVIDMEM_NODE_PTR       node;
+
+#ifdef __QNXNTO__
+/* TODO: This is part of the unlock - why is it here? */
+            /* Mapped logical address to unmap in user space. */
+            OUT gctPOINTER              memory;
+
+            /* Number of bytes to allocated. */
+            OUT gctSIZE_T               bytes;
+#endif
+        }
+        FreeVideoMemory;
+
+        /* gcvHAL_LOCK_VIDEO_MEMORY */
+        struct _gcsHAL_LOCK_VIDEO_MEMORY
+        {
+            /* Allocated video memory. */
+            IN gcuVIDMEM_NODE_PTR       node;
+
+            /* Cache configuration. */
+            /* Only gcvPOOL_CONTIGUOUS and gcvPOOL_VIRUTAL
+            ** can be configured */
+            IN gctBOOL                  cacheable;
+
+            /* Hardware specific address. */
+            OUT gctUINT32               address;
+
+            /* Mapped logical address. */
+            OUT gctPOINTER              memory;
+        }
+        LockVideoMemory;
+
+        /* gcvHAL_UNLOCK_VIDEO_MEMORY */
+        struct _gcsHAL_UNLOCK_VIDEO_MEMORY
+        {
+            /* Allocated video memory. */
+            IN gcuVIDMEM_NODE_PTR       node;
+
+            /* Type of surface. */
+            IN gceSURF_TYPE             type;
+
+            /* Flag to unlock surface asynchroneously. */
+            IN OUT gctBOOL              asynchroneous;
+        }
+        UnlockVideoMemory;
+
+        /* gcvHAL_ALLOCATE_NON_PAGED_MEMORY */
+        struct _gcsHAL_ALLOCATE_NON_PAGED_MEMORY
+        {
+            /* Number of bytes to allocate. */
+            IN OUT gctSIZE_T            bytes;
+
+            /* Physical address of allocation. */
+            OUT gctPHYS_ADDR            physical;
+
+            /* Logical address of allocation. */
+            OUT gctPOINTER              logical;
+        }
+        AllocateNonPagedMemory;
+
+        /* gcvHAL_FREE_NON_PAGED_MEMORY */
+        struct _gcsHAL_FREE_NON_PAGED_MEMORY
+        {
+            /* Number of bytes allocated. */
+            IN gctSIZE_T                bytes;
+
+            /* Physical address of allocation. */
+            IN gctPHYS_ADDR             physical;
+
+            /* Logical address of allocation. */
+            IN gctPOINTER               logical;
+        }
+        FreeNonPagedMemory;
+
+        /* gcvHAL_EVENT_COMMIT. */
+        struct _gcsHAL_EVENT_COMMIT
+        {
+            /* Event queue. */
+            IN gcsQUEUE_PTR             queue;
+        }
+        Event;
+
+        /* gcvHAL_COMMIT */
+        struct _gcsHAL_COMMIT
+        {
+            /* Context buffer object. */
+            IN gckCONTEXT               context;
+
+            /* Command buffer. */
+            IN gcoCMDBUF                commandBuffer;
+
+            /* State delta buffer. */
+            gcsSTATE_DELTA_PTR          delta;
+
+            /* Event queue. */
+            IN gcsQUEUE_PTR             queue;
+        }
+        Commit;
+
+        /* gcvHAL_MAP_USER_MEMORY */
+        struct _gcsHAL_MAP_USER_MEMORY
+        {
+            /* Base address of user memory to map. */
+            IN gctPOINTER               memory;
+
+            /* Size of user memory in bytes to map. */
+            IN gctSIZE_T                size;
+
+            /* Info record required by gcvHAL_UNMAP_USER_MEMORY. */
+            OUT gctPOINTER              info;
+
+            /* Physical address of mapped memory. */
+            OUT gctUINT32               address;
+        }
+        MapUserMemory;
+
+        /* gcvHAL_UNMAP_USER_MEMORY */
+        struct _gcsHAL_UNMAP_USER_MEMORY
+        {
+            /* Base address of user memory to unmap. */
+            IN gctPOINTER               memory;
+
+            /* Size of user memory in bytes to unmap. */
+            IN gctSIZE_T                size;
+
+            /* Info record returned by gcvHAL_MAP_USER_MEMORY. */
+            IN gctPOINTER               info;
+
+            /* Physical address of mapped memory as returned by
+               gcvHAL_MAP_USER_MEMORY. */
+            IN gctUINT32                address;
+        }
+        UnmapUserMemory;
+#if !USE_NEW_LINUX_SIGNAL
+        /* gcsHAL_USER_SIGNAL  */
+        struct _gcsHAL_USER_SIGNAL
+        {
+            /* Command. */
+            gceUSER_SIGNAL_COMMAND_CODES command;
+
+            /* Signal ID. */
+            IN OUT gctINT               id;
+
+            /* Reset mode. */
+            IN gctBOOL                  manualReset;
+
+            /* Wait timedout. */
+            IN gctUINT32                wait;
+
+            /* State. */
+            IN gctBOOL                  state;
+        }
+        UserSignal;
+#endif
+
+        /* gcvHAL_SIGNAL. */
+        struct _gcsHAL_SIGNAL
+        {
+            /* Signal handle to signal. */
+            IN gctSIGNAL                signal;
+
+            /* Reserved. */
+            IN gctSIGNAL                auxSignal;
+
+            /* Process owning the signal. */
+            IN gctHANDLE                process;
+
+#if defined(__QNXNTO__)
+            /* Client pulse side-channel connection ID. Set by client in gcoOS_CreateSignal. */
+            IN gctINT32                 coid;
+
+            /* Set by server. */
+            IN gctINT32                 rcvid;
+#endif
+            /* Event generated from where of pipeline */
+            IN gceKERNEL_WHERE          fromWhere;
+        }
+        Signal;
+
+        /* gcvHAL_WRITE_DATA. */
+        struct _gcsHAL_WRITE_DATA
+        {
+            /* Address to write data to. */
+            IN gctUINT32                address;
+
+            /* Data to write. */
+            IN gctUINT32                data;
+        }
+        WriteData;
+
+        /* gcvHAL_ALLOCATE_CONTIGUOUS_MEMORY */
+        struct _gcsHAL_ALLOCATE_CONTIGUOUS_MEMORY
+        {
+            /* Number of bytes to allocate. */
+            IN OUT gctSIZE_T            bytes;
+
+            /* Hardware address of allocation. */
+            OUT gctUINT32               address;
+
+            /* Physical address of allocation. */
+            OUT gctPHYS_ADDR            physical;
+
+            /* Logical address of allocation. */
+            OUT gctPOINTER              logical;
+        }
+        AllocateContiguousMemory;
+
+        /* gcvHAL_FREE_CONTIGUOUS_MEMORY */
+        struct _gcsHAL_FREE_CONTIGUOUS_MEMORY
+        {
+            /* Number of bytes allocated. */
+            IN gctSIZE_T                bytes;
+
+            /* Physical address of allocation. */
+            IN gctPHYS_ADDR             physical;
+
+            /* Logical address of allocation. */
+            IN gctPOINTER               logical;
+        }
+        FreeContiguousMemory;
+
+        /* gcvHAL_READ_REGISTER */
+        struct _gcsHAL_READ_REGISTER
+        {
+            /* Logical address of memory to write data to. */
+            IN gctUINT32            address;
+
+            /* Data read. */
+            OUT gctUINT32           data;
+        }
+        ReadRegisterData;
+
+        /* gcvHAL_WRITE_REGISTER */
+        struct _gcsHAL_WRITE_REGISTER
+        {
+            /* Logical address of memory to write data to. */
+            IN gctUINT32            address;
+
+            /* Data read. */
+            IN gctUINT32            data;
+        }
+        WriteRegisterData;
+
+#if VIVANTE_PROFILER
+        /* gcvHAL_GET_PROFILE_SETTING */
+        struct _gcsHAL_GET_PROFILE_SETTING
+        {
+            /* Enable profiling */
+            OUT gctBOOL             enable;
+
+            /* The profile file name */
+            OUT gctCHAR             fileName[gcdMAX_PROFILE_FILE_NAME];
+        }
+        GetProfileSetting;
+
+        /* gcvHAL_SET_PROFILE_SETTING */
+        struct _gcsHAL_SET_PROFILE_SETTING
+        {
+            /* Enable profiling */
+            IN gctBOOL              enable;
+
+            /* The profile file name */
+            IN gctCHAR              fileName[gcdMAX_PROFILE_FILE_NAME];
+        }
+        SetProfileSetting;
+
+        /* gcvHAL_READ_ALL_PROFILE_REGISTERS */
+        struct _gcsHAL_READ_ALL_PROFILE_REGISTERS
+        {
+            /* Data read. */
+            OUT gcsPROFILER_COUNTERS    counters;
+        }
+        RegisterProfileData;
+
+        /* gcvHAL_PROFILE_REGISTERS_2D */
+        struct _gcsHAL_PROFILE_REGISTERS_2D
+        {
+            /* Data read. */
+            OUT gcs2D_PROFILE_PTR       hwProfile2D;
+        }
+        RegisterProfileData2D;
+#endif
+        /* Power management. */
+        /* gcvHAL_SET_POWER_MANAGEMENT_STATE */
+        struct _gcsHAL_SET_POWER_MANAGEMENT
+        {
+            /* Data read. */
+            IN gceCHIPPOWERSTATE        state;
+        }
+        SetPowerManagement;
+
+        /* gcvHAL_QUERY_POWER_MANAGEMENT_STATE */
+        struct _gcsHAL_QUERY_POWER_MANAGEMENT
+        {
+            /* Data read. */
+            OUT gceCHIPPOWERSTATE       state;
+
+            /* Idle query. */
+            OUT gctBOOL                 isIdle;
+        }
+        QueryPowerManagement;
+
+        /* gcvHAL_QUERY_KERNEL_SETTINGS */
+        struct _gcsHAL_QUERY_KERNEL_SETTINGS
+        {
+            /* Settings.*/
+            OUT gcsKERNEL_SETTINGS      settings;
+        }
+        QueryKernelSettings;
+
+        /* gcvHAL_MAP_PHYSICAL */
+        struct _gcsHAL_MAP_PHYSICAL
+        {
+            /* gcvTRUE to map, gcvFALSE to unmap. */
+            IN gctBOOL                  map;
+
+            /* Physical address. */
+            IN OUT gctPHYS_ADDR         physical;
+        }
+        MapPhysical;
+
+        /* gcvHAL_DEBUG */
+        struct _gcsHAL_DEBUG
+        {
+            /* If gcvTRUE, set the debug information. */
+            IN gctBOOL                  set;
+            IN gctUINT32                level;
+            IN gctUINT32                zones;
+            IN gctBOOL                  enable;
+
+            IN gceDEBUG_MESSAGE_TYPE    type;
+            IN gctUINT32                messageSize;
+
+            /* Message to print if not empty. */
+            IN gctCHAR                  message[80];
+        }
+        Debug;
+
+        /* gcvHAL_CACHE */
+        struct _gcsHAL_CACHE
+        {
+            IN gceCACHEOPERATION        operation;
+            IN gctHANDLE                process;
+            IN gctPOINTER               logical;
+            IN gctSIZE_T                bytes;
+            IN gcuVIDMEM_NODE_PTR       node;
+        }
+        Cache;
+
+        /* gcvHAL_TIMESTAMP */
+        struct _gcsHAL_TIMESTAMP
+        {
+            /* Timer select. */
+            IN gctUINT32                timer;
+
+            /* Timer request type (0-stop, 1-start, 2-send delta). */
+            IN gctUINT32                request;
+
+            /* Result of delta time in microseconds. */
+            OUT gctINT32                timeDelta;
+        }
+        TimeStamp;
+
+        /* gcvHAL_DATABASE */
+        struct _gcsHAL_DATABASE
+        {
+            /* Set to gcvTRUE if you want to query a particular process ID.
+            ** Set to gcvFALSE to query the last detached process. */
+            IN gctBOOL                  validProcessID;
+
+            /* Process ID to query. */
+            IN gctUINT32                processID;
+
+            /* Information. */
+            OUT gcuDATABASE_INFO        vidMem;
+            OUT gcuDATABASE_INFO        nonPaged;
+            OUT gcuDATABASE_INFO        contiguous;
+            OUT gcuDATABASE_INFO        gpuIdle;
+        }
+        Database;
+
+        /* gcvHAL_VERSION */
+        struct _gcsHAL_VERSION
+        {
+            /* Major version: N.n.n. */
+            OUT gctINT32                major;
+
+            /* Minor version: n.N.n. */
+            OUT gctINT32                minor;
+
+            /* Patch version: n.n.N. */
+            OUT gctINT32                patch;
+
+            /* Build version. */
+            OUT gctUINT32               build;
+        }
+        Version;
+
+        /* gcvHAL_CHIP_INFO */
+        struct _gcsHAL_CHIP_INFO
+        {
+            /* Chip count. */
+            OUT gctINT32                count;
+
+            /* Chip types. */
+            OUT gceHARDWARE_TYPE        types[gcdCHIP_COUNT];
+        }
+        ChipInfo;
+
+        /* gcvHAL_ATTACH */
+        struct _gcsHAL_ATTACH
+        {
+            /* Context buffer object. */
+            OUT gckCONTEXT              context;
+
+            /* Number of states in the buffer. */
+            OUT gctSIZE_T               stateCount;
+        }
+        Attach;
+
+        /* gcvHAL_DETACH */
+        struct _gcsHAL_DETACH
+        {
+            /* Context buffer object. */
+            IN gckCONTEXT               context;
+        }
+        Detach;
+
+        /* gcvHAL_COMPOSE. */
+        gcsHAL_COMPOSE                  Compose;
+
+        /* gcvHAL_GET_FRAME_INFO. */
+        struct _gcsHAL_GET_FRAME_INFO
+        {
+            OUT gcsHAL_FRAME_INFO *     frameInfo;
+        }
+        GetFrameInfo;
+
+        /* gcvHAL_SET_TIME_OUT. */
+        struct _gcsHAL_SET_TIMEOUT
+        {
+            gctUINT32                   timeOut;
+        }
+        SetTimeOut;
+
+#if gcdENABLE_VG
+		/* gcvHAL_COMMIT */
+		struct _gcsHAL_VGCOMMIT
+		{
+			/* Context buffer. */
+			IN gcsVGCONTEXT_PTR			context;
+
+			/* Command queue. */
+			IN gcsVGCMDQUEUE_PTR			queue;
+
+			/* Number of entries in the queue. */
+			IN gctUINT					entryCount;
+
+			/* Task table. */
+			IN gcsTASK_MASTER_TABLE_PTR	taskTable;
+		}
+		VGCommit;
+
+		/* gcvHAL_QUERY_COMMAND_BUFFER */
+		struct _gcsHAL_QUERY_COMMAND_BUFFER
+		{
+			/* Command buffer attributes. */
+			OUT gcsCOMMAND_BUFFER_INFO	information;
+		}
+		QueryCommandBuffer;
+
+#endif
+
+        struct _gcsHAL_GET_SHARED_INFO
+        {
+            IN gctUINT32            pid;
+            IN gctUINT32            dataId;
+            IN gcuVIDMEM_NODE_PTR   node;
+            OUT gctUINT8_PTR        data;
+            /* fix size */
+            OUT gctUINT8_PTR        nodeData;
+            gctSIZE_T               size;
+            IN gceVIDMEM_NODE_SHARED_INFO_TYPE infoType;
+        }
+        GetSharedInfo;
+
+        struct _gcsHAL_SET_SHARED_INFO
+        {
+            IN gctUINT32            dataId;
+            IN gcuVIDMEM_NODE_PTR   node;
+            IN gctUINT8_PTR         data;
+            IN gctUINT8_PTR         nodeData;
+            IN gctSIZE_T            size;
+            IN gceVIDMEM_NODE_SHARED_INFO_TYPE infoType;
+        }
+        SetSharedInfo;
+    }
+    u;
+}
+gcsHAL_INTERFACE;
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __gc_hal_driver_h_ */
diff --git a/attic/gc_hal_driver_vg.h b/attic/gc_hal_driver_vg.h
new file mode 100644
index 0000000..fe57968
--- /dev/null
+++ b/attic/gc_hal_driver_vg.h
@@ -0,0 +1,292 @@
+/****************************************************************************
+*
+*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*
+*    This program is free software; you can redistribute it and/or modify
+*    it under the terms of the GNU General Public License as published by
+*    the Free Software Foundation; either version 2 of the license, or
+*    (at your option) any later version.
+*
+*    This program is distributed in the hope that it will be useful,
+*    but WITHOUT ANY WARRANTY; without even the implied warranty of
+*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+*    GNU General Public License for more details.
+*
+*    You should have received a copy of the GNU General Public License
+*    along with this program; if not write to the Free Software
+*    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*
+*****************************************************************************/
+
+
+
+
+
+
+#ifndef __gc_hal_driver_vg_h_
+#define __gc_hal_driver_vg_h_
+
+
+
+#include "gc_hal_types.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/******************************************************************************\
+******************************* I/O Control Codes ******************************
+\******************************************************************************/
+
+#define gcvHAL_CLASS            "galcore"
+#define IOCTL_GCHAL_INTERFACE   30000
+
+/******************************************************************************\
+********************************* Command Codes ********************************
+\******************************************************************************/
+
+/******************************************************************************\
+********************* Command buffer information structure. ********************
+\******************************************************************************/
+
+typedef struct _gcsCOMMAND_BUFFER_INFO * gcsCOMMAND_BUFFER_INFO_PTR;
+typedef struct _gcsCOMMAND_BUFFER_INFO
+{
+    /* FE command buffer interrupt ID. */
+    gctINT32                    feBufferInt;
+
+    /* TS overflow interrupt ID. */
+    gctINT32                    tsOverflowInt;
+
+    /* Alignment and mask for the buffer address. */
+    gctUINT                     addressMask;
+    gctSIZE_T                   addressAlignment;
+
+    /* Alignment for each command. */
+    gctSIZE_T                   commandAlignment;
+
+    /* Number of bytes required by the STATE command. */
+    gctSIZE_T                   stateCommandSize;
+
+    /* Number of bytes required by the RESTART command. */
+    gctSIZE_T                   restartCommandSize;
+
+    /* Number of bytes required by the FETCH command. */
+    gctSIZE_T                   fetchCommandSize;
+
+    /* Number of bytes required by the CALL command. */
+    gctSIZE_T                   callCommandSize;
+
+    /* Number of bytes required by the RETURN command. */
+    gctSIZE_T                   returnCommandSize;
+
+    /* Number of bytes required by the EVENT command. */
+    gctSIZE_T                   eventCommandSize;
+
+    /* Number of bytes required by the END command. */
+    gctSIZE_T                   endCommandSize;
+
+    /* Number of bytes reserved at the tail of a static command buffer. */
+    gctSIZE_T                   staticTailSize;
+
+    /* Number of bytes reserved at the tail of a dynamic command buffer. */
+    gctSIZE_T                   dynamicTailSize;
+}
+gcsCOMMAND_BUFFER_INFO;
+
+/******************************************************************************\
+******************************** Task Structures *******************************
+\******************************************************************************/
+
+typedef enum _gceTASK
+{
+    gcvTASK_LINK,
+    gcvTASK_CLUSTER,
+    gcvTASK_INCREMENT,
+    gcvTASK_DECREMENT,
+    gcvTASK_SIGNAL,
+    gcvTASK_LOCKDOWN,
+    gcvTASK_UNLOCK_VIDEO_MEMORY,
+    gcvTASK_FREE_VIDEO_MEMORY,
+    gcvTASK_FREE_CONTIGUOUS_MEMORY,
+    gcvTASK_UNMAP_USER_MEMORY,
+    gcvTASK_UNMAP_MEMORY
+}
+gceTASK;
+
+typedef struct _gcsTASK_HEADER * gcsTASK_HEADER_PTR;
+typedef struct _gcsTASK_HEADER
+{
+    /* Task ID. */
+    IN gceTASK                  id;
+}
+gcsTASK_HEADER;
+
+typedef struct _gcsTASK_LINK * gcsTASK_LINK_PTR;
+typedef struct _gcsTASK_LINK
+{
+    /* Task ID (gcvTASK_LINK). */
+    IN gceTASK                  id;
+
+    /* Pointer to the next task container. */
+    IN gctPOINTER               cotainer;
+
+    /* Pointer to the next task from the next task container. */
+    IN gcsTASK_HEADER_PTR       task;
+}
+gcsTASK_LINK;
+
+typedef struct _gcsTASK_CLUSTER * gcsTASK_CLUSTER_PTR;
+typedef struct _gcsTASK_CLUSTER
+{
+    /* Task ID (gcvTASK_CLUSTER). */
+    IN gceTASK                  id;
+
+    /* Number of tasks in the cluster. */
+    IN gctUINT                  taskCount;
+}
+gcsTASK_CLUSTER;
+
+typedef struct _gcsTASK_INCREMENT * gcsTASK_INCREMENT_PTR;
+typedef struct _gcsTASK_INCREMENT
+{
+    /* Task ID (gcvTASK_INCREMENT). */
+    IN gceTASK                  id;
+
+    /* Address of the variable to increment. */
+    IN gctUINT32                address;
+}
+gcsTASK_INCREMENT;
+
+typedef struct _gcsTASK_DECREMENT * gcsTASK_DECREMENT_PTR;
+typedef struct _gcsTASK_DECREMENT
+{
+    /* Task ID (gcvTASK_DECREMENT). */
+    IN gceTASK                  id;
+
+    /* Address of the variable to decrement. */
+    IN gctUINT32                address;
+}
+gcsTASK_DECREMENT;
+
+typedef struct _gcsTASK_SIGNAL * gcsTASK_SIGNAL_PTR;
+typedef struct _gcsTASK_SIGNAL
+{
+    /* Task ID (gcvTASK_SIGNAL). */
+    IN gceTASK                  id;
+
+    /* Process owning the signal. */
+    IN gctHANDLE                process;
+
+    /* Signal handle to signal. */
+    IN gctSIGNAL                signal;
+
+#if defined(__QNXNTO__)
+    IN gctINT32                 coid;
+    IN gctINT32                 rcvid;
+#endif
+}
+gcsTASK_SIGNAL;
+
+typedef struct _gcsTASK_LOCKDOWN * gcsTASK_LOCKDOWN_PTR;
+typedef struct _gcsTASK_LOCKDOWN
+{
+    /* Task ID (gcvTASK_LOCKDOWN). */
+    IN gceTASK                  id;
+
+    /* Address of the user space counter. */
+    IN gctUINT32                userCounter;
+
+    /* Address of the kernel space counter. */
+    IN gctUINT32                kernelCounter;
+
+    /* Process owning the signal. */
+    IN gctHANDLE                process;
+
+    /* Signal handle to signal. */
+    IN gctSIGNAL                signal;
+}
+gcsTASK_LOCKDOWN;
+
+typedef struct _gcsTASK_UNLOCK_VIDEO_MEMORY * gcsTASK_UNLOCK_VIDEO_MEMORY_PTR;
+typedef struct _gcsTASK_UNLOCK_VIDEO_MEMORY
+{
+    /* Task ID (gcvTASK_UNLOCK_VIDEO_MEMORY). */
+    IN gceTASK                  id;
+
+    /* Allocated video memory. */
+    IN gcuVIDMEM_NODE_PTR       node;
+}
+gcsTASK_UNLOCK_VIDEO_MEMORY;
+
+typedef struct _gcsTASK_FREE_VIDEO_MEMORY * gcsTASK_FREE_VIDEO_MEMORY_PTR;
+typedef struct _gcsTASK_FREE_VIDEO_MEMORY
+{
+    /* Task ID (gcvTASK_FREE_VIDEO_MEMORY). */
+    IN gceTASK                  id;
+
+    /* Allocated video memory. */
+    IN gcuVIDMEM_NODE_PTR       node;
+}
+gcsTASK_FREE_VIDEO_MEMORY;
+
+typedef struct _gcsTASK_FREE_CONTIGUOUS_MEMORY * gcsTASK_FREE_CONTIGUOUS_MEMORY_PTR;
+typedef struct _gcsTASK_FREE_CONTIGUOUS_MEMORY
+{
+    /* Task ID (gcvTASK_FREE_CONTIGUOUS_MEMORY). */
+    IN gceTASK                  id;
+
+    /* Number of bytes allocated. */
+    IN gctSIZE_T                bytes;
+
+    /* Physical address of allocation. */
+    IN gctPHYS_ADDR             physical;
+
+    /* Logical address of allocation. */
+    IN gctPOINTER               logical;
+}
+gcsTASK_FREE_CONTIGUOUS_MEMORY;
+
+typedef struct _gcsTASK_UNMAP_USER_MEMORY * gcsTASK_UNMAP_USER_MEMORY_PTR;
+typedef struct _gcsTASK_UNMAP_USER_MEMORY
+{
+    /* Task ID (gcvTASK_UNMAP_USER_MEMORY). */
+    IN gceTASK                  id;
+
+    /* Base address of user memory to unmap. */
+    IN gctPOINTER               memory;
+
+    /* Size of user memory in bytes to unmap. */
+    IN gctSIZE_T                size;
+
+    /* Info record returned by gcvHAL_MAP_USER_MEMORY. */
+    IN gctPOINTER               info;
+
+    /* Physical address of mapped memory as returned by
+       gcvHAL_MAP_USER_MEMORY. */
+    IN gctUINT32                address;
+}
+gcsTASK_UNMAP_USER_MEMORY;
+
+typedef struct _gcsTASK_UNMAP_MEMORY * gcsTASK_UNMAP_MEMORY_PTR;
+typedef struct _gcsTASK_UNMAP_MEMORY
+{
+    /* Task ID (gcvTASK_UNMAP_MEMORY). */
+    IN gceTASK                  id;
+
+    /* Physical memory address to unmap. */
+    IN gctPHYS_ADDR             physical;
+
+    /* Number of bytes in physical memory to unmap. */
+    IN gctSIZE_T                bytes;
+
+    /* Address of mapped memory to unmap. */
+    IN gctPOINTER               logical;
+}
+gcsTASK_UNMAP_MEMORY;
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __gc_hal_driver_h_ */
diff --git a/attic/gc_hal_dump.h b/attic/gc_hal_dump.h
new file mode 100644
index 0000000..9b2db22
--- /dev/null
+++ b/attic/gc_hal_dump.h
@@ -0,0 +1,89 @@
+/****************************************************************************
+*
+*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*
+*    This program is free software; you can redistribute it and/or modify
+*    it under the terms of the GNU General Public License as published by
+*    the Free Software Foundation; either version 2 of the license, or
+*    (at your option) any later version.
+*
+*    This program is distributed in the hope that it will be useful,
+*    but WITHOUT ANY WARRANTY; without even the implied warranty of
+*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+*    GNU General Public License for more details.
+*
+*    You should have received a copy of the GNU General Public License
+*    along with this program; if not write to the Free Software
+*    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*
+*****************************************************************************/
+
+
+
+#ifndef __gc_hal_dump_h_
+#define __gc_hal_dump_h_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*
+**	FILE LAYOUT:
+**
+**		gcsDUMP_FILE structure
+**
+**		gcsDUMP_DATA frame
+**			gcsDUMP_DATA or gcDUMP_DATA_SIZE records rendingring the frame
+**			gctUINT8 data[length]
+*/
+
+#define gcvDUMP_FILE_SIGNATURE		gcmCC('g','c','D','B')
+
+typedef struct _gcsDUMP_FILE
+{
+	gctUINT32   		signature;	/* File signature */
+	gctSIZE_T 			length;		/* Length of file */
+	gctUINT32 			frames;		/* Number of frames in file */
+}
+gcsDUMP_FILE;
+
+typedef enum _gceDUMP_TAG
+{
+	gcvTAG_SURFACE					= gcmCC('s','u','r','f'),
+	gcvTAG_FRAME					= gcmCC('f','r','m',' '),
+	gcvTAG_COMMAND					= gcmCC('c','m','d',' '),
+	gcvTAG_INDEX					= gcmCC('i','n','d','x'),
+	gcvTAG_STREAM					= gcmCC('s','t','r','m'),
+	gcvTAG_TEXTURE					= gcmCC('t','e','x','t'),
+	gcvTAG_RENDER_TARGET			= gcmCC('r','n','d','r'),
+	gcvTAG_DEPTH					= gcmCC('z','b','u','f'),
+	gcvTAG_RESOLVE					= gcmCC('r','s','l','v'),
+	gcvTAG_DELETE					= gcmCC('d','e','l',' '),
+}
+gceDUMP_TAG;
+
+typedef struct _gcsDUMP_SURFACE
+{
+	gceDUMP_TAG			type;		/* Type of record. */
+	gctUINT32     		address;	/* Address of the surface. */
+	gctINT16      		width;		/* Width of surface. */
+	gctINT16	   		height;		/* Height of surface. */
+	gceSURF_FORMAT		format;		/* Surface pixel format. */
+	gctSIZE_T			length;		/* Number of bytes inside the surface. */
+}
+gcsDUMP_SURFACE;
+
+typedef struct _gcsDUMP_DATA
+{
+	gceDUMP_TAG		 	type;		/* Type of record. */
+	gctSIZE_T     		length;		/* Number of bytes of data. */
+	gctUINT32     		address;	/* Address for the data. */
+}
+gcsDUMP_DATA;
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __gc_hal_dump_h_ */
+
diff --git a/attic/gc_hal_eglplatform.h b/attic/gc_hal_eglplatform.h
new file mode 100644
index 0000000..e0efba4
--- /dev/null
+++ b/attic/gc_hal_eglplatform.h
@@ -0,0 +1,621 @@
+/****************************************************************************
+*
+*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*
+*    This program is free software; you can redistribute it and/or modify
+*    it under the terms of the GNU General Public License as published by
+*    the Free Software Foundation; either version 2 of the license, or
+*    (at your option) any later version.
+*
+*    This program is distributed in the hope that it will be useful,
+*    but WITHOUT ANY WARRANTY; without even the implied warranty of
+*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+*    GNU General Public License for more details.
+*
+*    You should have received a copy of the GNU General Public License
+*    along with this program; if not write to the Free Software
+*    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*
+*****************************************************************************/
+
+
+
+
+#ifndef __gc_hal_eglplatform_h_
+#define __gc_hal_eglplatform_h_
+
+/* Include VDK types. */
+#include "gc_hal_types.h"
+#include "gc_hal_base.h"
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*******************************************************************************
+** Events. *********************************************************************
+*/
+
+typedef enum _halEventType
+{
+	/* Keyboard event. */
+    HAL_KEYBOARD,
+
+	/* Mouse move event. */
+    HAL_POINTER,
+
+	/* Mouse button event. */
+    HAL_BUTTON,
+
+	/* Application close event. */
+	HAL_CLOSE,
+
+	/* Application window has been updated. */
+	HAL_WINDOW_UPDATE
+}
+halEventType;
+
+/* Scancodes for keyboard. */
+typedef enum _halKeys
+{
+    HAL_UNKNOWN = -1,
+
+    HAL_BACKSPACE = 0x08,
+    HAL_TAB,
+    HAL_ENTER = 0x0D,
+    HAL_ESCAPE = 0x1B,
+
+    HAL_SPACE = 0x20,
+    HAL_SINGLEQUOTE = 0x27,
+    HAL_PAD_ASTERISK = 0x2A,
+    HAL_COMMA = 0x2C,
+    HAL_HYPHEN,
+    HAL_PERIOD,
+    HAL_SLASH,
+    HAL_0,
+    HAL_1,
+    HAL_2,
+    HAL_3,
+    HAL_4,
+    HAL_5,
+    HAL_6,
+    HAL_7,
+    HAL_8,
+    HAL_9,
+    HAL_SEMICOLON = 0x3B,
+    HAL_EQUAL = 0x3D,
+    HAL_A = 0x41,
+    HAL_B,
+    HAL_C,
+    HAL_D,
+    HAL_E,
+    HAL_F,
+    HAL_G,
+    HAL_H,
+    HAL_I,
+    HAL_J,
+    HAL_K,
+    HAL_L,
+    HAL_M,
+    HAL_N,
+    HAL_O,
+    HAL_P,
+    HAL_Q,
+    HAL_R,
+    HAL_S,
+    HAL_T,
+    HAL_U,
+    HAL_V,
+    HAL_W,
+    HAL_X,
+    HAL_Y,
+    HAL_Z,
+    HAL_LBRACKET,
+    HAL_BACKSLASH,
+    HAL_RBRACKET,
+    HAL_BACKQUOTE = 0x60,
+
+    HAL_F1 = 0x80,
+    HAL_F2,
+    HAL_F3,
+    HAL_F4,
+    HAL_F5,
+    HAL_F6,
+    HAL_F7,
+    HAL_F8,
+    HAL_F9,
+    HAL_F10,
+    HAL_F11,
+    HAL_F12,
+
+    HAL_LCTRL,
+    HAL_RCTRL,
+    HAL_LSHIFT,
+    HAL_RSHIFT,
+    HAL_LALT,
+    HAL_RALT,
+    HAL_CAPSLOCK,
+    HAL_NUMLOCK,
+    HAL_SCROLLLOCK,
+    HAL_PAD_0,
+    HAL_PAD_1,
+    HAL_PAD_2,
+    HAL_PAD_3,
+    HAL_PAD_4,
+    HAL_PAD_5,
+    HAL_PAD_6,
+    HAL_PAD_7,
+    HAL_PAD_8,
+    HAL_PAD_9,
+    HAL_PAD_HYPHEN,
+    HAL_PAD_PLUS,
+    HAL_PAD_SLASH,
+    HAL_PAD_PERIOD,
+    HAL_PAD_ENTER,
+    HAL_SYSRQ,
+    HAL_PRNTSCRN,
+    HAL_BREAK,
+    HAL_UP,
+    HAL_LEFT,
+    HAL_RIGHT,
+    HAL_DOWN,
+    HAL_HOME,
+    HAL_END,
+    HAL_PGUP,
+    HAL_PGDN,
+    HAL_INSERT,
+    HAL_DELETE,
+    HAL_LWINDOW,
+    HAL_RWINDOW,
+    HAL_MENU,
+    HAL_POWER,
+    HAL_SLEEP,
+    HAL_WAKE
+}
+halKeys;
+
+/* Structure that defined keyboard mapping. */
+typedef struct _halKeyMap
+{
+	/* Normal key. */
+    halKeys normal;
+
+	/* Extended key. */
+    halKeys extended;
+}
+halKeyMap;
+
+/* Event structure. */
+typedef struct _halEvent
+{
+	/* Event type. */
+    halEventType type;
+
+	/* Event data union. */
+    union _halEventData
+    {
+		/* Event data for keyboard. */
+        struct _halKeyboard
+        {
+			/* Scancode. */
+            halKeys	scancode;
+
+			/* ASCII characte of the key pressed. */
+            gctCHAR	key;
+
+			/* Flag whether the key was pressed (1) or released (0). */
+            gctCHAR	pressed;
+        }
+        keyboard;
+
+		/* Event data for pointer. */
+        struct _halPointer
+        {
+			/* Current pointer coordinate. */
+            gctINT		x;
+            gctINT		y;
+        }
+        pointer;
+
+		/* Event data for mouse buttons. */
+        struct _halButton
+        {
+			/* Left button state. */
+            gctINT		left;
+
+			/* Middle button state. */
+            gctINT		middle;
+
+			/* Right button state. */
+            gctINT		right;
+
+			/* Current pointer coordinate. */
+			gctINT		x;
+			gctINT		y;
+        }
+        button;
+    }
+    data;
+}
+halEvent;
+
+#if defined(_WIN32) || defined(__VC32__) && !defined(__CYGWIN__) && !defined(__SCITECH_SNAP__)
+/* Win32 and Windows CE platforms. */
+#include <windows.h>
+typedef HDC             HALNativeDisplayType;
+typedef HWND            HALNativeWindowType;
+typedef HBITMAP         HALNativePixmapType;
+
+#elif defined(LINUX) && defined(EGL_API_FB) && !defined(__APPLE__)
+/* Linux platform for FBDEV. */
+typedef struct _FBDisplay * HALNativeDisplayType;
+typedef struct _FBWindow *  HALNativeWindowType;
+typedef struct _FBPixmap *  HALNativePixmapType;
+
+#elif defined(__ANDROID__) || defined(ANDROID)
+
+struct egl_native_pixmap_t;
+
+#if ANDROID_SDK_VERSION >= 9
+    #include <android/native_window.h>
+
+    typedef struct ANativeWindow*           HALNativeWindowType;
+    typedef struct egl_native_pixmap_t*     HALNativePixmapType;
+    typedef void*                           HALNativeDisplayType;
+#else
+    struct android_native_window_t;
+    typedef struct android_native_window_t*    HALNativeWindowType;
+    typedef struct egl_native_pixmap_t *        HALNativePixmapType;
+    typedef void*                               HALNativeDisplayType;
+#endif
+
+#elif defined(LINUX) || defined(__APPLE__)
+/* X11 platform. */
+#include <X11/Xlib.h>
+#include <X11/Xutil.h>
+
+typedef Display *   HALNativeDisplayType;
+typedef Window      HALNativeWindowType;
+
+#ifdef CUSTOM_PIXMAP
+typedef void *      HALNativePixmapType;
+#else
+typedef Pixmap      HALNativePixmapType;
+#endif /* CUSTOM_PIXMAP */
+
+/* Rename some badly named X defines. */
+#ifdef Status
+#   define XStatus      int
+#   undef Status
+#endif
+#ifdef Always
+#   define XAlways      2
+#   undef Always
+#endif
+#ifdef CurrentTime
+#   undef CurrentTime
+#   define XCurrentTime 0
+#endif
+
+#elif defined(__QNXNTO__)
+
+/* VOID */
+typedef void *  HALNativeDisplayType;
+typedef void *  HALNativeWindowType;
+typedef void *  HALNativePixmapType;
+
+#else
+
+#error "Platform not recognized"
+
+/* VOID */
+typedef void *  HALNativeDisplayType;
+typedef void *  HALNativeWindowType;
+typedef void *  HALNativePixmapType;
+
+#endif
+
+
+
+/*******************************************************************************
+** Display. ********************************************************************
+*/
+
+gceSTATUS
+gcoOS_GetDisplay(
+    OUT HALNativeDisplayType * Display
+    );
+
+gceSTATUS
+gcoOS_GetDisplayByIndex(
+    IN gctINT DisplayIndex,
+    OUT HALNativeDisplayType * Display
+    );
+
+gceSTATUS
+gcoOS_GetDisplayInfo(
+    IN HALNativeDisplayType Display,
+    OUT gctINT * Width,
+    OUT gctINT * Height,
+    OUT gctSIZE_T * Physical,
+    OUT gctINT * Stride,
+    OUT gctINT * BitsPerPixel
+    );
+
+/* VFK_DISPLAY_INFO structure defining information returned by
+   vdkGetDisplayInfoEx. */
+typedef struct _halDISPLAY_INFO
+{
+    /* The size of the display in pixels. */
+    gctINT                         width;
+    gctINT                         height;
+
+    /* The stride of the dispay. -1 is returned if the stride is not known
+    ** for the specified display.*/
+    gctINT                         stride;
+
+    /* The color depth of the display in bits per pixel. */
+    gctINT                         bitsPerPixel;
+
+    /* The logical pointer to the display memory buffer. NULL is returned
+    ** if the pointer is not known for the specified display. */
+    gctPOINTER                      logical;
+
+    /* The physical address of the display memory buffer. ~0 is returned
+    ** if the address is not known for the specified display. */
+    gctSIZE_T               physical;
+
+#ifndef __QNXNTO__
+    /* 355_FB_MULTI_BUFFER */
+    gctINT                      multiBuffer;
+    gctINT                      backBufferY;
+#endif
+
+    /* The color info of the display. */
+    gctUINT                alphaLength;
+    gctUINT                alphaOffset;
+    gctUINT                redLength;
+    gctUINT                redOffset;
+    gctUINT                greenLength;
+    gctUINT                greenOffset;
+    gctUINT                blueLength;
+    gctUINT                blueOffset;
+
+    /* Display flip support. */
+    gctINT                         flip;
+}
+halDISPLAY_INFO;
+
+gceSTATUS
+gcoOS_GetDisplayInfoEx(
+    IN HALNativeDisplayType Display,
+    IN HALNativeWindowType Window,
+    IN gctUINT DisplayInfoSize,
+    OUT halDISPLAY_INFO * DisplayInfo
+    );
+
+gceSTATUS
+gcoOS_GetNextDisplayInfoEx(
+    IN HALNativeDisplayType Display,
+    IN HALNativeWindowType Window,
+    IN gctUINT DisplayInfoSize,
+    OUT halDISPLAY_INFO * DisplayInfo
+    );
+
+gceSTATUS
+gcoOS_GetDisplayVirtual(
+    IN HALNativeDisplayType Display,
+    OUT gctINT * Width,
+    OUT gctINT * Height
+    );
+
+gceSTATUS
+gcoOS_GetDisplayBackbuffer(
+    IN HALNativeDisplayType Display,
+    IN HALNativeWindowType Window,
+    IN gctPOINTER    context,
+    IN gcoSURF       surface,
+    OUT gctUINT * Offset,
+    OUT gctINT * X,
+    OUT gctINT * Y
+    );
+
+gceSTATUS
+gcoOS_SetDisplayVirtual(
+    IN HALNativeDisplayType Display,
+    IN HALNativeWindowType Window,
+    IN gctUINT Offset,
+    IN gctINT X,
+    IN gctINT Y
+    );
+
+gceSTATUS
+gcoOS_DisplayBufferRegions(
+    IN HALNativeDisplayType Display,
+    IN HALNativeWindowType Window,
+    IN gctINT NumRects,
+    IN gctINT_PTR Rects
+    );
+
+gceSTATUS
+gcoOS_DestroyDisplay(
+    IN HALNativeDisplayType Display
+    );
+
+/*******************************************************************************
+** Windows. ********************************************************************
+*/
+
+gceSTATUS
+gcoOS_CreateWindow(
+    IN HALNativeDisplayType Display,
+    IN gctINT X,
+    IN gctINT Y,
+    IN gctINT Width,
+    IN gctINT Height,
+    OUT HALNativeWindowType * Window
+    );
+
+gceSTATUS
+gcoOS_GetWindowInfo(
+    IN HALNativeDisplayType Display,
+    IN HALNativeWindowType Window,
+    OUT gctINT * X,
+    OUT gctINT * Y,
+    OUT gctINT * Width,
+    OUT gctINT * Height,
+    OUT gctINT * BitsPerPixel,
+#ifdef __QNXNTO__
+    OUT gctINT * Format,
+#endif
+    OUT gctUINT * Offset
+    );
+
+gceSTATUS
+gcoOS_DestroyWindow(
+    IN HALNativeDisplayType Display,
+    IN HALNativeWindowType Window
+    );
+
+gceSTATUS
+gcoOS_DrawImage(
+    IN HALNativeDisplayType Display,
+    IN HALNativeWindowType Window,
+    IN gctINT Left,
+    IN gctINT Top,
+    IN gctINT Right,
+    IN gctINT Bottom,
+    IN gctINT Width,
+    IN gctINT Height,
+    IN gctINT BitsPerPixel,
+    IN gctPOINTER Bits
+    );
+
+gceSTATUS
+gcoOS_GetImage(
+    IN HALNativeWindowType Window,
+    IN gctINT Left,
+    IN gctINT Top,
+    IN gctINT Right,
+    IN gctINT Bottom,
+    OUT gctINT * BitsPerPixel,
+    OUT gctPOINTER * Bits
+    );
+
+/*******************************************************************************
+** Pixmaps. ********************************************************************
+*/
+
+gceSTATUS
+gcoOS_CreatePixmap(
+    IN HALNativeDisplayType Display,
+    IN gctINT Width,
+    IN gctINT Height,
+    IN gctINT BitsPerPixel,
+    OUT HALNativePixmapType * Pixmap
+    );
+
+gceSTATUS
+gcoOS_GetPixmapInfo(
+    IN HALNativeDisplayType Display,
+    IN HALNativePixmapType Pixmap,
+    OUT gctINT * Width,
+    OUT gctINT * Height,
+    OUT gctINT * BitsPerPixel,
+    OUT gctINT * Stride,
+    OUT gctPOINTER * Bits
+    );
+
+gceSTATUS
+gcoOS_DrawPixmap(
+    IN HALNativeDisplayType Display,
+    IN HALNativePixmapType Pixmap,
+    IN gctINT Left,
+    IN gctINT Top,
+    IN gctINT Right,
+    IN gctINT Bottom,
+    IN gctINT Width,
+    IN gctINT Height,
+    IN gctINT BitsPerPixel,
+    IN gctPOINTER Bits
+    );
+
+gceSTATUS
+gcoOS_DestroyPixmap(
+    IN HALNativeDisplayType Display,
+    IN HALNativePixmapType Pixmap
+    );
+
+/*******************************************************************************
+** OS relative. ****************************************************************
+*/
+gceSTATUS
+gcoOS_LoadEGLLibrary(
+    OUT gctHANDLE * Handle
+    );
+
+gceSTATUS
+gcoOS_FreeEGLLibrary(
+    IN gctHANDLE Handle
+    );
+
+gceSTATUS
+gcoOS_ShowWindow(
+    IN HALNativeDisplayType Display,
+    IN HALNativeWindowType Window
+    );
+
+gceSTATUS
+gcoOS_HideWindow(
+    IN HALNativeDisplayType Display,
+    IN HALNativeWindowType Window
+    );
+
+gceSTATUS
+gcoOS_SetWindowTitle(
+    IN HALNativeDisplayType Display,
+    IN HALNativeWindowType Window,
+    IN gctCONST_STRING Title
+    );
+
+gceSTATUS
+gcoOS_CapturePointer(
+    IN HALNativeDisplayType Display,
+    IN HALNativeWindowType Window
+    );
+
+gceSTATUS
+gcoOS_GetEvent(
+    IN HALNativeDisplayType Display,
+    IN HALNativeWindowType Window,
+    OUT halEvent * Event
+    );
+
+gceSTATUS
+gcoOS_CreateClientBuffer(
+    IN gctINT Width,
+    IN gctINT Height,
+    IN gctINT Format,
+    IN gctINT Type,
+    OUT gctPOINTER * ClientBuffer
+    );
+
+gceSTATUS
+gcoOS_GetClientBufferInfo(
+    IN gctPOINTER ClientBuffer,
+    OUT gctINT * Width,
+    OUT gctINT * Height,
+    OUT gctINT * Stride,
+    OUT gctPOINTER * Bits
+    );
+
+gceSTATUS
+gcoOS_DestroyClientBuffer(
+    IN gctPOINTER ClientBuffer
+    );
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __gc_hal_eglplatform_h_ */
diff --git a/attic/gc_hal_engine.h b/attic/gc_hal_engine.h
new file mode 100644
index 0000000..22cdc2f
--- /dev/null
+++ b/attic/gc_hal_engine.h
@@ -0,0 +1,1847 @@
+/****************************************************************************
+*
+*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*
+*    This program is free software; you can redistribute it and/or modify
+*    it under the terms of the GNU General Public License as published by
+*    the Free Software Foundation; either version 2 of the license, or
+*    (at your option) any later version.
+*
+*    This program is distributed in the hope that it will be useful,
+*    but WITHOUT ANY WARRANTY; without even the implied warranty of
+*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+*    GNU General Public License for more details.
+*
+*    You should have received a copy of the GNU General Public License
+*    along with this program; if not write to the Free Software
+*    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*
+*****************************************************************************/
+
+
+
+
+#ifndef __gc_hal_engine_h_
+#define __gc_hal_engine_h_
+
+#ifndef VIVANTE_NO_3D
+#include "gc_hal_types.h"
+#include "gc_hal_enum.h"
+
+#if gcdENABLE_VG
+#include "gc_hal_engine_vg.h"
+#endif
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/******************************************************************************\
+****************************** Object Declarations *****************************
+\******************************************************************************/
+
+typedef struct _gcoSTREAM *             gcoSTREAM;
+typedef struct _gcoVERTEX *             gcoVERTEX;
+typedef struct _gcoTEXTURE *            gcoTEXTURE;
+typedef struct _gcoINDEX *              gcoINDEX;
+typedef struct _gcsVERTEX_ATTRIBUTES *  gcsVERTEX_ATTRIBUTES_PTR;
+typedef struct _gcoVERTEXARRAY *        gcoVERTEXARRAY;
+
+#define gcdATTRIBUTE_COUNT              16
+
+/******************************************************************************\
+********************************* Enumerations *********************************
+\******************************************************************************/
+
+/* Shading format. */
+typedef enum _gceSHADING
+{
+    gcvSHADING_SMOOTH,
+    gcvSHADING_FLAT_D3D,
+    gcvSHADING_FLAT_OPENGL,
+}
+gceSHADING;
+
+/* Culling modes. */
+typedef enum _gceCULL
+{
+    gcvCULL_NONE,
+    gcvCULL_CCW,
+    gcvCULL_CW,
+}
+gceCULL;
+
+/* Fill modes. */
+typedef enum _gceFILL
+{
+    gcvFILL_POINT,
+    gcvFILL_WIRE_FRAME,
+    gcvFILL_SOLID,
+}
+gceFILL;
+
+/* Compare modes. */
+typedef enum _gceCOMPARE
+{
+    gcvCOMPARE_NEVER,
+    gcvCOMPARE_NOT_EQUAL,
+    gcvCOMPARE_LESS,
+    gcvCOMPARE_LESS_OR_EQUAL,
+    gcvCOMPARE_EQUAL,
+    gcvCOMPARE_GREATER,
+    gcvCOMPARE_GREATER_OR_EQUAL,
+    gcvCOMPARE_ALWAYS,
+    gcvCOMPARE_INVALID = -1
+}
+gceCOMPARE;
+
+/* Stencil modes. */
+typedef enum _gceSTENCIL_MODE
+{
+    gcvSTENCIL_NONE,
+    gcvSTENCIL_SINGLE_SIDED,
+    gcvSTENCIL_DOUBLE_SIDED,
+}
+gceSTENCIL_MODE;
+
+/* Stencil operations. */
+typedef enum _gceSTENCIL_OPERATION
+{
+    gcvSTENCIL_KEEP,
+    gcvSTENCIL_REPLACE,
+    gcvSTENCIL_ZERO,
+    gcvSTENCIL_INVERT,
+    gcvSTENCIL_INCREMENT,
+    gcvSTENCIL_DECREMENT,
+    gcvSTENCIL_INCREMENT_SATURATE,
+    gcvSTENCIL_DECREMENT_SATURATE,
+    gcvSTENCIL_OPERATION_INVALID = -1
+}
+gceSTENCIL_OPERATION;
+
+/* Stencil selection. */
+typedef enum _gceSTENCIL_WHERE
+{
+    gcvSTENCIL_FRONT,
+    gcvSTENCIL_BACK,
+}
+gceSTENCIL_WHERE;
+
+/* Texture addressing selection. */
+typedef enum _gceTEXTURE_WHICH
+{
+    gcvTEXTURE_S,
+    gcvTEXTURE_T,
+    gcvTEXTURE_R,
+}
+gceTEXTURE_WHICH;
+
+/* Texture addressing modes. */
+typedef enum _gceTEXTURE_ADDRESSING
+{
+    gcvTEXTURE_WRAP,
+    gcvTEXTURE_CLAMP,
+    gcvTEXTURE_BORDER,
+    gcvTEXTURE_MIRROR,
+    gcvTEXTURE_MIRROR_ONCE,
+}
+gceTEXTURE_ADDRESSING;
+
+/* Texture filters. */
+typedef enum _gceTEXTURE_FILTER
+{
+    gcvTEXTURE_NONE,
+    gcvTEXTURE_POINT,
+    gcvTEXTURE_LINEAR,
+    gcvTEXTURE_ANISOTROPIC,
+}
+gceTEXTURE_FILTER;
+
+/* Primitive types. */
+typedef enum _gcePRIMITIVE
+{
+    gcvPRIMITIVE_POINT_LIST,
+    gcvPRIMITIVE_LINE_LIST,
+    gcvPRIMITIVE_LINE_STRIP,
+    gcvPRIMITIVE_LINE_LOOP,
+    gcvPRIMITIVE_TRIANGLE_LIST,
+    gcvPRIMITIVE_TRIANGLE_STRIP,
+    gcvPRIMITIVE_TRIANGLE_FAN,
+    gcvPRIMITIVE_RECTANGLE,
+}
+gcePRIMITIVE;
+
+/* Index types. */
+typedef enum _gceINDEX_TYPE
+{
+    gcvINDEX_8,
+    gcvINDEX_16,
+    gcvINDEX_32,
+}
+gceINDEX_TYPE;
+
+/******************************************************************************\
+********************************* gcoHAL Object *********************************
+\******************************************************************************/
+
+/* Query the target capabilities. */
+gceSTATUS
+gcoHAL_QueryTargetCaps(
+    IN gcoHAL Hal,
+    OUT gctUINT * MaxWidth,
+    OUT gctUINT * MaxHeight,
+    OUT gctUINT * MultiTargetCount,
+    OUT gctUINT * MaxSamples
+    );
+
+gceSTATUS
+gcoHAL_SetDepthOnly(
+    IN gcoHAL Hal,
+    IN gctBOOL Enable
+    );
+
+gceSTATUS
+gcoHAL_QueryShaderCaps(
+    IN gcoHAL Hal,
+    OUT gctUINT * VertexUniforms,
+    OUT gctUINT * FragmentUniforms,
+    OUT gctUINT * Varyings
+    );
+
+gceSTATUS
+gcoHAL_QueryTextureCaps(
+    IN gcoHAL Hal,
+    OUT gctUINT * MaxWidth,
+    OUT gctUINT * MaxHeight,
+    OUT gctUINT * MaxDepth,
+    OUT gctBOOL * Cubic,
+    OUT gctBOOL * NonPowerOfTwo,
+    OUT gctUINT * VertexSamplers,
+    OUT gctUINT * PixelSamplers
+    );
+
+gceSTATUS
+gcoHAL_QueryTextureMaxAniso(
+    IN gcoHAL Hal,
+    OUT gctUINT * MaxAnisoValue
+    );
+
+gceSTATUS
+gcoHAL_QueryStreamCaps(
+    IN gcoHAL Hal,
+    OUT gctUINT32 * MaxAttributes,
+    OUT gctUINT32 * MaxStreamSize,
+    OUT gctUINT32 * NumberOfStreams,
+    OUT gctUINT32 * Alignment
+    );
+
+/******************************************************************************\
+********************************* gcoSURF Object ********************************
+\******************************************************************************/
+
+/*----------------------------------------------------------------------------*/
+/*--------------------------------- gcoSURF 3D --------------------------------*/
+
+/* Copy surface. */
+gceSTATUS
+gcoSURF_Copy(
+    IN gcoSURF Surface,
+    IN gcoSURF Source
+    );
+
+/* Clear surface. */
+gceSTATUS
+gcoSURF_Clear(
+    IN gcoSURF Surface,
+    IN gctUINT Flags
+    );
+
+/* Set number of samples for a gcoSURF object. */
+gceSTATUS
+gcoSURF_SetSamples(
+    IN gcoSURF Surface,
+    IN gctUINT Samples
+    );
+
+/* Get the number of samples per pixel. */
+gceSTATUS
+gcoSURF_GetSamples(
+    IN gcoSURF Surface,
+    OUT gctUINT_PTR Samples
+    );
+
+/* Clear rectangular surface. */
+gceSTATUS
+gcoSURF_ClearRect(
+    IN gcoSURF Surface,
+    IN gctINT Left,
+    IN gctINT Top,
+    IN gctINT Right,
+    IN gctINT Bottom,
+    IN gctUINT Flags
+    );
+
+/* TO BE REMOVED */
+    gceSTATUS
+    depr_gcoSURF_Resolve(
+        IN gcoSURF SrcSurface,
+        IN gcoSURF DestSurface,
+        IN gctUINT32 DestAddress,
+        IN gctPOINTER DestBits,
+        IN gctINT DestStride,
+        IN gceSURF_TYPE DestType,
+        IN gceSURF_FORMAT DestFormat,
+        IN gctUINT DestWidth,
+        IN gctUINT DestHeight
+        );
+
+    gceSTATUS
+    depr_gcoSURF_ResolveRect(
+        IN gcoSURF SrcSurface,
+        IN gcoSURF DestSurface,
+        IN gctUINT32 DestAddress,
+        IN gctPOINTER DestBits,
+        IN gctINT DestStride,
+        IN gceSURF_TYPE DestType,
+        IN gceSURF_FORMAT DestFormat,
+        IN gctUINT DestWidth,
+        IN gctUINT DestHeight,
+        IN gcsPOINT_PTR SrcOrigin,
+        IN gcsPOINT_PTR DestOrigin,
+        IN gcsPOINT_PTR RectSize
+        );
+
+/* Resample surface. */
+gceSTATUS
+gcoSURF_Resample(
+    IN gcoSURF SrcSurface,
+    IN gcoSURF DestSurface
+    );
+
+/* Resolve surface. */
+gceSTATUS
+gcoSURF_Resolve(
+    IN gcoSURF SrcSurface,
+    IN gcoSURF DestSurface
+    );
+
+/* Export the render target. */
+gceSTATUS
+gcoSURF_ExportRenderTarget(
+    IN gcoSURF SrcSurface
+);
+
+/* Import the render target. */
+gceSTATUS
+gcoSURF_ImportRenderTarget(
+    IN gctUINT32 Pid,
+    IN gcoSURF SrcSurface
+);
+
+/* Save the Resolve info to kernel. */
+gceSTATUS
+gcoSURF_PrepareRemoteResolveRect(
+    IN gcoSURF SrcSurface,
+    IN gcsPOINT_PTR SrcOrigin,
+    IN gcsPOINT_PTR DestOrigin,
+    IN gcsPOINT_PTR RectSize
+    );
+
+/* Resolve using the rectangle info previously saved in the vid mem node. */
+gceSTATUS
+gcoSURF_ResolveFromStoredRect(
+    IN gcoSURF SrcSurface,
+    IN gcoSURF DestSurface
+    );
+
+/* Using the info that Process Pid saved to do resolve. */
+gceSTATUS
+gcoSURF_RemoteResolveRect(
+    IN gcoSURF SrcSurface,
+    IN gcoSURF DestSurface,
+    IN gctBOOL *resolveDiscarded
+    );
+
+/* Return the "resolve submitted indicator" signal. */
+gceSTATUS
+gcoSURF_GetRTSignal(
+    IN gcoSURF RTSurface,
+    OUT gctSIGNAL * resolveSubmittedSignal
+    );
+
+/* Resolve rectangular area of a surface. */
+gceSTATUS
+gcoSURF_ResolveRect(
+    IN gcoSURF SrcSurface,
+    IN gcoSURF DestSurface,
+    IN gcsPOINT_PTR SrcOrigin,
+    IN gcsPOINT_PTR DestOrigin,
+    IN gcsPOINT_PTR RectSize
+    );
+
+/* Set surface resolvability. */
+gceSTATUS
+gcoSURF_SetResolvability(
+    IN gcoSURF Surface,
+    IN gctBOOL Resolvable
+    );
+
+gceSTATUS
+gcoSURF_IsRenderable(
+    IN gcoSURF Surface
+    );
+
+/******************************************************************************\
+******************************** gcoINDEX Object *******************************
+\******************************************************************************/
+
+/* Construct a new gcoINDEX object. */
+gceSTATUS
+gcoINDEX_Construct(
+    IN gcoHAL Hal,
+    OUT gcoINDEX * Index
+    );
+
+/* Destroy a gcoINDEX object. */
+gceSTATUS
+gcoINDEX_Destroy(
+    IN gcoINDEX Index
+    );
+
+/* Lock index in memory. */
+gceSTATUS
+gcoINDEX_Lock(
+    IN gcoINDEX Index,
+    OUT gctUINT32 * Address,
+    OUT gctPOINTER * Memory
+    );
+
+/* Unlock index that was previously locked with gcoINDEX_Lock. */
+gceSTATUS
+gcoINDEX_Unlock(
+    IN gcoINDEX Index
+    );
+
+/* Upload index data into the memory. */
+gceSTATUS
+gcoINDEX_Load(
+    IN gcoINDEX Index,
+    IN gceINDEX_TYPE IndexType,
+    IN gctUINT32 IndexCount,
+    IN gctPOINTER IndexBuffer
+    );
+
+/* Bind an index object to the hardware. */
+gceSTATUS
+gcoINDEX_Bind(
+    IN gcoINDEX Index,
+    IN gceINDEX_TYPE Type
+    );
+
+/* Bind an index object to the hardware. */
+gceSTATUS
+gcoINDEX_BindOffset(
+    IN gcoINDEX Index,
+    IN gceINDEX_TYPE Type,
+    IN gctUINT32 Offset
+    );
+
+/* Free existing index buffer. */
+gceSTATUS
+gcoINDEX_Free(
+    IN gcoINDEX Index
+    );
+
+/* Upload data into an index buffer. */
+gceSTATUS
+gcoINDEX_Upload(
+    IN gcoINDEX Index,
+    IN gctCONST_POINTER Buffer,
+    IN gctSIZE_T Bytes
+    );
+
+/* Upload data into an index buffer starting at an offset. */
+gceSTATUS
+gcoINDEX_UploadOffset(
+    IN gcoINDEX Index,
+    IN gctUINT32 Offset,
+    IN gctCONST_POINTER Buffer,
+    IN gctSIZE_T Bytes
+    );
+
+/* Query the index capabilities. */
+gceSTATUS
+gcoINDEX_QueryCaps(
+    OUT gctBOOL * Index8,
+    OUT gctBOOL * Index16,
+    OUT gctBOOL * Index32,
+    OUT gctUINT * MaxIndex
+    );
+
+/* Determine the index range in the current index buffer. */
+gceSTATUS
+gcoINDEX_GetIndexRange(
+    IN gcoINDEX Index,
+    IN gceINDEX_TYPE Type,
+    IN gctUINT32 Offset,
+    IN gctUINT32 Count,
+    OUT gctUINT32 * MinimumIndex,
+    OUT gctUINT32 * MaximumIndex
+    );
+
+/* Dynamic buffer management. */
+gceSTATUS
+gcoINDEX_SetDynamic(
+    IN gcoINDEX Index,
+    IN gctSIZE_T Bytes,
+    IN gctUINT Buffers
+    );
+
+gceSTATUS
+gcoINDEX_UploadDynamic(
+    IN gcoINDEX Index,
+    IN gctCONST_POINTER Data,
+    IN gctSIZE_T Bytes
+    );
+
+/******************************************************************************\
+********************************** gco3D Object *********************************
+\******************************************************************************/
+
+/* Clear flags. */
+typedef enum _gceCLEAR
+{
+    gcvCLEAR_COLOR              = 0x1,
+    gcvCLEAR_DEPTH              = 0x2,
+    gcvCLEAR_STENCIL            = 0x4,
+    gcvCLEAR_HZ                 = 0x8,
+    gcvCLEAR_HAS_VAA            = 0x10,
+}
+gceCLEAR;
+
+/* Blending targets. */
+typedef enum _gceBLEND_UNIT
+{
+    gcvBLEND_SOURCE,
+    gcvBLEND_TARGET,
+}
+gceBLEND_UNIT;
+
+/* Construct a new gco3D object. */
+gceSTATUS
+gco3D_Construct(
+    IN gcoHAL Hal,
+    OUT gco3D * Engine
+    );
+
+/* Destroy an gco3D object. */
+gceSTATUS
+gco3D_Destroy(
+    IN gco3D Engine
+    );
+
+/* Set 3D API type. */
+gceSTATUS
+gco3D_SetAPI(
+    IN gco3D Engine,
+    IN gceAPI ApiType
+    );
+
+/* Set render target. */
+gceSTATUS
+gco3D_SetTarget(
+    IN gco3D Engine,
+    IN gcoSURF Surface
+    );
+
+/* Unset render target. */
+gceSTATUS
+gco3D_UnsetTarget(
+    IN gco3D Engine,
+    IN gcoSURF Surface
+    );
+
+/* Set depth buffer. */
+gceSTATUS
+gco3D_SetDepth(
+    IN gco3D Engine,
+    IN gcoSURF Surface
+    );
+
+/* Unset depth buffer. */
+gceSTATUS
+gco3D_UnsetDepth(
+    IN gco3D Engine,
+    IN gcoSURF Surface
+    );
+
+/* Set viewport. */
+gceSTATUS
+gco3D_SetViewport(
+    IN gco3D Engine,
+    IN gctINT32 Left,
+    IN gctINT32 Top,
+    IN gctINT32 Right,
+    IN gctINT32 Bottom
+    );
+
+/* Set scissors. */
+gceSTATUS
+gco3D_SetScissors(
+    IN gco3D Engine,
+    IN gctINT32 Left,
+    IN gctINT32 Top,
+    IN gctINT32 Right,
+    IN gctINT32 Bottom
+    );
+
+/* Set clear color. */
+gceSTATUS
+gco3D_SetClearColor(
+    IN gco3D Engine,
+    IN gctUINT8 Red,
+    IN gctUINT8 Green,
+    IN gctUINT8 Blue,
+    IN gctUINT8 Alpha
+    );
+
+/* Set fixed point clear color. */
+gceSTATUS
+gco3D_SetClearColorX(
+    IN gco3D Engine,
+    IN gctFIXED_POINT Red,
+    IN gctFIXED_POINT Green,
+    IN gctFIXED_POINT Blue,
+    IN gctFIXED_POINT Alpha
+    );
+
+/* Set floating point clear color. */
+gceSTATUS
+gco3D_SetClearColorF(
+    IN gco3D Engine,
+    IN gctFLOAT Red,
+    IN gctFLOAT Green,
+    IN gctFLOAT Blue,
+    IN gctFLOAT Alpha
+    );
+
+/* Set fixed point clear depth. */
+gceSTATUS
+gco3D_SetClearDepthX(
+    IN gco3D Engine,
+    IN gctFIXED_POINT Depth
+    );
+
+/* Set floating point clear depth. */
+gceSTATUS
+gco3D_SetClearDepthF(
+    IN gco3D Engine,
+    IN gctFLOAT Depth
+    );
+
+/* Set clear stencil. */
+gceSTATUS
+gco3D_SetClearStencil(
+    IN gco3D Engine,
+    IN gctUINT32 Stencil
+    );
+
+/* Clear a Rect sub-surface. */
+gceSTATUS
+gco3D_ClearRect(
+    IN gco3D Engine,
+    IN gctUINT32 Address,
+    IN gctPOINTER Memory,
+    IN gctUINT32 Stride,
+    IN gceSURF_FORMAT Format,
+    IN gctINT32 Left,
+    IN gctINT32 Top,
+    IN gctINT32 Right,
+    IN gctINT32 Bottom,
+    IN gctUINT32 Width,
+    IN gctUINT32 Height,
+    IN gctUINT32 Flags
+    );
+
+/* Clear surface. */
+gceSTATUS
+gco3D_Clear(
+    IN gco3D Engine,
+    IN gctUINT32 Address,
+    IN gctUINT32 Stride,
+    IN gceSURF_FORMAT Format,
+    IN gctUINT32 Width,
+    IN gctUINT32 Height,
+    IN gctUINT32 Flags
+    );
+
+
+/* Clear tile status. */
+gceSTATUS
+gco3D_ClearTileStatus(
+    IN gco3D Engine,
+    IN gcsSURF_INFO_PTR Surface,
+    IN gctUINT32 TileStatusAddress,
+    IN gctUINT32 Flags
+    );
+
+/* Set shading mode. */
+gceSTATUS
+gco3D_SetShading(
+    IN gco3D Engine,
+    IN gceSHADING Shading
+    );
+
+/* Set blending mode. */
+gceSTATUS
+gco3D_EnableBlending(
+    IN gco3D Engine,
+    IN gctBOOL Enable
+    );
+
+/* Set blending function. */
+gceSTATUS
+gco3D_SetBlendFunction(
+    IN gco3D Engine,
+    IN gceBLEND_UNIT Unit,
+    IN gceBLEND_FUNCTION FunctionRGB,
+    IN gceBLEND_FUNCTION FunctionAlpha
+    );
+
+/* Set blending mode. */
+gceSTATUS
+gco3D_SetBlendMode(
+    IN gco3D Engine,
+    IN gceBLEND_MODE ModeRGB,
+    IN gceBLEND_MODE ModeAlpha
+    );
+
+/* Set blending color. */
+gceSTATUS
+gco3D_SetBlendColor(
+    IN gco3D Engine,
+    IN gctUINT Red,
+    IN gctUINT Green,
+    IN gctUINT Blue,
+    IN gctUINT Alpha
+    );
+
+/* Set fixed point blending color. */
+gceSTATUS
+gco3D_SetBlendColorX(
+    IN gco3D Engine,
+    IN gctFIXED_POINT Red,
+    IN gctFIXED_POINT Green,
+    IN gctFIXED_POINT Blue,
+    IN gctFIXED_POINT Alpha
+    );
+
+/* Set floating point blending color. */
+gceSTATUS
+gco3D_SetBlendColorF(
+    IN gco3D Engine,
+    IN gctFLOAT Red,
+    IN gctFLOAT Green,
+    IN gctFLOAT Blue,
+    IN gctFLOAT Alpha
+    );
+
+/* Set culling mode. */
+gceSTATUS
+gco3D_SetCulling(
+    IN gco3D Engine,
+    IN gceCULL Mode
+    );
+
+/* Enable point size */
+gceSTATUS
+gco3D_SetPointSizeEnable(
+    IN gco3D Engine,
+    IN gctBOOL Enable
+    );
+
+/* Set point sprite */
+gceSTATUS
+gco3D_SetPointSprite(
+    IN gco3D Engine,
+    IN gctBOOL Enable
+    );
+
+/* Set fill mode. */
+gceSTATUS
+gco3D_SetFill(
+    IN gco3D Engine,
+    IN gceFILL Mode
+    );
+
+/* Set depth compare mode. */
+gceSTATUS
+gco3D_SetDepthCompare(
+    IN gco3D Engine,
+    IN gceCOMPARE Compare
+    );
+
+/* Enable depth writing. */
+gceSTATUS
+gco3D_EnableDepthWrite(
+    IN gco3D Engine,
+    IN gctBOOL Enable
+    );
+
+/* Set depth mode. */
+gceSTATUS
+gco3D_SetDepthMode(
+    IN gco3D Engine,
+    IN gceDEPTH_MODE Mode
+    );
+
+/* Set depth range. */
+gceSTATUS
+gco3D_SetDepthRangeX(
+    IN gco3D Engine,
+    IN gceDEPTH_MODE Mode,
+    IN gctFIXED_POINT Near,
+    IN gctFIXED_POINT Far
+    );
+
+/* Set depth range. */
+gceSTATUS
+gco3D_SetDepthRangeF(
+    IN gco3D Engine,
+    IN gceDEPTH_MODE Mode,
+    IN gctFLOAT Near,
+    IN gctFLOAT Far
+    );
+
+/* Set last pixel enable */
+gceSTATUS
+gco3D_SetLastPixelEnable(
+    IN gco3D Engine,
+    IN gctBOOL Enable
+    );
+
+/* Set depth Bias and Scale */
+gceSTATUS
+gco3D_SetDepthScaleBiasX(
+    IN gco3D Engine,
+    IN gctFIXED_POINT DepthScale,
+    IN gctFIXED_POINT DepthBias
+    );
+
+gceSTATUS
+gco3D_SetDepthScaleBiasF(
+    IN gco3D Engine,
+    IN gctFLOAT DepthScale,
+    IN gctFLOAT DepthBias
+    );
+
+/* Enable or disable dithering. */
+gceSTATUS
+gco3D_EnableDither(
+    IN gco3D Engine,
+    IN gctBOOL Enable
+    );
+
+/* Set color write enable bits. */
+gceSTATUS
+gco3D_SetColorWrite(
+    IN gco3D Engine,
+    IN gctUINT8 Enable
+    );
+
+/* Enable or disable early depth. */
+gceSTATUS
+gco3D_SetEarlyDepth(
+    IN gco3D Engine,
+    IN gctBOOL Enable
+    );
+
+/* Enable or disable all early depth operations. */
+gceSTATUS
+gco3D_SetAllEarlyDepthModes(
+    IN gco3D Engine,
+    IN gctBOOL Disable
+    );
+
+/* Enable or disable depth-only mode. */
+gceSTATUS
+gco3D_SetDepthOnly(
+    IN gco3D Engine,
+    IN gctBOOL Enable
+    );
+
+typedef struct _gcsSTENCIL_INFO * gcsSTENCIL_INFO_PTR;
+typedef struct _gcsSTENCIL_INFO
+{
+    gceSTENCIL_MODE         mode;
+
+    gctUINT8                mask;
+    gctUINT8                writeMask;
+
+    gctUINT8                referenceFront;
+
+    gceCOMPARE              compareFront;
+    gceSTENCIL_OPERATION    passFront;
+    gceSTENCIL_OPERATION    failFront;
+    gceSTENCIL_OPERATION    depthFailFront;
+
+    gctUINT8                referenceBack;
+    gceCOMPARE              compareBack;
+    gceSTENCIL_OPERATION    passBack;
+    gceSTENCIL_OPERATION    failBack;
+    gceSTENCIL_OPERATION    depthFailBack;
+}
+gcsSTENCIL_INFO;
+
+/* Set stencil mode. */
+gceSTATUS
+gco3D_SetStencilMode(
+    IN gco3D Engine,
+    IN gceSTENCIL_MODE Mode
+    );
+
+/* Set stencil mask. */
+gceSTATUS
+gco3D_SetStencilMask(
+    IN gco3D Engine,
+    IN gctUINT8 Mask
+    );
+
+/* Set stencil write mask. */
+gceSTATUS
+gco3D_SetStencilWriteMask(
+    IN gco3D Engine,
+    IN gctUINT8 Mask
+    );
+
+/* Set stencil reference. */
+gceSTATUS
+gco3D_SetStencilReference(
+    IN gco3D Engine,
+    IN gctUINT8 Reference,
+    IN gctBOOL Front
+    );
+
+/* Set stencil compare. */
+gceSTATUS
+gco3D_SetStencilCompare(
+    IN gco3D Engine,
+    IN gceSTENCIL_WHERE Where,
+    IN gceCOMPARE Compare
+    );
+
+/* Set stencil operation on pass. */
+gceSTATUS
+gco3D_SetStencilPass(
+    IN gco3D Engine,
+    IN gceSTENCIL_WHERE Where,
+    IN gceSTENCIL_OPERATION Operation
+    );
+
+/* Set stencil operation on fail. */
+gceSTATUS
+gco3D_SetStencilFail(
+    IN gco3D Engine,
+    IN gceSTENCIL_WHERE Where,
+    IN gceSTENCIL_OPERATION Operation
+    );
+
+/* Set stencil operation on depth fail. */
+gceSTATUS
+gco3D_SetStencilDepthFail(
+    IN gco3D Engine,
+    IN gceSTENCIL_WHERE Where,
+    IN gceSTENCIL_OPERATION Operation
+    );
+
+/* Set all stencil states in one blow. */
+gceSTATUS
+gco3D_SetStencilAll(
+    IN gco3D Engine,
+    IN gcsSTENCIL_INFO_PTR Info
+    );
+
+typedef struct _gcsALPHA_INFO * gcsALPHA_INFO_PTR;
+typedef struct _gcsALPHA_INFO
+{
+    /* Alpha test states. */
+    gctBOOL                 test;
+    gceCOMPARE              compare;
+    gctUINT8                reference;
+
+    /* Alpha blending states. */
+    gctBOOL                 blend;
+
+    gceBLEND_FUNCTION       srcFuncColor;
+    gceBLEND_FUNCTION       srcFuncAlpha;
+    gceBLEND_FUNCTION       trgFuncColor;
+    gceBLEND_FUNCTION       trgFuncAlpha;
+
+    gceBLEND_MODE           modeColor;
+    gceBLEND_MODE           modeAlpha;
+
+    gctUINT32               color;
+}
+gcsALPHA_INFO;
+
+/* Enable or disable alpha test. */
+gceSTATUS
+gco3D_SetAlphaTest(
+    IN gco3D Engine,
+    IN gctBOOL Enable
+    );
+
+/* Set alpha test compare. */
+gceSTATUS
+gco3D_SetAlphaCompare(
+    IN gco3D Engine,
+    IN gceCOMPARE Compare
+    );
+
+/* Set alpha test reference in unsigned integer. */
+gceSTATUS
+gco3D_SetAlphaReference(
+    IN gco3D Engine,
+    IN gctUINT8 Reference
+    );
+
+/* Set alpha test reference in fixed point. */
+gceSTATUS
+gco3D_SetAlphaReferenceX(
+    IN gco3D Engine,
+    IN gctFIXED_POINT Reference
+    );
+
+/* Set alpha test reference in floating point. */
+gceSTATUS
+gco3D_SetAlphaReferenceF(
+    IN gco3D Engine,
+    IN gctFLOAT Reference
+    );
+
+/* Enable/Disable anti-alias line. */
+gceSTATUS
+gco3D_SetAntiAliasLine(
+    IN gco3D Engine,
+    IN gctBOOL Enable
+    );
+
+/* Set texture slot for anti-alias line. */
+gceSTATUS
+gco3D_SetAALineTexSlot(
+    IN gco3D Engine,
+    IN gctUINT TexSlot
+    );
+
+/* Set anti-alias line width scale. */
+gceSTATUS
+gco3D_SetAALineWidth(
+    IN gco3D Engine,
+    IN gctFLOAT Width
+    );
+
+/* Draw a number of primitives. */
+gceSTATUS
+gco3D_DrawPrimitives(
+    IN gco3D Engine,
+    IN gcePRIMITIVE Type,
+    IN gctINT StartVertex,
+    IN gctSIZE_T PrimitiveCount
+    );
+
+gceSTATUS
+gco3D_DrawPrimitivesCount(
+    IN gco3D Engine,
+    IN gcePRIMITIVE Type,
+    IN gctINT* StartVertex,
+    IN gctSIZE_T* VertexCount,
+    IN gctSIZE_T PrimitiveCount
+    );
+
+
+/* Draw a number of primitives using offsets. */
+gceSTATUS
+gco3D_DrawPrimitivesOffset(
+    IN gco3D Engine,
+    IN gcePRIMITIVE Type,
+    IN gctINT32 StartOffset,
+    IN gctSIZE_T PrimitiveCount
+    );
+
+/* Draw a number of indexed primitives. */
+gceSTATUS
+gco3D_DrawIndexedPrimitives(
+    IN gco3D Engine,
+    IN gcePRIMITIVE Type,
+    IN gctINT BaseVertex,
+    IN gctINT StartIndex,
+    IN gctSIZE_T PrimitiveCount
+    );
+
+/* Draw a number of indexed primitives using offsets. */
+gceSTATUS
+gco3D_DrawIndexedPrimitivesOffset(
+    IN gco3D Engine,
+    IN gcePRIMITIVE Type,
+    IN gctINT32 BaseOffset,
+    IN gctINT32 StartOffset,
+    IN gctSIZE_T PrimitiveCount
+    );
+
+/* Enable or disable anti-aliasing. */
+gceSTATUS
+gco3D_SetAntiAlias(
+    IN gco3D Engine,
+    IN gctBOOL Enable
+    );
+
+/* Write data into the command buffer. */
+gceSTATUS
+gco3D_WriteBuffer(
+    IN gco3D Engine,
+    IN gctCONST_POINTER Data,
+    IN gctSIZE_T Bytes,
+    IN gctBOOL Aligned
+    );
+
+/* Send sempahore and stall until sempahore is signalled. */
+gceSTATUS
+gco3D_Semaphore(
+    IN gco3D Engine,
+    IN gceWHERE From,
+    IN gceWHERE To,
+    IN gceHOW How);
+
+/* Set the subpixels center. */
+gceSTATUS
+gco3D_SetCentroids(
+    IN gco3D Engine,
+    IN gctUINT32 Index,
+    IN gctPOINTER Centroids
+    );
+
+gceSTATUS
+gco3D_SetLogicOp(
+    IN gco3D Engine,
+    IN gctUINT8 Rop
+    );
+
+/* OCL thread walker information. */
+typedef struct _gcsTHREAD_WALKER_INFO * gcsTHREAD_WALKER_INFO_PTR;
+typedef struct _gcsTHREAD_WALKER_INFO
+{
+    gctUINT32   dimensions;
+    gctUINT32   traverseOrder;
+    gctUINT32   enableSwathX;
+    gctUINT32   enableSwathY;
+    gctUINT32   enableSwathZ;
+    gctUINT32   swathSizeX;
+    gctUINT32   swathSizeY;
+    gctUINT32   swathSizeZ;
+    gctUINT32   valueOrder;
+
+    gctUINT32   globalSizeX;
+    gctUINT32   globalOffsetX;
+    gctUINT32   globalSizeY;
+    gctUINT32   globalOffsetY;
+    gctUINT32   globalSizeZ;
+    gctUINT32   globalOffsetZ;
+
+    gctUINT32   workGroupSizeX;
+    gctUINT32   workGroupCountX;
+    gctUINT32   workGroupSizeY;
+    gctUINT32   workGroupCountY;
+    gctUINT32   workGroupSizeZ;
+    gctUINT32   workGroupCountZ;
+
+    gctUINT32   threadAllocation;
+}
+gcsTHREAD_WALKER_INFO;
+
+/* Start OCL thread walker. */
+gceSTATUS
+gco3D_InvokeThreadWalker(
+    IN gco3D Engine,
+    IN gcsTHREAD_WALKER_INFO_PTR Info
+    );
+
+/*----------------------------------------------------------------------------*/
+/*-------------------------- gco3D Fragment Processor ------------------------*/
+
+/* Set the fragment processor configuration. */
+gceSTATUS
+gco3D_SetFragmentConfiguration(
+    IN gco3D Engine,
+    IN gctBOOL ColorFromStream,
+    IN gctBOOL EnableFog,
+    IN gctBOOL EnableSmoothPoint,
+    IN gctUINT32 ClipPlanes
+    );
+
+/* Enable/disable texture stage operation. */
+gceSTATUS
+gco3D_EnableTextureStage(
+    IN gco3D Engine,
+    IN gctINT Stage,
+    IN gctBOOL Enable
+    );
+
+/* Program the channel enable masks for the color texture function. */
+gceSTATUS
+gco3D_SetTextureColorMask(
+    IN gco3D Engine,
+    IN gctINT Stage,
+    IN gctBOOL ColorEnabled,
+    IN gctBOOL AlphaEnabled
+    );
+
+/* Program the channel enable masks for the alpha texture function. */
+gceSTATUS
+gco3D_SetTextureAlphaMask(
+    IN gco3D Engine,
+    IN gctINT Stage,
+    IN gctBOOL ColorEnabled,
+    IN gctBOOL AlphaEnabled
+    );
+
+/* Program the constant fragment color. */
+gceSTATUS
+gco3D_SetFragmentColorX(
+    IN gco3D Engine,
+    IN gctFIXED_POINT Red,
+    IN gctFIXED_POINT Green,
+    IN gctFIXED_POINT Blue,
+    IN gctFIXED_POINT Alpha
+    );
+
+gceSTATUS
+gco3D_SetFragmentColorF(
+    IN gco3D Engine,
+    IN gctFLOAT Red,
+    IN gctFLOAT Green,
+    IN gctFLOAT Blue,
+    IN gctFLOAT Alpha
+    );
+
+/* Program the constant fog color. */
+gceSTATUS
+gco3D_SetFogColorX(
+    IN gco3D Engine,
+    IN gctFIXED_POINT Red,
+    IN gctFIXED_POINT Green,
+    IN gctFIXED_POINT Blue,
+    IN gctFIXED_POINT Alpha
+    );
+
+gceSTATUS
+gco3D_SetFogColorF(
+    IN gco3D Engine,
+    IN gctFLOAT Red,
+    IN gctFLOAT Green,
+    IN gctFLOAT Blue,
+    IN gctFLOAT Alpha
+    );
+
+/* Program the constant texture color. */
+gceSTATUS
+gco3D_SetTetxureColorX(
+    IN gco3D Engine,
+    IN gctINT Stage,
+    IN gctFIXED_POINT Red,
+    IN gctFIXED_POINT Green,
+    IN gctFIXED_POINT Blue,
+    IN gctFIXED_POINT Alpha
+    );
+
+gceSTATUS
+gco3D_SetTetxureColorF(
+    IN gco3D Engine,
+    IN gctINT Stage,
+    IN gctFLOAT Red,
+    IN gctFLOAT Green,
+    IN gctFLOAT Blue,
+    IN gctFLOAT Alpha
+    );
+
+/* Configure color texture function. */
+gceSTATUS
+gco3D_SetColorTextureFunction(
+    IN gco3D Engine,
+    IN gctINT Stage,
+    IN gceTEXTURE_FUNCTION Function,
+    IN gceTEXTURE_SOURCE Source0,
+    IN gceTEXTURE_CHANNEL Channel0,
+    IN gceTEXTURE_SOURCE Source1,
+    IN gceTEXTURE_CHANNEL Channel1,
+    IN gceTEXTURE_SOURCE Source2,
+    IN gceTEXTURE_CHANNEL Channel2,
+    IN gctINT Scale
+    );
+
+/* Configure alpha texture function. */
+gceSTATUS
+gco3D_SetAlphaTextureFunction(
+    IN gco3D Engine,
+    IN gctINT Stage,
+    IN gceTEXTURE_FUNCTION Function,
+    IN gceTEXTURE_SOURCE Source0,
+    IN gceTEXTURE_CHANNEL Channel0,
+    IN gceTEXTURE_SOURCE Source1,
+    IN gceTEXTURE_CHANNEL Channel1,
+    IN gceTEXTURE_SOURCE Source2,
+    IN gceTEXTURE_CHANNEL Channel2,
+    IN gctINT Scale
+    );
+
+/* Invoke OCL thread walker. */
+gceSTATUS
+gcoHARDWARE_InvokeThreadWalker(
+    IN gcsTHREAD_WALKER_INFO_PTR Info
+    );
+
+/******************************************************************************\
+******************************* gcoTEXTURE Object *******************************
+\******************************************************************************/
+
+/* Cube faces. */
+typedef enum _gceTEXTURE_FACE
+{
+    gcvFACE_NONE,
+    gcvFACE_POSITIVE_X,
+    gcvFACE_NEGATIVE_X,
+    gcvFACE_POSITIVE_Y,
+    gcvFACE_NEGATIVE_Y,
+    gcvFACE_POSITIVE_Z,
+    gcvFACE_NEGATIVE_Z,
+}
+gceTEXTURE_FACE;
+
+typedef struct _gcsTEXTURE
+{
+    /* Addressing modes. */
+    gceTEXTURE_ADDRESSING       s;
+    gceTEXTURE_ADDRESSING       t;
+    gceTEXTURE_ADDRESSING       r;
+
+    /* Border color. */
+    gctUINT8                    border[4];
+
+    /* Filters. */
+    gceTEXTURE_FILTER           minFilter;
+    gceTEXTURE_FILTER           magFilter;
+    gceTEXTURE_FILTER           mipFilter;
+    gctUINT                     anisoFilter;
+
+    /* Level of detail. */
+    gctFIXED_POINT              lodBias;
+    gctFIXED_POINT              lodMin;
+    gctFIXED_POINT              lodMax;
+}
+gcsTEXTURE, * gcsTEXTURE_PTR;
+
+/* Construct a new gcoTEXTURE object. */
+gceSTATUS
+gcoTEXTURE_Construct(
+    IN gcoHAL Hal,
+    OUT gcoTEXTURE * Texture
+    );
+
+/* Construct a new sized gcoTEXTURE object. */
+gceSTATUS
+gcoTEXTURE_ConstructSized(
+    IN gcoHAL Hal,
+    IN gceSURF_FORMAT Format,
+    IN gctUINT Width,
+    IN gctUINT Height,
+    IN gctUINT Depth,
+    IN gctUINT Faces,
+    IN gctUINT MipMapCount,
+    IN gcePOOL Pool,
+    OUT gcoTEXTURE * Texture
+    );
+
+/* Destroy an gcoTEXTURE object. */
+gceSTATUS
+gcoTEXTURE_Destroy(
+    IN gcoTEXTURE Texture
+    );
+
+/* Upload data to an gcoTEXTURE object. */
+gceSTATUS
+gcoTEXTURE_Upload(
+    IN gcoTEXTURE Texture,
+    IN gceTEXTURE_FACE Face,
+    IN gctUINT Width,
+    IN gctUINT Height,
+    IN gctUINT Slice,
+    IN gctCONST_POINTER Memory,
+    IN gctINT Stride,
+    IN gceSURF_FORMAT Format
+    );
+
+/* Upload data to an gcoTEXTURE object. */
+gceSTATUS
+gcoTEXTURE_UploadSub(
+    IN gcoTEXTURE Texture,
+    IN gctUINT MipMap,
+    IN gceTEXTURE_FACE Face,
+    IN gctUINT X,
+    IN gctUINT Y,
+    IN gctUINT Width,
+    IN gctUINT Height,
+    IN gctUINT Slice,
+    IN gctCONST_POINTER Memory,
+    IN gctINT Stride,
+    IN gceSURF_FORMAT Format
+    );
+
+/* Upload compressed data to an gcoTEXTURE object. */
+gceSTATUS
+gcoTEXTURE_UploadCompressed(
+    IN gcoTEXTURE Texture,
+    IN gceTEXTURE_FACE Face,
+    IN gctUINT Width,
+    IN gctUINT Height,
+    IN gctUINT Slice,
+    IN gctCONST_POINTER Memory,
+    IN gctSIZE_T Bytes
+    );
+
+/* Get gcoSURF object for a mipmap level. */
+gceSTATUS
+gcoTEXTURE_GetMipMap(
+    IN gcoTEXTURE Texture,
+    IN gctUINT MipMap,
+    OUT gcoSURF * Surface
+    );
+
+/* Get gcoSURF object for a mipmap level and face offset. */
+gceSTATUS
+gcoTEXTURE_GetMipMapFace(
+    IN gcoTEXTURE Texture,
+    IN gctUINT MipMap,
+    IN gceTEXTURE_FACE Face,
+    OUT gcoSURF * Surface,
+    OUT gctUINT32_PTR Offset
+    );
+
+gceSTATUS
+gcoTEXTURE_AddMipMap(
+    IN gcoTEXTURE Texture,
+    IN gctINT Level,
+    IN gceSURF_FORMAT Format,
+    IN gctUINT Width,
+    IN gctUINT Height,
+    IN gctUINT Depth,
+    IN gctUINT Faces,
+    IN gcePOOL Pool,
+    OUT gcoSURF * Surface
+    );
+
+gceSTATUS
+gcoTEXTURE_AddMipMapFromClient(
+    IN gcoTEXTURE Texture,
+    IN gctINT     Level,
+    IN gcoSURF    Surface
+    );
+
+gceSTATUS
+gcoTEXTURE_AddMipMapFromSurface(
+    IN gcoTEXTURE Texture,
+    IN gctINT     Level,
+    IN gcoSURF    Surface
+    );
+
+gceSTATUS
+gcoTEXTURE_SetEndianHint(
+    IN gcoTEXTURE Texture,
+    IN gceENDIAN_HINT EndianHint
+    );
+
+gceSTATUS
+gcoTEXTURE_Disable(
+    IN gcoHAL Hal,
+    IN gctINT Sampler
+    );
+
+gceSTATUS
+gcoTEXTURE_Flush(
+    IN gcoTEXTURE Texture
+    );
+
+gceSTATUS
+gcoTEXTURE_QueryCaps(
+    IN  gcoHAL    Hal,
+    OUT gctUINT * MaxWidth,
+    OUT gctUINT * MaxHeight,
+    OUT gctUINT * MaxDepth,
+    OUT gctBOOL * Cubic,
+    OUT gctBOOL * NonPowerOfTwo,
+    OUT gctUINT * VertexSamplers,
+    OUT gctUINT * PixelSamplers
+    );
+
+gceSTATUS
+gcoTEXTURE_GetClosestFormat(
+    IN gcoHAL Hal,
+    IN gceSURF_FORMAT InFormat,
+    OUT gceSURF_FORMAT* OutFormat
+    );
+
+gceSTATUS
+gcoTEXTURE_RenderIntoMipMap(
+    IN gcoTEXTURE Texture,
+    IN gctINT Level
+    );
+
+gceSTATUS
+gcoTEXTURE_IsRenderable(
+    IN gcoTEXTURE Texture,
+    IN gctUINT Level
+    );
+
+gceSTATUS
+gcoTEXTURE_IsComplete(
+    IN gcoTEXTURE Texture,
+    IN gctINT MaxLevel
+    );
+
+gceSTATUS
+gcoTEXTURE_BindTexture(
+    IN gcoTEXTURE Texture,
+    IN gctINT Target,
+    IN gctINT Sampler,
+    IN gcsTEXTURE_PTR Info
+    );
+
+/******************************************************************************\
+******************************* gcoSTREAM Object ******************************
+\******************************************************************************/
+
+typedef enum _gceVERTEX_FORMAT
+{
+    gcvVERTEX_BYTE,
+    gcvVERTEX_UNSIGNED_BYTE,
+    gcvVERTEX_SHORT,
+    gcvVERTEX_UNSIGNED_SHORT,
+    gcvVERTEX_INT,
+    gcvVERTEX_UNSIGNED_INT,
+    gcvVERTEX_FIXED,
+    gcvVERTEX_HALF,
+    gcvVERTEX_FLOAT,
+    gcvVERTEX_UNSIGNED_INT_10_10_10_2,
+    gcvVERTEX_INT_10_10_10_2,
+}
+gceVERTEX_FORMAT;
+
+gceSTATUS
+gcoSTREAM_Construct(
+    IN gcoHAL Hal,
+    OUT gcoSTREAM * Stream
+    );
+
+gceSTATUS
+gcoSTREAM_Destroy(
+    IN gcoSTREAM Stream
+    );
+
+gceSTATUS
+gcoSTREAM_Upload(
+    IN gcoSTREAM Stream,
+    IN gctCONST_POINTER Buffer,
+    IN gctUINT32 Offset,
+    IN gctSIZE_T Bytes,
+    IN gctBOOL Dynamic
+    );
+
+gceSTATUS
+gcoSTREAM_SetStride(
+    IN gcoSTREAM Stream,
+    IN gctUINT32 Stride
+    );
+
+gceSTATUS
+gcoSTREAM_Lock(
+    IN gcoSTREAM Stream,
+    OUT gctPOINTER * Logical,
+    OUT gctUINT32 * Physical
+    );
+
+gceSTATUS
+gcoSTREAM_Unlock(
+    IN gcoSTREAM Stream
+    );
+
+gceSTATUS
+gcoSTREAM_Reserve(
+    IN gcoSTREAM Stream,
+    IN gctSIZE_T Bytes
+    );
+
+gceSTATUS
+gcoSTREAM_Flush(
+    IN gcoSTREAM Stream
+    );
+
+/* Dynamic buffer API. */
+gceSTATUS
+gcoSTREAM_SetDynamic(
+    IN gcoSTREAM Stream,
+    IN gctSIZE_T Bytes,
+    IN gctUINT Buffers
+    );
+
+typedef struct _gcsSTREAM_INFO
+{
+    gctUINT             index;
+    gceVERTEX_FORMAT    format;
+    gctBOOL             normalized;
+    gctUINT             components;
+    gctSIZE_T           size;
+    gctCONST_POINTER    data;
+    gctUINT             stride;
+}
+gcsSTREAM_INFO, * gcsSTREAM_INFO_PTR;
+
+gceSTATUS
+gcoSTREAM_UploadDynamic(
+    IN gcoSTREAM Stream,
+    IN gctUINT VertexCount,
+    IN gctUINT InfoCount,
+    IN gcsSTREAM_INFO_PTR Info,
+    IN gcoVERTEX Vertex
+    );
+
+gceSTATUS
+gcoSTREAM_CPUCacheOperation(
+    IN gcoSTREAM Stream,
+    IN gceCACHEOPERATION Operation
+    );
+
+/******************************************************************************\
+******************************** gcoVERTEX Object ******************************
+\******************************************************************************/
+
+typedef struct _gcsVERTEX_ATTRIBUTES
+{
+    gceVERTEX_FORMAT            format;
+    gctBOOL                     normalized;
+    gctUINT32                   components;
+    gctSIZE_T                   size;
+    gctUINT32                   stream;
+    gctUINT32                   offset;
+    gctUINT32                   stride;
+}
+gcsVERTEX_ATTRIBUTES;
+
+gceSTATUS
+gcoVERTEX_Construct(
+    IN gcoHAL Hal,
+    OUT gcoVERTEX * Vertex
+    );
+
+gceSTATUS
+gcoVERTEX_Destroy(
+    IN gcoVERTEX Vertex
+    );
+
+gceSTATUS
+gcoVERTEX_Reset(
+    IN gcoVERTEX Vertex
+    );
+
+gceSTATUS
+gcoVERTEX_EnableAttribute(
+    IN gcoVERTEX Vertex,
+    IN gctUINT32 Index,
+    IN gceVERTEX_FORMAT Format,
+    IN gctBOOL Normalized,
+    IN gctUINT32 Components,
+    IN gcoSTREAM Stream,
+    IN gctUINT32 Offset,
+    IN gctUINT32 Stride
+    );
+
+gceSTATUS
+gcoVERTEX_DisableAttribute(
+    IN gcoVERTEX Vertex,
+    IN gctUINT32 Index
+    );
+
+gceSTATUS
+gcoVERTEX_Bind(
+    IN gcoVERTEX Vertex
+    );
+
+/*******************************************************************************
+***** gcoVERTEXARRAY Object ***************************************************/
+
+typedef struct _gcsVERTEXARRAY
+{
+    /* Enabled. */
+    gctBOOL             enable;
+
+    /* Number of components. */
+    gctINT              size;
+
+    /* Attribute format. */
+    gceVERTEX_FORMAT    format;
+
+    /* Flag whether the attribute is normalized or not. */
+    gctBOOL             normalized;
+
+    /* Stride of the component. */
+    gctUINT             stride;
+
+    /* Pointer to the attribute data. */
+    gctCONST_POINTER    pointer;
+
+    /* Stream object owning the attribute data. */
+    gcoSTREAM           stream;
+
+    /* Generic values for attribute. */
+    gctFLOAT            genericValue[4];
+
+    /* Vertex shader linkage. */
+    gctUINT             linkage;
+}
+gcsVERTEXARRAY,
+* gcsVERTEXARRAY_PTR;
+
+gceSTATUS
+gcoVERTEXARRAY_Construct(
+    IN gcoHAL Hal,
+    OUT gcoVERTEXARRAY * Vertex
+    );
+
+gceSTATUS
+gcoVERTEXARRAY_Destroy(
+    IN gcoVERTEXARRAY Vertex
+    );
+
+gceSTATUS
+gcoVERTEXARRAY_Bind(
+    IN gcoVERTEXARRAY Vertex,
+    IN gctUINT32 EnableBits,
+    IN gcsVERTEXARRAY_PTR VertexArray,
+    IN gctUINT First,
+    IN gctSIZE_T Count,
+    IN gceINDEX_TYPE IndexType,
+    IN gcoINDEX IndexObject,
+    IN gctPOINTER IndexMemory,
+    IN OUT gcePRIMITIVE * PrimitiveType,
+    IN OUT gctUINT * PrimitiveCount
+    );
+
+/*******************************************************************************
+***** Composition *************************************************************/
+
+typedef enum _gceCOMPOSITION
+{
+    gcvCOMPOSE_CLEAR = 1,
+    gcvCOMPOSE_BLUR,
+    gcvCOMPOSE_DIM,
+    gcvCOMPOSE_LAYER
+}
+gceCOMPOSITION;
+
+typedef struct _gcsCOMPOSITION * gcsCOMPOSITION_PTR;
+typedef struct _gcsCOMPOSITION
+{
+    /* Structure size. */
+    gctUINT                         structSize;
+
+    /* Composition operation. */
+    gceCOMPOSITION                  operation;
+
+    /* Layer to be composed. */
+    gcoSURF                         layer;
+
+    /* Source and target coordinates. */
+    gcsRECT                         srcRect;
+    gcsRECT                         trgRect;
+
+    /* Target rectangle */
+    gcsPOINT                        v0;
+    gcsPOINT                        v1;
+    gcsPOINT                        v2;
+
+    /* Blending parameters. */
+    gctBOOL                         enableBlending;
+    gctBOOL                         premultiplied;
+    gctUINT8                        alphaValue;
+
+    /* Clear color. */
+    gctFLOAT                        r;
+    gctFLOAT                        g;
+    gctFLOAT                        b;
+    gctFLOAT                        a;
+}
+gcsCOMPOSITION;
+
+gceSTATUS
+gco3D_ProbeComposition(
+    gctBOOL ResetIfEmpty
+    );
+
+gceSTATUS
+gco3D_CompositionBegin(
+    void
+    );
+
+gceSTATUS
+gco3D_ComposeLayer(
+    IN gcsCOMPOSITION_PTR Layer
+    );
+
+gceSTATUS
+gco3D_CompositionSignals(
+    IN gctHANDLE Process,
+    IN gctSIGNAL Signal1,
+    IN gctSIGNAL Signal2
+    );
+
+gceSTATUS
+gco3D_CompositionEnd(
+    IN gcoSURF Target,
+    IN gctBOOL Synchronous
+    );
+
+/* Frame Database */
+gceSTATUS
+gcoHAL_AddFrameDB(
+    void
+    );
+
+gceSTATUS
+gcoHAL_DumpFrameDB(
+    gctCONST_STRING Filename OPTIONAL
+    );
+
+gceSTATUS
+gcoHAL_GetSharedInfo(
+    IN gctUINT32 Pid,
+    IN gctUINT32 DataId,
+    OUT gctUINT8_PTR Data,
+    IN gctSIZE_T Bytes,
+    IN gcuVIDMEM_NODE_PTR Node,
+    OUT gctUINT8_PTR NodeData,
+    IN gceVIDMEM_NODE_SHARED_INFO_TYPE SharedInfoType
+    );
+
+gceSTATUS
+gcoHAL_SetSharedInfo(
+    IN gctUINT32 DataId,
+    IN gctUINT8_PTR Data,
+    IN gctSIZE_T Bytes,
+    IN gcuVIDMEM_NODE_PTR Node,
+    IN gctUINT8_PTR NodeData,
+    IN gceVIDMEM_NODE_SHARED_INFO_TYPE SharedInfoType
+    );
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* VIVANTE_NO_3D */
+#endif /* __gc_hal_engine_h_ */
diff --git a/attic/gc_hal_engine_vg.h b/attic/gc_hal_engine_vg.h
new file mode 100644
index 0000000..571e03e
--- /dev/null
+++ b/attic/gc_hal_engine_vg.h
@@ -0,0 +1,908 @@
+/****************************************************************************
+*
+*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*
+*    This program is free software; you can redistribute it and/or modify
+*    it under the terms of the GNU General Public License as published by
+*    the Free Software Foundation; either version 2 of the license, or
+*    (at your option) any later version.
+*
+*    This program is distributed in the hope that it will be useful,
+*    but WITHOUT ANY WARRANTY; without even the implied warranty of
+*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+*    GNU General Public License for more details.
+*
+*    You should have received a copy of the GNU General Public License
+*    along with this program; if not write to the Free Software
+*    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*
+*****************************************************************************/
+
+
+
+
+
+
+#ifndef __gc_hal_engine_vg_h_
+#define __gc_hal_engine_vg_h_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include "gc_hal_types.h"
+
+/******************************************************************************\
+******************************** VG Enumerations *******************************
+\******************************************************************************/
+
+/**
+**  @ingroup gcoVG
+**
+**  @brief  Tiling mode for painting and imagig.
+**
+**  This enumeration defines the tiling modes supported by the HAL.  This is
+**  in fact a one-to-one mapping of the OpenVG 1.1 tile modes.
+*/
+typedef enum _gceTILE_MODE
+{
+    gcvTILE_FILL,
+    gcvTILE_PAD,
+    gcvTILE_REPEAT,
+    gcvTILE_REFLECT
+}
+gceTILE_MODE;
+
+/******************************************************************************/
+/** @ingroup gcoVG
+**
+**  @brief  The different paint modes.
+**
+**  This enumeration lists the available paint modes.
+*/
+typedef enum _gcePAINT_TYPE
+{
+    /** Solid color. */
+    gcvPAINT_MODE_SOLID,
+
+    /** Linear gradient. */
+    gcvPAINT_MODE_LINEAR,
+
+    /** Radial gradient. */
+    gcvPAINT_MODE_RADIAL,
+
+    /** Pattern. */
+    gcvPAINT_MODE_PATTERN,
+
+    /** Mode count. */
+    gcvPAINT_MODE_COUNT
+}
+gcePAINT_TYPE;
+
+/**
+** @ingroup gcoVG
+**
+**  @brief Types of path data supported by HAL.
+**
+**  This enumeration defines the types of path data supported by the HAL.
+**  This is in fact a one-to-one mapping of the OpenVG 1.1 path types.
+*/
+typedef enum _gcePATHTYPE
+{
+    gcePATHTYPE_UNKNOWN = -1,
+    gcePATHTYPE_INT8,
+    gcePATHTYPE_INT16,
+    gcePATHTYPE_INT32,
+    gcePATHTYPE_FLOAT
+}
+gcePATHTYPE;
+
+/**
+** @ingroup gcoVG
+**
+**  @brief Supported path segment commands.
+**
+**  This enumeration defines the path segment commands supported by the HAL.
+*/
+typedef enum _gceVGCMD
+{
+    gcvVGCMD_END,                        /*  0: GCCMD_TS_OPCODE_END           */
+    gcvVGCMD_CLOSE,                      /*  1: GCCMD_TS_OPCODE_CLOSE         */
+    gcvVGCMD_MOVE,                       /*  2: GCCMD_TS_OPCODE_MOVE          */
+    gcvVGCMD_MOVE_REL,                   /*  3: GCCMD_TS_OPCODE_MOVE_REL      */
+    gcvVGCMD_LINE,                       /*  4: GCCMD_TS_OPCODE_LINE          */
+    gcvVGCMD_LINE_REL,                   /*  5: GCCMD_TS_OPCODE_LINE_REL      */
+    gcvVGCMD_QUAD,                       /*  6: GCCMD_TS_OPCODE_QUADRATIC     */
+    gcvVGCMD_QUAD_REL,                   /*  7: GCCMD_TS_OPCODE_QUADRATIC_REL */
+    gcvVGCMD_CUBIC,                      /*  8: GCCMD_TS_OPCODE_CUBIC         */
+    gcvVGCMD_CUBIC_REL,                  /*  9: GCCMD_TS_OPCODE_CUBIC_REL     */
+    gcvVGCMD_BREAK,                      /* 10: GCCMD_TS_OPCODE_BREAK         */
+    gcvVGCMD_HLINE,                      /* 11: ******* R E S E R V E D *******/
+    gcvVGCMD_HLINE_REL,                  /* 12: ******* R E S E R V E D *******/
+    gcvVGCMD_VLINE,                      /* 13: ******* R E S E R V E D *******/
+    gcvVGCMD_VLINE_REL,                  /* 14: ******* R E S E R V E D *******/
+    gcvVGCMD_SQUAD,                      /* 15: ******* R E S E R V E D *******/
+    gcvVGCMD_SQUAD_REL,                  /* 16: ******* R E S E R V E D *******/
+    gcvVGCMD_SCUBIC,                     /* 17: ******* R E S E R V E D *******/
+    gcvVGCMD_SCUBIC_REL,                 /* 18: ******* R E S E R V E D *******/
+    gcvVGCMD_SCCWARC,                    /* 19: ******* R E S E R V E D *******/
+    gcvVGCMD_SCCWARC_REL,                /* 20: ******* R E S E R V E D *******/
+    gcvVGCMD_SCWARC,                     /* 21: ******* R E S E R V E D *******/
+    gcvVGCMD_SCWARC_REL,                 /* 22: ******* R E S E R V E D *******/
+    gcvVGCMD_LCCWARC,                    /* 23: ******* R E S E R V E D *******/
+    gcvVGCMD_LCCWARC_REL,                /* 24: ******* R E S E R V E D *******/
+    gcvVGCMD_LCWARC,                     /* 25: ******* R E S E R V E D *******/
+    gcvVGCMD_LCWARC_REL,                 /* 26: ******* R E S E R V E D *******/
+
+    /* The width of the command recognized by the hardware on bits. */
+    gcvVGCMD_WIDTH = 5,
+
+    /* Hardware command mask. */
+    gcvVGCMD_MASK = (1 << gcvVGCMD_WIDTH) - 1,
+
+    /* Command modifiers. */
+    gcvVGCMD_H_MOD   = 1 << gcvVGCMD_WIDTH,  /* =  32 */
+    gcvVGCMD_V_MOD   = 2 << gcvVGCMD_WIDTH,  /* =  64 */
+    gcvVGCMD_S_MOD   = 3 << gcvVGCMD_WIDTH,  /* =  96 */
+    gcvVGCMD_ARC_MOD = 4 << gcvVGCMD_WIDTH,  /* = 128 */
+
+    /* Emulated LINE commands. */
+    gcvVGCMD_HLINE_EMUL     = gcvVGCMD_H_MOD | gcvVGCMD_LINE,        /* =  36 */
+    gcvVGCMD_HLINE_EMUL_REL = gcvVGCMD_H_MOD | gcvVGCMD_LINE_REL,    /* =  37 */
+    gcvVGCMD_VLINE_EMUL     = gcvVGCMD_V_MOD | gcvVGCMD_LINE,        /* =  68 */
+    gcvVGCMD_VLINE_EMUL_REL = gcvVGCMD_V_MOD | gcvVGCMD_LINE_REL,    /* =  69 */
+
+    /* Emulated SMOOTH commands. */
+    gcvVGCMD_SQUAD_EMUL      = gcvVGCMD_S_MOD | gcvVGCMD_QUAD,       /* = 102 */
+    gcvVGCMD_SQUAD_EMUL_REL  = gcvVGCMD_S_MOD | gcvVGCMD_QUAD_REL,   /* = 103 */
+    gcvVGCMD_SCUBIC_EMUL     = gcvVGCMD_S_MOD | gcvVGCMD_CUBIC,      /* = 104 */
+    gcvVGCMD_SCUBIC_EMUL_REL = gcvVGCMD_S_MOD | gcvVGCMD_CUBIC_REL,  /* = 105 */
+
+    /* Emulation ARC commands. */
+    gcvVGCMD_ARC_LINE     = gcvVGCMD_ARC_MOD | gcvVGCMD_LINE,        /* = 132 */
+    gcvVGCMD_ARC_LINE_REL = gcvVGCMD_ARC_MOD | gcvVGCMD_LINE_REL,    /* = 133 */
+    gcvVGCMD_ARC_QUAD     = gcvVGCMD_ARC_MOD | gcvVGCMD_QUAD,        /* = 134 */
+    gcvVGCMD_ARC_QUAD_REL = gcvVGCMD_ARC_MOD | gcvVGCMD_QUAD_REL     /* = 135 */
+}
+gceVGCMD;
+typedef enum _gceVGCMD * gceVGCMD_PTR;
+
+/**
+**  @ingroup gcoVG
+**
+**  @brief  Blending modes supported by the HAL.
+**
+**  This enumeration defines the blending modes supported by the HAL.  This is
+**  in fact a one-to-one mapping of the OpenVG 1.1 blending modes.
+*/
+typedef enum _gceVG_BLEND
+{
+    gcvVG_BLEND_SRC,
+    gcvVG_BLEND_SRC_OVER,
+    gcvVG_BLEND_DST_OVER,
+    gcvVG_BLEND_SRC_IN,
+    gcvVG_BLEND_DST_IN,
+    gcvVG_BLEND_MULTIPLY,
+    gcvVG_BLEND_SCREEN,
+    gcvVG_BLEND_DARKEN,
+    gcvVG_BLEND_LIGHTEN,
+    gcvVG_BLEND_ADDITIVE,
+    gcvVG_BLEND_SUBTRACT,
+    gcvVG_BLEND_FILTER
+}
+gceVG_BLEND;
+
+/**
+**  @ingroup gcoVG
+**
+**  @brief  Image modes supported by the HAL.
+**
+**  This enumeration defines the image modes supported by the HAL.  This is
+**  in fact a one-to-one mapping of the OpenVG 1.1 image modes with the addition
+**  of NO IMAGE.
+*/
+typedef enum _gceVG_IMAGE
+{
+    gcvVG_IMAGE_NONE,
+    gcvVG_IMAGE_NORMAL,
+    gcvVG_IMAGE_MULTIPLY,
+    gcvVG_IMAGE_STENCIL,
+    gcvVG_IMAGE_FILTER
+}
+gceVG_IMAGE;
+
+/**
+**  @ingroup gcoVG
+**
+**  @brief  Filter mode patterns and imaging.
+**
+**  This enumeration defines the filter modes supported by the HAL.
+*/
+typedef enum _gceIMAGE_FILTER
+{
+    gcvFILTER_POINT,
+    gcvFILTER_LINEAR,
+    gcvFILTER_BI_LINEAR
+}
+gceIMAGE_FILTER;
+
+/**
+**  @ingroup gcoVG
+**
+**  @brief  Primitive modes supported by the HAL.
+**
+**  This enumeration defines the primitive modes supported by the HAL.
+*/
+typedef enum _gceVG_PRIMITIVE
+{
+    gcvVG_SCANLINE,
+    gcvVG_RECTANGLE,
+    gcvVG_TESSELLATED,
+    gcvVG_TESSELLATED_TILED
+}
+gceVG_PRIMITIVE;
+
+/**
+**  @ingroup gcoVG
+**
+**  @brief  Rendering quality modes supported by the HAL.
+**
+**  This enumeration defines the rendering quality modes supported by the HAL.
+*/
+typedef enum _gceRENDER_QUALITY
+{
+    gcvVG_NONANTIALIASED,
+    gcvVG_2X2_MSAA,
+    gcvVG_2X4_MSAA,
+    gcvVG_4X4_MSAA
+}
+gceRENDER_QUALITY;
+
+/**
+**  @ingroup gcoVG
+**
+**  @brief  Fill rules supported by the HAL.
+**
+**  This enumeration defines the fill rules supported by the HAL.
+*/
+typedef enum _gceFILL_RULE
+{
+    gcvVG_EVEN_ODD,
+    gcvVG_NON_ZERO
+}
+gceFILL_RULE;
+
+/**
+**  @ingroup gcoVG
+**
+**  @brief  Cap styles supported by the HAL.
+**
+**  This enumeration defines the cap styles supported by the HAL.
+*/
+typedef enum _gceCAP_STYLE
+{
+    gcvCAP_BUTT,
+    gcvCAP_ROUND,
+    gcvCAP_SQUARE
+}
+gceCAP_STYLE;
+
+/**
+**  @ingroup gcoVG
+**
+**  @brief  Join styles supported by the HAL.
+**
+**  This enumeration defines the join styles supported by the HAL.
+*/
+typedef enum _gceJOIN_STYLE
+{
+    gcvJOIN_MITER,
+    gcvJOIN_ROUND,
+    gcvJOIN_BEVEL
+}
+gceJOIN_STYLE;
+
+/**
+**  @ingroup gcoVG
+**
+**  @brief  Channel mask values.
+**
+**  This enumeration defines the values for channel mask used in image
+**  filtering.
+*/
+
+/* Base values for channel mask definitions. */
+#define gcvCHANNEL_X    (0)
+#define gcvCHANNEL_R    (1 << 0)
+#define gcvCHANNEL_G    (1 << 1)
+#define gcvCHANNEL_B    (1 << 2)
+#define gcvCHANNEL_A    (1 << 3)
+
+typedef enum _gceCHANNEL
+{
+    gcvCHANNEL_XXXX = (gcvCHANNEL_X | gcvCHANNEL_X | gcvCHANNEL_X | gcvCHANNEL_X),
+    gcvCHANNEL_XXXA = (gcvCHANNEL_X | gcvCHANNEL_X | gcvCHANNEL_X | gcvCHANNEL_A),
+    gcvCHANNEL_XXBX = (gcvCHANNEL_X | gcvCHANNEL_X | gcvCHANNEL_B | gcvCHANNEL_X),
+    gcvCHANNEL_XXBA = (gcvCHANNEL_X | gcvCHANNEL_X | gcvCHANNEL_B | gcvCHANNEL_A),
+
+    gcvCHANNEL_XGXX = (gcvCHANNEL_X | gcvCHANNEL_G | gcvCHANNEL_X | gcvCHANNEL_X),
+    gcvCHANNEL_XGXA = (gcvCHANNEL_X | gcvCHANNEL_G | gcvCHANNEL_X | gcvCHANNEL_A),
+    gcvCHANNEL_XGBX = (gcvCHANNEL_X | gcvCHANNEL_G | gcvCHANNEL_B | gcvCHANNEL_X),
+    gcvCHANNEL_XGBA = (gcvCHANNEL_X | gcvCHANNEL_G | gcvCHANNEL_B | gcvCHANNEL_A),
+
+    gcvCHANNEL_RXXX = (gcvCHANNEL_R | gcvCHANNEL_X | gcvCHANNEL_X | gcvCHANNEL_X),
+    gcvCHANNEL_RXXA = (gcvCHANNEL_R | gcvCHANNEL_X | gcvCHANNEL_X | gcvCHANNEL_A),
+    gcvCHANNEL_RXBX = (gcvCHANNEL_R | gcvCHANNEL_X | gcvCHANNEL_B | gcvCHANNEL_X),
+    gcvCHANNEL_RXBA = (gcvCHANNEL_R | gcvCHANNEL_X | gcvCHANNEL_B | gcvCHANNEL_A),
+
+    gcvCHANNEL_RGXX = (gcvCHANNEL_R | gcvCHANNEL_G | gcvCHANNEL_X | gcvCHANNEL_X),
+    gcvCHANNEL_RGXA = (gcvCHANNEL_R | gcvCHANNEL_G | gcvCHANNEL_X | gcvCHANNEL_A),
+    gcvCHANNEL_RGBX = (gcvCHANNEL_R | gcvCHANNEL_G | gcvCHANNEL_B | gcvCHANNEL_X),
+    gcvCHANNEL_RGBA = (gcvCHANNEL_R | gcvCHANNEL_G | gcvCHANNEL_B | gcvCHANNEL_A),
+}
+gceCHANNEL;
+
+/******************************************************************************\
+******************************** VG Structures *******************************
+\******************************************************************************/
+
+/**
+**  @ingroup    gcoVG
+**
+**  @brief      Definition of the color ramp used by the gradient paints.
+**
+**  The gcsCOLOR_RAMP structure defines the layout of one single color inside
+**  a color ramp which is used by gradient paints.
+*/
+typedef struct _gcsCOLOR_RAMP
+{
+    /** Value for the color stop. */
+    gctFLOAT        stop;
+
+    /** Red color channel value for the color stop. */
+    gctFLOAT        red;
+
+    /** Green color channel value for the color stop. */
+    gctFLOAT        green;
+
+    /** Blue color channel value for the color stop. */
+    gctFLOAT        blue;
+
+    /** Alpha color channel value for the color stop. */
+    gctFLOAT        alpha;
+}
+gcsCOLOR_RAMP, * gcsCOLOR_RAMP_PTR;
+
+/**
+**  @ingroup    gcoVG
+**
+**  @brief      Definition of the color ramp used by the gradient paints in fixed form.
+**
+**  The gcsCOLOR_RAMP structure defines the layout of one single color inside
+**  a color ramp which is used by gradient paints.
+*/
+typedef struct _gcsFIXED_COLOR_RAMP
+{
+    /** Value for the color stop. */
+    gctFIXED_POINT      stop;
+
+    /** Red color channel value for the color stop. */
+    gctFIXED_POINT      red;
+
+    /** Green color channel value for the color stop. */
+    gctFIXED_POINT      green;
+
+    /** Blue color channel value for the color stop. */
+    gctFIXED_POINT      blue;
+
+    /** Alpha color channel value for the color stop. */
+    gctFIXED_POINT      alpha;
+}
+gcsFIXED_COLOR_RAMP, * gcsFIXED_COLOR_RAMP_PTR;
+
+
+/**
+**  @ingroup gcoVG
+**
+**  @brief  Rectangle structure used by the gcoVG object.
+**
+**  This structure defines the layout of a rectangle.  Make sure width and
+**  height are larger than 0.
+*/
+typedef struct _gcsVG_RECT * gcsVG_RECT_PTR;
+typedef struct _gcsVG_RECT
+{
+    /** Left location of the rectangle. */
+    gctINT      x;
+
+    /** Top location of the rectangle. */
+    gctINT      y;
+
+    /** Width of the rectangle. */
+    gctINT      width;
+
+    /** Height of the rectangle. */
+    gctINT      height;
+}
+gcsVG_RECT;
+
+/**
+**  @ingroup    gcoVG
+**
+**  @brief      Path command buffer attribute structure.
+**
+**  The gcsPATH_BUFFER_INFO structure contains the specifics about
+**  the layout of the path data command buffer.
+*/
+typedef struct _gcsPATH_BUFFER_INFO * gcsPATH_BUFFER_INFO_PTR;
+typedef struct _gcsPATH_BUFFER_INFO
+{
+    gctUINT     reservedForHead;
+    gctUINT     reservedForTail;
+}
+gcsPATH_BUFFER_INFO;
+
+/**
+**  @ingroup    gcoVG
+**
+**  @brief      Definition of the path data container structure.
+**
+**  The gcsPATH structure defines the layout of the path data container.
+*/
+typedef struct _gcsPATH_DATA * gcsPATH_DATA_PTR;
+typedef struct _gcsPATH_DATA
+{
+    /* Data container in command buffer format. */
+    gcsCMDBUFFER    data;
+
+    /* Path data type. */
+    gcePATHTYPE     dataType;
+}
+gcsPATH_DATA;
+
+
+/******************************************************************************\
+********************************* gcoHAL Object ********************************
+\******************************************************************************/
+
+/* Query path data storage attributes. */
+gceSTATUS
+gcoHAL_QueryPathStorage(
+    IN gcoHAL Hal,
+    OUT gcsPATH_BUFFER_INFO_PTR Information
+    );
+
+/* Associate a completion signal with the command buffer. */
+gceSTATUS
+gcoHAL_AssociateCompletion(
+    IN gcoHAL Hal,
+    IN gcsPATH_DATA_PTR PathData
+    );
+
+/* Release the current command buffer completion signal. */
+gceSTATUS
+gcoHAL_DeassociateCompletion(
+    IN gcoHAL Hal,
+    IN gcsPATH_DATA_PTR PathData
+    );
+
+/* Verify whether the command buffer is still in use. */
+gceSTATUS
+gcoHAL_CheckCompletion(
+    IN gcoHAL Hal,
+    IN gcsPATH_DATA_PTR PathData
+    );
+
+/* Wait until the command buffer is no longer in use. */
+gceSTATUS
+gcoHAL_WaitCompletion(
+    IN gcoHAL Hal,
+    IN gcsPATH_DATA_PTR PathData
+    );
+
+/* Flush the pixel cache. */
+gceSTATUS
+gcoHAL_Flush(
+    IN gcoHAL Hal
+    );
+
+/* Split a harwdare address into pool and offset. */
+gceSTATUS
+gcoHAL_SplitAddress(
+    IN gcoHAL Hal,
+    IN gctUINT32 Address,
+    OUT gcePOOL * Pool,
+    OUT gctUINT32 * Offset
+    );
+
+/* Combine pool and offset into a harwdare address. */
+gceSTATUS
+gcoHAL_CombineAddress(
+    IN gcoHAL Hal,
+    IN gcePOOL Pool,
+    IN gctUINT32 Offset,
+    OUT gctUINT32 * Address
+    );
+
+/* Schedule to free linear video memory allocated. */
+gceSTATUS
+gcoHAL_ScheduleVideoMemory(
+    IN gcoHAL Hal,
+    IN gcuVIDMEM_NODE_PTR Node
+    );
+
+/* Free linear video memory allocated with gcoHAL_AllocateLinearVideoMemory. */
+gceSTATUS
+gcoHAL_FreeVideoMemory(
+    IN gcoHAL Hal,
+    IN gcuVIDMEM_NODE_PTR Node
+    );
+
+/* Query command buffer attributes. */
+gceSTATUS
+gcoHAL_QueryCommandBuffer(
+    IN gcoHAL Hal,
+    OUT gcsCOMMAND_BUFFER_INFO_PTR Information
+    );
+/* Allocate and lock linear video memory. */
+gceSTATUS
+gcoHAL_AllocateLinearVideoMemory(
+    IN gcoHAL Hal,
+    IN gctUINT Size,
+    IN gctUINT Alignment,
+    IN gcePOOL Pool,
+    OUT gcuVIDMEM_NODE_PTR * Node,
+    OUT gctUINT32 * Address,
+    OUT gctPOINTER * Memory
+    );
+
+/* Align the specified size accordingly to the hardware requirements. */
+gceSTATUS
+gcoHAL_GetAlignedSurfaceSize(
+    IN gcoHAL Hal,
+    IN gceSURF_TYPE Type,
+    IN OUT gctUINT32_PTR Width,
+    IN OUT gctUINT32_PTR Height
+    );
+
+gceSTATUS
+gcoHAL_ReserveTask(
+    IN gcoHAL Hal,
+    IN gceBLOCK Block,
+    IN gctUINT TaskCount,
+    IN gctSIZE_T Bytes,
+    OUT gctPOINTER * Memory
+    );
+/******************************************************************************\
+********************************** gcoVG Object ********************************
+\******************************************************************************/
+
+/** @defgroup gcoVG gcoVG
+**
+**  The gcoVG object abstracts the VG hardware pipe.
+*/
+
+gctBOOL
+gcoVG_IsMaskSupported(
+    IN gceSURF_FORMAT Format
+    );
+
+gctBOOL
+gcoVG_IsTargetSupported(
+    IN gceSURF_FORMAT Format
+    );
+
+gctBOOL
+gcoVG_IsImageSupported(
+    IN gceSURF_FORMAT Format
+    );
+
+gctUINT8 gcoVG_PackColorComponent(
+    gctFLOAT Value
+    );
+
+gceSTATUS
+gcoVG_Construct(
+    IN gcoHAL Hal,
+    OUT gcoVG * Vg
+    );
+
+gceSTATUS
+gcoVG_Destroy(
+    IN gcoVG Vg
+    );
+
+gceSTATUS
+gcoVG_SetTarget(
+    IN gcoVG Vg,
+    IN gcoSURF Target
+    );
+
+gceSTATUS
+gcoVG_UnsetTarget(
+    IN gcoVG Vg,
+    IN gcoSURF Surface
+    );
+
+gceSTATUS
+gcoVG_SetUserToSurface(
+    IN gcoVG Vg,
+    IN gctFLOAT UserToSurface[9]
+    );
+
+gceSTATUS
+gcoVG_SetSurfaceToImage(
+    IN gcoVG Vg,
+    IN gctFLOAT SurfaceToImage[9]
+    );
+
+gceSTATUS
+gcoVG_EnableMask(
+    IN gcoVG Vg,
+    IN gctBOOL Enable
+    );
+
+gceSTATUS
+gcoVG_SetMask(
+    IN gcoVG Vg,
+    IN gcoSURF Mask
+    );
+
+gceSTATUS
+gcoVG_UnsetMask(
+    IN gcoVG Vg,
+    IN gcoSURF Surface
+    );
+
+gceSTATUS
+gcoVG_FlushMask(
+    IN gcoVG Vg
+    );
+
+gceSTATUS
+gcoVG_EnableScissor(
+    IN gcoVG Vg,
+    IN gctBOOL Enable
+    );
+
+gceSTATUS
+gcoVG_SetScissor(
+    IN gcoVG Vg,
+    IN gctSIZE_T RectangleCount,
+    IN gcsVG_RECT_PTR Rectangles
+    );
+
+gceSTATUS
+gcoVG_EnableColorTransform(
+    IN gcoVG Vg,
+    IN gctBOOL Enable
+    );
+
+gceSTATUS
+gcoVG_SetColorTransform(
+    IN gcoVG Vg,
+    IN gctFLOAT ColorTransform[8]
+    );
+
+gceSTATUS
+gcoVG_SetTileFillColor(
+    IN gcoVG Vg,
+    IN gctFLOAT Red,
+    IN gctFLOAT Green,
+    IN gctFLOAT Blue,
+    IN gctFLOAT Alpha
+    );
+
+gceSTATUS
+gcoVG_SetSolidPaint(
+    IN gcoVG Vg,
+    IN gctUINT8 Red,
+    IN gctUINT8 Green,
+    IN gctUINT8 Blue,
+    IN gctUINT8 Alpha
+    );
+
+gceSTATUS
+gcoVG_SetLinearPaint(
+    IN gcoVG Vg,
+    IN gctFLOAT Constant,
+    IN gctFLOAT StepX,
+    IN gctFLOAT StepY
+    );
+
+gceSTATUS
+gcoVG_SetRadialPaint(
+    IN gcoVG Vg,
+    IN gctFLOAT LinConstant,
+    IN gctFLOAT LinStepX,
+    IN gctFLOAT LinStepY,
+    IN gctFLOAT RadConstant,
+    IN gctFLOAT RadStepX,
+    IN gctFLOAT RadStepY,
+    IN gctFLOAT RadStepXX,
+    IN gctFLOAT RadStepYY,
+    IN gctFLOAT RadStepXY
+    );
+
+gceSTATUS
+gcoVG_SetPatternPaint(
+    IN gcoVG Vg,
+    IN gctFLOAT UConstant,
+    IN gctFLOAT UStepX,
+    IN gctFLOAT UStepY,
+    IN gctFLOAT VConstant,
+    IN gctFLOAT VStepX,
+    IN gctFLOAT VStepY,
+    IN gctBOOL Linear
+    );
+
+gceSTATUS
+gcoVG_SetColorRamp(
+    IN gcoVG Vg,
+    IN gcoSURF ColorRamp,
+    IN gceTILE_MODE ColorRampSpreadMode
+    );
+
+gceSTATUS
+gcoVG_SetPattern(
+    IN gcoVG Vg,
+    IN gcoSURF Pattern,
+    IN gceTILE_MODE TileMode,
+    IN gceIMAGE_FILTER Filter
+    );
+
+gceSTATUS
+gcoVG_SetImageMode(
+    IN gcoVG Vg,
+    IN gceVG_IMAGE Mode
+    );
+
+gceSTATUS
+gcoVG_SetBlendMode(
+    IN gcoVG Vg,
+    IN gceVG_BLEND Mode
+    );
+
+gceSTATUS
+gcoVG_SetRenderingQuality(
+    IN gcoVG Vg,
+    IN gceRENDER_QUALITY Quality
+    );
+
+gceSTATUS
+gcoVG_SetFillRule(
+    IN gcoVG Vg,
+    IN gceFILL_RULE FillRule
+    );
+
+gceSTATUS
+gcoVG_FinalizePath(
+    IN gcoVG Vg,
+    IN gcsPATH_DATA_PTR PathData
+    );
+
+gceSTATUS
+gcoVG_Clear(
+    IN gcoVG Vg,
+    IN gctINT X,
+    IN gctINT Y,
+    IN gctINT Width,
+    IN gctINT Height
+    );
+
+gceSTATUS
+gcoVG_DrawPath(
+    IN gcoVG Vg,
+    IN gcsPATH_DATA_PTR PathData,
+    IN gctFLOAT Scale,
+    IN gctFLOAT Bias,
+    IN gctBOOL SoftwareTesselation
+    );
+
+gceSTATUS
+gcoVG_DrawImage(
+    IN gcoVG Vg,
+    IN gcoSURF Source,
+    IN gcsPOINT_PTR SourceOrigin,
+    IN gcsPOINT_PTR TargetOrigin,
+    IN gcsSIZE_PTR SourceSize,
+    IN gctINT SourceX,
+    IN gctINT SourceY,
+    IN gctINT TargetX,
+    IN gctINT TargetY,
+    IN gctINT Width,
+    IN gctINT Height,
+    IN gctBOOL Mask
+    );
+
+gceSTATUS
+gcoVG_TesselateImage(
+    IN gcoVG Vg,
+    IN gcoSURF Image,
+    IN gcsVG_RECT_PTR Rectangle,
+    IN gceIMAGE_FILTER Filter,
+    IN gctBOOL Mask,
+    IN gctBOOL SoftwareTesselation
+    );
+
+gceSTATUS
+gcoVG_Blit(
+    IN gcoVG Vg,
+    IN gcoSURF Source,
+    IN gcoSURF Target,
+    IN gcsVG_RECT_PTR SrcRect,
+    IN gcsVG_RECT_PTR TrgRect,
+    IN gceIMAGE_FILTER Filter,
+    IN gceVG_BLEND Mode
+    );
+
+gceSTATUS
+gcoVG_ColorMatrix(
+    IN gcoVG Vg,
+    IN gcoSURF Source,
+    IN gcoSURF Target,
+    IN const gctFLOAT * Matrix,
+    IN gceCHANNEL ColorChannels,
+    IN gctBOOL FilterLinear,
+    IN gctBOOL FilterPremultiplied,
+    IN gcsPOINT_PTR SourceOrigin,
+    IN gcsPOINT_PTR TargetOrigin,
+    IN gctINT Width,
+    IN gctINT Height
+    );
+
+gceSTATUS
+gcoVG_SeparableConvolve(
+    IN gcoVG Vg,
+    IN gcoSURF Source,
+    IN gcoSURF Target,
+    IN gctINT KernelWidth,
+    IN gctINT KernelHeight,
+    IN gctINT ShiftX,
+    IN gctINT ShiftY,
+    IN const gctINT16 * KernelX,
+    IN const gctINT16 * KernelY,
+    IN gctFLOAT Scale,
+    IN gctFLOAT Bias,
+    IN gceTILE_MODE TilingMode,
+    IN gctFLOAT_PTR FillColor,
+    IN gceCHANNEL ColorChannels,
+    IN gctBOOL FilterLinear,
+    IN gctBOOL FilterPremultiplied,
+    IN gcsPOINT_PTR SourceOrigin,
+    IN gcsPOINT_PTR TargetOrigin,
+    IN gcsSIZE_PTR SourceSize,
+    IN gctINT Width,
+    IN gctINT Height
+    );
+
+gceSTATUS
+gcoVG_GaussianBlur(
+    IN gcoVG Vg,
+    IN gcoSURF Source,
+    IN gcoSURF Target,
+    IN gctFLOAT StdDeviationX,
+    IN gctFLOAT StdDeviationY,
+    IN gceTILE_MODE TilingMode,
+    IN gctFLOAT_PTR FillColor,
+    IN gceCHANNEL ColorChannels,
+    IN gctBOOL FilterLinear,
+    IN gctBOOL FilterPremultiplied,
+    IN gcsPOINT_PTR SourceOrigin,
+    IN gcsPOINT_PTR TargetOrigin,
+    IN gcsSIZE_PTR SourceSize,
+    IN gctINT Width,
+    IN gctINT Height
+    );
+
+gceSTATUS
+gcoVG_EnableDither(
+    IN gcoVG Vg,
+    IN gctBOOL Enable
+    );
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif  /* __gc_hal_vg_h_ */
diff --git a/attic/gc_hal_enum.h b/attic/gc_hal_enum.h
new file mode 100644
index 0000000..7d67828
--- /dev/null
+++ b/attic/gc_hal_enum.h
@@ -0,0 +1,823 @@
+/****************************************************************************
+*
+*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*
+*    This program is free software; you can redistribute it and/or modify
+*    it under the terms of the GNU General Public License as published by
+*    the Free Software Foundation; either version 2 of the license, or
+*    (at your option) any later version.
+*
+*    This program is distributed in the hope that it will be useful,
+*    but WITHOUT ANY WARRANTY; without even the implied warranty of
+*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+*    GNU General Public License for more details.
+*
+*    You should have received a copy of the GNU General Public License
+*    along with this program; if not write to the Free Software
+*    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*
+*****************************************************************************/
+
+
+
+
+#ifndef __gc_hal_enum_h_
+#define __gc_hal_enum_h_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* Chip models. */
+typedef enum _gceCHIPMODEL
+{
+    gcv300  = 0x0300,
+    gcv320  = 0x0320,
+    gcv350  = 0x0350,
+    gcv355  = 0x0355,
+    gcv400  = 0x0400,
+    gcv410  = 0x0410,
+    gcv420  = 0x0420,
+    gcv450  = 0x0450,
+    gcv500  = 0x0500,
+    gcv530  = 0x0530,
+    gcv600  = 0x0600,
+    gcv700  = 0x0700,
+    gcv800  = 0x0800,
+    gcv860  = 0x0860,
+    gcv880  = 0x0880,
+    gcv1000 = 0x1000,
+    gcv2000 = 0x2000,
+    gcv2100 = 0x2100,
+    gcv4000 = 0x4000,
+}
+gceCHIPMODEL;
+
+/* Chip features. */
+typedef enum _gceFEATURE
+{
+    gcvFEATURE_PIPE_2D = 0,
+    gcvFEATURE_PIPE_3D,
+    gcvFEATURE_PIPE_VG,
+    gcvFEATURE_DC,
+    gcvFEATURE_HIGH_DYNAMIC_RANGE,
+    gcvFEATURE_MODULE_CG,
+    gcvFEATURE_MIN_AREA,
+    gcvFEATURE_BUFFER_INTERLEAVING,
+    gcvFEATURE_BYTE_WRITE_2D,
+    gcvFEATURE_ENDIANNESS_CONFIG,
+    gcvFEATURE_DUAL_RETURN_BUS,
+    gcvFEATURE_DEBUG_MODE,
+    gcvFEATURE_YUY2_RENDER_TARGET,
+    gcvFEATURE_FRAGMENT_PROCESSOR,
+    gcvFEATURE_2DPE20,
+    gcvFEATURE_FAST_CLEAR,
+    gcvFEATURE_YUV420_TILER,
+    gcvFEATURE_YUY2_AVERAGING,
+    gcvFEATURE_FLIP_Y,
+    gcvFEATURE_EARLY_Z,
+    gcvFEATURE_Z_COMPRESSION,
+    gcvFEATURE_MSAA,
+    gcvFEATURE_SPECIAL_ANTI_ALIASING,
+    gcvFEATURE_SPECIAL_MSAA_LOD,
+    gcvFEATURE_422_TEXTURE_COMPRESSION,
+    gcvFEATURE_DXT_TEXTURE_COMPRESSION,
+    gcvFEATURE_ETC1_TEXTURE_COMPRESSION,
+    gcvFEATURE_CORRECT_TEXTURE_CONVERTER,
+    gcvFEATURE_TEXTURE_8K,
+    gcvFEATURE_SCALER,
+    gcvFEATURE_YUV420_SCALER,
+    gcvFEATURE_SHADER_HAS_W,
+    gcvFEATURE_SHADER_HAS_SIGN,
+    gcvFEATURE_SHADER_HAS_FLOOR,
+    gcvFEATURE_SHADER_HAS_CEIL,
+    gcvFEATURE_SHADER_HAS_SQRT,
+    gcvFEATURE_SHADER_HAS_TRIG,
+    gcvFEATURE_VAA,
+    gcvFEATURE_HZ,
+    gcvFEATURE_CORRECT_STENCIL,
+    gcvFEATURE_VG20,
+    gcvFEATURE_VG_FILTER,
+    gcvFEATURE_VG21,
+    gcvFEATURE_VG_DOUBLE_BUFFER,
+    gcvFEATURE_MC20,
+    gcvFEATURE_SUPER_TILED,
+    gcvFEATURE_2D_FILTERBLIT_PLUS_ALPHABLEND,
+    gcvFEATURE_2D_DITHER,
+    gcvFEATURE_2D_A8_TARGET,
+    gcvFEATURE_2D_FILTERBLIT_FULLROTATION,
+    gcvFEATURE_2D_BITBLIT_FULLROTATION,
+    gcvFEATURE_WIDE_LINE,
+    gcvFEATURE_FC_FLUSH_STALL,
+    gcvFEATURE_FULL_DIRECTFB,
+    gcvFEATURE_HALF_FLOAT_PIPE,
+    gcvFEATURE_LINE_LOOP,
+    gcvFEATURE_2D_YUV_BLIT,
+    gcvFEATURE_2D_TILING,
+    gcvFEATURE_NON_POWER_OF_TWO,
+    gcvFEATURE_3D_TEXTURE,
+    gcvFEATURE_TEXTURE_ARRAY,
+    gcvFEATURE_TILE_FILLER,
+    gcvFEATURE_LOGIC_OP,
+    gcvFEATURE_COMPOSITION,
+    gcvFEATURE_MIXED_STREAMS,
+    gcvFEATURE_2D_MULTI_SOURCE_BLT,
+    gcvFEATURE_END_EVENT,
+    gcvFEATURE_VERTEX_10_10_10_2,
+    gcvFEATURE_TEXTURE_10_10_10_2,
+    gcvFEATURE_TEXTURE_ANISOTROPIC_FILTERING,
+    gcvFEATURE_TEXTURE_FLOAT_HALF_FLOAT,
+	gcvFEATURE_2D_ROTATION_STALL_FIX,
+    gcvFEATURE_2D_MULTI_SOURCE_BLT_EX,
+	gcvFEATURE_BUG_FIXES10,
+    gcvFEATURE_2D_MINOR_TILING,
+    /* Supertiled compressed textures are supported. */
+    gcvFEATURE_TEX_COMPRRESSION_SUPERTILED,
+    gcvFEATURE_FAST_MSAA,
+    gcvFEATURE_BUG_FIXED_INDEXED_TRIANGLE_STRIP,
+    gcvFEATURE_TEXTURE_TILED_READ,
+    gcvFEATURE_DEPTH_BIAS_FIX,
+    gcvFEATURE_RECT_PRIMITIVE,
+	gcvFEATURE_BUG_FIXES11,
+	gcvFEATURE_SUPERTILED_TEXTURE,
+    gcvFEATURE_2D_NO_COLORBRUSH_INDEX8
+}
+gceFEATURE;
+
+/* Chip Power Status. */
+typedef enum _gceCHIPPOWERSTATE
+{
+    gcvPOWER_ON = 0,
+    gcvPOWER_OFF,
+    gcvPOWER_IDLE,
+    gcvPOWER_SUSPEND,
+    gcvPOWER_SUSPEND_ATPOWERON,
+    gcvPOWER_OFF_ATPOWERON,
+    gcvPOWER_IDLE_BROADCAST,
+    gcvPOWER_SUSPEND_BROADCAST,
+    gcvPOWER_OFF_BROADCAST,
+    gcvPOWER_OFF_RECOVERY,
+#if gcdPOWEROFF_TIMEOUT
+    gcvPOWER_OFF_TIMEOUT,
+#endif
+    gcvPOWER_ON_AUTO
+}
+gceCHIPPOWERSTATE;
+
+/* CPU cache operations */
+typedef enum _gceCACHEOPERATION
+{
+    gcvCACHE_CLEAN      = 0x01,
+    gcvCACHE_INVALIDATE = 0x02,
+    gcvCACHE_FLUSH      = gcvCACHE_CLEAN  | gcvCACHE_INVALIDATE,
+    gcvCACHE_MEMORY_BARRIER = 0x04
+}
+gceCACHEOPERATION;
+
+typedef enum _gceVIDMEM_NODE_SHARED_INFO_TYPE
+{
+    gcvVIDMEM_INFO_GENERIC,
+    gcvVIDMEM_INFO_DIRTY_RECTANGLE
+}
+gceVIDMEM_NODE_SHARED_INFO_TYPE;
+
+/* Surface types. */
+typedef enum _gceSURF_TYPE
+{
+    gcvSURF_TYPE_UNKNOWN = 0,
+    gcvSURF_INDEX,
+    gcvSURF_VERTEX,
+    gcvSURF_TEXTURE,
+    gcvSURF_RENDER_TARGET,
+    gcvSURF_DEPTH,
+    gcvSURF_BITMAP,
+    gcvSURF_TILE_STATUS,
+	gcvSURF_IMAGE,
+    gcvSURF_MASK,
+    gcvSURF_SCISSOR,
+    gcvSURF_HIERARCHICAL_DEPTH,
+    gcvSURF_NUM_TYPES, /* Make sure this is the last one! */
+
+    /* Combinations. */
+    gcvSURF_NO_TILE_STATUS = 0x100,
+    gcvSURF_NO_VIDMEM      = 0x200, /* Used to allocate surfaces with no underlying vidmem node.
+                                       In Android, vidmem node is allocated by another process. */
+    gcvSURF_CACHEABLE      = 0x400, /* Used to allocate a cacheable surface */
+#if gcdANDROID_UNALIGNED_LINEAR_COMPOSITION_ADJUST
+    gcvSURF_FLIP           = 0x800, /* The Resolve Target the will been flip resolve from RT */
+#endif
+
+    gcvSURF_RENDER_TARGET_NO_TILE_STATUS = gcvSURF_RENDER_TARGET
+                                         | gcvSURF_NO_TILE_STATUS,
+
+    gcvSURF_DEPTH_NO_TILE_STATUS         = gcvSURF_DEPTH
+                                         | gcvSURF_NO_TILE_STATUS,
+
+    /* Supported surface types with no vidmem node. */
+    gcvSURF_BITMAP_NO_VIDMEM             = gcvSURF_BITMAP
+                                         | gcvSURF_NO_VIDMEM,
+
+    gcvSURF_TEXTURE_NO_VIDMEM            = gcvSURF_TEXTURE
+                                         | gcvSURF_NO_VIDMEM,
+
+    /* Cacheable surface types with no vidmem node. */
+    gcvSURF_CACHEABLE_BITMAP_NO_VIDMEM   = gcvSURF_BITMAP_NO_VIDMEM
+                                         | gcvSURF_CACHEABLE,
+
+    gcvSURF_CACHEABLE_BITMAP             = gcvSURF_BITMAP
+                                         | gcvSURF_CACHEABLE,
+
+#if gcdANDROID_UNALIGNED_LINEAR_COMPOSITION_ADJUST
+    gcvSURF_FLIP_BITMAP                  = gcvSURF_BITMAP
+                                         | gcvSURF_FLIP,
+#endif
+}
+gceSURF_TYPE;
+
+typedef enum _gceSURF_USAGE
+{
+    gcvSURF_USAGE_UNKNOWN,
+    gcvSURF_USAGE_RESOLVE_AFTER_CPU,
+    gcvSURF_USAGE_RESOLVE_AFTER_3D
+}
+gceSURF_USAGE;
+
+typedef enum _gceSURF_COLOR_TYPE
+{
+    gcvSURF_COLOR_UNKNOWN = 0,
+    gcvSURF_COLOR_LINEAR        = 0x01,
+    gcvSURF_COLOR_ALPHA_PRE     = 0x02,
+}
+gceSURF_COLOR_TYPE;
+
+/* Rotation. */
+typedef enum _gceSURF_ROTATION
+{
+    gcvSURF_0_DEGREE = 0,
+    gcvSURF_90_DEGREE,
+    gcvSURF_180_DEGREE,
+    gcvSURF_270_DEGREE,
+    gcvSURF_FLIP_X,
+    gcvSURF_FLIP_Y,
+}
+gceSURF_ROTATION;
+
+/* Surface formats. */
+typedef enum _gceSURF_FORMAT
+{
+    /* Unknown format. */
+    gcvSURF_UNKNOWN             = 0,
+
+    /* Palettized formats. */
+    gcvSURF_INDEX1              = 100,
+    gcvSURF_INDEX4,
+    gcvSURF_INDEX8,
+
+    /* RGB formats. */
+    gcvSURF_A2R2G2B2            = 200,
+    gcvSURF_R3G3B2,
+    gcvSURF_A8R3G3B2,
+    gcvSURF_X4R4G4B4,
+    gcvSURF_A4R4G4B4,
+    gcvSURF_R4G4B4A4,
+    gcvSURF_X1R5G5B5,
+    gcvSURF_A1R5G5B5,
+    gcvSURF_R5G5B5A1,
+    gcvSURF_R5G6B5,
+    gcvSURF_R8G8B8,
+    gcvSURF_X8R8G8B8,
+    gcvSURF_A8R8G8B8,
+    gcvSURF_R8G8B8A8,
+    gcvSURF_G8R8G8B8,
+    gcvSURF_R8G8B8G8,
+    gcvSURF_X2R10G10B10,
+    gcvSURF_A2R10G10B10,
+    gcvSURF_X12R12G12B12,
+    gcvSURF_A12R12G12B12,
+    gcvSURF_X16R16G16B16,
+    gcvSURF_A16R16G16B16,
+    gcvSURF_A32R32G32B32,
+    gcvSURF_R8G8B8X8,
+    gcvSURF_R5G5B5X1,
+    gcvSURF_R4G4B4X4,
+
+    /* BGR formats. */
+    gcvSURF_A4B4G4R4            = 300,
+    gcvSURF_A1B5G5R5,
+    gcvSURF_B5G6R5,
+    gcvSURF_B8G8R8,
+    gcvSURF_B16G16R16,
+    gcvSURF_X8B8G8R8,
+    gcvSURF_A8B8G8R8,
+    gcvSURF_A2B10G10R10,
+    gcvSURF_X16B16G16R16,
+    gcvSURF_A16B16G16R16,
+    gcvSURF_B32G32R32,
+    gcvSURF_X32B32G32R32,
+    gcvSURF_A32B32G32R32,
+    gcvSURF_B4G4R4A4,
+    gcvSURF_B5G5R5A1,
+    gcvSURF_B8G8R8X8,
+    gcvSURF_B8G8R8A8,
+    gcvSURF_X4B4G4R4,
+    gcvSURF_X1B5G5R5,
+    gcvSURF_B4G4R4X4,
+    gcvSURF_B5G5R5X1,
+    gcvSURF_X2B10G10R10,
+
+    /* Compressed formats. */
+    gcvSURF_DXT1                = 400,
+    gcvSURF_DXT2,
+    gcvSURF_DXT3,
+    gcvSURF_DXT4,
+    gcvSURF_DXT5,
+    gcvSURF_CXV8U8,
+    gcvSURF_ETC1,
+
+    /* YUV formats. */
+    gcvSURF_YUY2                = 500,
+    gcvSURF_UYVY,
+    gcvSURF_YV12,
+    gcvSURF_I420,
+    gcvSURF_NV12,
+    gcvSURF_NV21,
+    gcvSURF_NV16,
+    gcvSURF_NV61,
+    gcvSURF_YVYU,
+    gcvSURF_VYUY,
+
+    /* Depth formats. */
+    gcvSURF_D16                 = 600,
+    gcvSURF_D24S8,
+    gcvSURF_D32,
+    gcvSURF_D24X8,
+
+    /* Alpha formats. */
+    gcvSURF_A4                  = 700,
+    gcvSURF_A8,
+    gcvSURF_A12,
+    gcvSURF_A16,
+    gcvSURF_A32,
+    gcvSURF_A1,
+
+    /* Luminance formats. */
+    gcvSURF_L4                  = 800,
+    gcvSURF_L8,
+    gcvSURF_L12,
+    gcvSURF_L16,
+    gcvSURF_L32,
+    gcvSURF_L1,
+
+    /* Alpha/Luminance formats. */
+    gcvSURF_A4L4                = 900,
+    gcvSURF_A2L6,
+    gcvSURF_A8L8,
+    gcvSURF_A4L12,
+    gcvSURF_A12L12,
+    gcvSURF_A16L16,
+
+    /* Bump formats. */
+    gcvSURF_L6V5U5              = 1000,
+    gcvSURF_V8U8,
+    gcvSURF_X8L8V8U8,
+    gcvSURF_Q8W8V8U8,
+    gcvSURF_A2W10V10U10,
+    gcvSURF_V16U16,
+    gcvSURF_Q16W16V16U16,
+
+    /* R/RG/RA formats. */
+    gcvSURF_R8                  = 1100,
+    gcvSURF_X8R8,
+    gcvSURF_G8R8,
+    gcvSURF_X8G8R8,
+    gcvSURF_A8R8,
+    gcvSURF_R16,
+    gcvSURF_X16R16,
+    gcvSURF_G16R16,
+    gcvSURF_X16G16R16,
+    gcvSURF_A16R16,
+    gcvSURF_R32,
+    gcvSURF_X32R32,
+    gcvSURF_G32R32,
+    gcvSURF_X32G32R32,
+    gcvSURF_A32R32,
+    gcvSURF_RG16,
+
+    /* Floating point formats. */
+    gcvSURF_R16F                = 1200,
+    gcvSURF_X16R16F,
+    gcvSURF_G16R16F,
+    gcvSURF_X16G16R16F,
+    gcvSURF_B16G16R16F,
+    gcvSURF_X16B16G16R16F,
+    gcvSURF_A16B16G16R16F,
+    gcvSURF_R32F,
+    gcvSURF_X32R32F,
+    gcvSURF_G32R32F,
+    gcvSURF_X32G32R32F,
+    gcvSURF_B32G32R32F,
+    gcvSURF_X32B32G32R32F,
+    gcvSURF_A32B32G32R32F,
+    gcvSURF_A16F,
+    gcvSURF_L16F,
+    gcvSURF_A16L16F,
+    gcvSURF_A16R16F,
+    gcvSURF_A32F,
+    gcvSURF_L32F,
+    gcvSURF_A32L32F,
+    gcvSURF_A32R32F,
+
+}
+gceSURF_FORMAT;
+
+/* Pixel swizzle modes. */
+typedef enum _gceSURF_SWIZZLE
+{
+    gcvSURF_NOSWIZZLE = 0,
+    gcvSURF_ARGB,
+    gcvSURF_ABGR,
+    gcvSURF_RGBA,
+    gcvSURF_BGRA
+}
+gceSURF_SWIZZLE;
+
+/* Transparency modes. */
+typedef enum _gceSURF_TRANSPARENCY
+{
+    /* Valid only for PE 1.0 */
+    gcvSURF_OPAQUE = 0,
+    gcvSURF_SOURCE_MATCH,
+    gcvSURF_SOURCE_MASK,
+    gcvSURF_PATTERN_MASK,
+}
+gceSURF_TRANSPARENCY;
+
+/* Surface Alignment. */
+typedef enum _gceSURF_ALIGNMENT
+{
+    gcvSURF_FOUR = 0,
+    gcvSURF_SIXTEEN,
+    gcvSURF_SUPER_TILED,
+    gcvSURF_SPLIT_TILED,
+    gcvSURF_SPLIT_SUPER_TILED,
+}
+gceSURF_ALIGNMENT;
+
+/* Transparency modes. */
+typedef enum _gce2D_TRANSPARENCY
+{
+    /* Valid only for PE 2.0 */
+    gcv2D_OPAQUE = 0,
+    gcv2D_KEYED,
+    gcv2D_MASKED
+}
+gce2D_TRANSPARENCY;
+
+/* Mono packing modes. */
+typedef enum _gceSURF_MONOPACK
+{
+    gcvSURF_PACKED8 = 0,
+    gcvSURF_PACKED16,
+    gcvSURF_PACKED32,
+    gcvSURF_UNPACKED,
+}
+gceSURF_MONOPACK;
+
+/* Blending modes. */
+typedef enum _gceSURF_BLEND_MODE
+{
+    /* Porter-Duff blending modes.                   */
+    /*                         Fsrc      Fdst        */
+    gcvBLEND_CLEAR = 0,     /* 0         0           */
+    gcvBLEND_SRC,           /* 1         0           */
+    gcvBLEND_DST,           /* 0         1           */
+    gcvBLEND_SRC_OVER_DST,  /* 1         1 - Asrc    */
+    gcvBLEND_DST_OVER_SRC,  /* 1 - Adst  1           */
+    gcvBLEND_SRC_IN_DST,    /* Adst      0           */
+    gcvBLEND_DST_IN_SRC,    /* 0         Asrc        */
+    gcvBLEND_SRC_OUT_DST,   /* 1 - Adst  0           */
+    gcvBLEND_DST_OUT_SRC,   /* 0         1 - Asrc    */
+    gcvBLEND_SRC_ATOP_DST,  /* Adst      1 - Asrc    */
+    gcvBLEND_DST_ATOP_SRC,  /* 1 - Adst  Asrc        */
+    gcvBLEND_SRC_XOR_DST,   /* 1 - Adst  1 - Asrc    */
+
+    /* Special blending modes.                       */
+    gcvBLEND_SET,           /* DST = 1               */
+    gcvBLEND_SUB            /* DST = DST * (1 - SRC) */
+}
+gceSURF_BLEND_MODE;
+
+/* Per-pixel alpha modes. */
+typedef enum _gceSURF_PIXEL_ALPHA_MODE
+{
+    gcvSURF_PIXEL_ALPHA_STRAIGHT = 0,
+    gcvSURF_PIXEL_ALPHA_INVERSED
+}
+gceSURF_PIXEL_ALPHA_MODE;
+
+/* Global alpha modes. */
+typedef enum _gceSURF_GLOBAL_ALPHA_MODE
+{
+    gcvSURF_GLOBAL_ALPHA_OFF = 0,
+    gcvSURF_GLOBAL_ALPHA_ON,
+    gcvSURF_GLOBAL_ALPHA_SCALE
+}
+gceSURF_GLOBAL_ALPHA_MODE;
+
+/* Color component modes for alpha blending. */
+typedef enum _gceSURF_PIXEL_COLOR_MODE
+{
+    gcvSURF_COLOR_STRAIGHT = 0,
+    gcvSURF_COLOR_MULTIPLY
+}
+gceSURF_PIXEL_COLOR_MODE;
+
+/* Color component modes for alpha blending. */
+typedef enum _gce2D_PIXEL_COLOR_MULTIPLY_MODE
+{
+    gcv2D_COLOR_MULTIPLY_DISABLE = 0,
+    gcv2D_COLOR_MULTIPLY_ENABLE
+}
+gce2D_PIXEL_COLOR_MULTIPLY_MODE;
+
+/* Color component modes for alpha blending. */
+typedef enum _gce2D_GLOBAL_COLOR_MULTIPLY_MODE
+{
+    gcv2D_GLOBAL_COLOR_MULTIPLY_DISABLE = 0,
+    gcv2D_GLOBAL_COLOR_MULTIPLY_ALPHA,
+    gcv2D_GLOBAL_COLOR_MULTIPLY_COLOR
+}
+gce2D_GLOBAL_COLOR_MULTIPLY_MODE;
+
+/* Alpha blending factor modes. */
+typedef enum _gceSURF_BLEND_FACTOR_MODE
+{
+    gcvSURF_BLEND_ZERO = 0,
+    gcvSURF_BLEND_ONE,
+    gcvSURF_BLEND_STRAIGHT,
+    gcvSURF_BLEND_INVERSED,
+    gcvSURF_BLEND_COLOR,
+    gcvSURF_BLEND_COLOR_INVERSED,
+    gcvSURF_BLEND_SRC_ALPHA_SATURATED,
+    gcvSURF_BLEND_STRAIGHT_NO_CROSS,
+    gcvSURF_BLEND_INVERSED_NO_CROSS,
+    gcvSURF_BLEND_COLOR_NO_CROSS,
+    gcvSURF_BLEND_COLOR_INVERSED_NO_CROSS,
+    gcvSURF_BLEND_SRC_ALPHA_SATURATED_CROSS
+}
+gceSURF_BLEND_FACTOR_MODE;
+
+/* Alpha blending porter duff rules. */
+typedef enum _gce2D_PORTER_DUFF_RULE
+{
+    gcvPD_CLEAR = 0,
+    gcvPD_SRC,
+    gcvPD_SRC_OVER,
+    gcvPD_DST_OVER,
+    gcvPD_SRC_IN,
+    gcvPD_DST_IN,
+    gcvPD_SRC_OUT,
+    gcvPD_DST_OUT,
+    gcvPD_SRC_ATOP,
+    gcvPD_DST_ATOP,
+    gcvPD_ADD,
+    gcvPD_XOR,
+    gcvPD_DST
+}
+gce2D_PORTER_DUFF_RULE;
+
+/* Alpha blending factor modes. */
+typedef enum _gce2D_YUV_COLOR_MODE
+{
+    gcv2D_YUV_601= 0,
+    gcv2D_YUV_709
+}
+gce2D_YUV_COLOR_MODE;
+
+/* 2D Rotation and flipping. */
+typedef enum _gce2D_ORIENTATION
+{
+    gcv2D_0_DEGREE = 0,
+    gcv2D_90_DEGREE,
+    gcv2D_180_DEGREE,
+    gcv2D_270_DEGREE,
+    gcv2D_X_FLIP,
+    gcv2D_Y_FLIP
+}
+gce2D_ORIENTATION;
+
+typedef enum _gce2D_COMMAND
+{
+    gcv2D_CLEAR = 0,
+    gcv2D_LINE,
+    gcv2D_BLT,
+    gcv2D_STRETCH,
+    gcv2D_HOR_FILTER,
+    gcv2D_VER_FILTER,
+    gcv2D_MULTI_SOURCE_BLT,
+}
+gce2D_COMMAND;
+
+#ifndef VIVANTE_NO_3D
+/* Texture functions. */
+typedef enum _gceTEXTURE_FUNCTION
+{
+    gcvTEXTURE_DUMMY = 0,
+    gcvTEXTURE_REPLACE = 0,
+    gcvTEXTURE_MODULATE,
+    gcvTEXTURE_ADD,
+    gcvTEXTURE_ADD_SIGNED,
+    gcvTEXTURE_INTERPOLATE,
+    gcvTEXTURE_SUBTRACT,
+    gcvTEXTURE_DOT3
+}
+gceTEXTURE_FUNCTION;
+
+/* Texture sources. */
+typedef enum _gceTEXTURE_SOURCE
+{
+    gcvCOLOR_FROM_TEXTURE = 0,
+    gcvCOLOR_FROM_CONSTANT_COLOR,
+    gcvCOLOR_FROM_PRIMARY_COLOR,
+    gcvCOLOR_FROM_PREVIOUS_COLOR
+}
+gceTEXTURE_SOURCE;
+
+/* Texture source channels. */
+typedef enum _gceTEXTURE_CHANNEL
+{
+    gcvFROM_COLOR = 0,
+    gcvFROM_ONE_MINUS_COLOR,
+    gcvFROM_ALPHA,
+    gcvFROM_ONE_MINUS_ALPHA
+}
+gceTEXTURE_CHANNEL;
+#endif /* VIVANTE_NO_3D */
+
+/* Filter types. */
+typedef enum _gceFILTER_TYPE
+{
+    gcvFILTER_SYNC = 0,
+    gcvFILTER_BLUR,
+    gcvFILTER_USER
+}
+gceFILTER_TYPE;
+
+/* Filter pass types. */
+typedef enum _gceFILTER_PASS_TYPE
+{
+    gcvFILTER_HOR_PASS = 0,
+    gcvFILTER_VER_PASS
+}
+gceFILTER_PASS_TYPE;
+
+/* Endian hints. */
+typedef enum _gceENDIAN_HINT
+{
+    gcvENDIAN_NO_SWAP = 0,
+    gcvENDIAN_SWAP_WORD,
+    gcvENDIAN_SWAP_DWORD
+}
+gceENDIAN_HINT;
+
+/* Tiling modes. */
+typedef enum _gceTILING
+{
+    gcvLINEAR = 0,
+    gcvTILED,
+    gcvSUPERTILED,
+    gcvMULTI_TILED,
+    gcvMULTI_SUPERTILED,
+    gcvMINORTILED,
+}
+gceTILING;
+
+/* 2D pattern type. */
+typedef enum _gce2D_PATTERN
+{
+    gcv2D_PATTERN_SOLID = 0,
+    gcv2D_PATTERN_MONO,
+    gcv2D_PATTERN_COLOR,
+    gcv2D_PATTERN_INVALID
+}
+gce2D_PATTERN;
+
+/* 2D source type. */
+typedef enum _gce2D_SOURCE
+{
+    gcv2D_SOURCE_MASKED = 0,
+    gcv2D_SOURCE_MONO,
+    gcv2D_SOURCE_COLOR,
+    gcv2D_SOURCE_INVALID
+}
+gce2D_SOURCE;
+
+/* Pipes. */
+typedef enum _gcePIPE_SELECT
+{
+    gcvPIPE_INVALID = ~0,
+    gcvPIPE_3D      =  0,
+    gcvPIPE_2D
+}
+gcePIPE_SELECT;
+
+/* Hardware type. */
+typedef enum _gceHARDWARE_TYPE
+{
+    gcvHARDWARE_INVALID = 0x00,
+    gcvHARDWARE_3D      = 0x01,
+    gcvHARDWARE_2D      = 0x02,
+    gcvHARDWARE_VG      = 0x04,
+
+    gcvHARDWARE_3D2D    = gcvHARDWARE_3D | gcvHARDWARE_2D
+}
+gceHARDWARE_TYPE;
+
+#define gcdCHIP_COUNT               3
+
+typedef enum _gceMMU_MODE
+{
+    gcvMMU_MODE_1K,
+    gcvMMU_MODE_4K,
+} gceMMU_MODE;
+
+/* User signal command codes. */
+typedef enum _gceUSER_SIGNAL_COMMAND_CODES
+{
+    gcvUSER_SIGNAL_CREATE,
+    gcvUSER_SIGNAL_DESTROY,
+    gcvUSER_SIGNAL_SIGNAL,
+    gcvUSER_SIGNAL_WAIT,
+    gcvUSER_SIGNAL_MAP,
+    gcvUSER_SIGNAL_UNMAP,
+}
+gceUSER_SIGNAL_COMMAND_CODES;
+
+/* Event locations. */
+typedef enum _gceKERNEL_WHERE
+{
+    gcvKERNEL_COMMAND,
+    gcvKERNEL_VERTEX,
+    gcvKERNEL_TRIANGLE,
+    gcvKERNEL_TEXTURE,
+    gcvKERNEL_PIXEL,
+}
+gceKERNEL_WHERE;
+
+#if gcdENABLE_VG
+/* Hardware blocks. */
+typedef enum _gceBLOCK
+{
+	gcvBLOCK_COMMAND,
+	gcvBLOCK_TESSELLATOR,
+	gcvBLOCK_TESSELLATOR2,
+	gcvBLOCK_TESSELLATOR3,
+	gcvBLOCK_RASTER,
+	gcvBLOCK_VG,
+	gcvBLOCK_VG2,
+	gcvBLOCK_VG3,
+	gcvBLOCK_PIXEL,
+
+	/* Number of defined blocks. */
+	gcvBLOCK_COUNT
+}
+gceBLOCK;
+#endif
+
+/* gcdDUMP message type. */
+typedef enum _gceDEBUG_MESSAGE_TYPE
+{
+    gcvMESSAGE_TEXT,
+    gcvMESSAGE_DUMP
+}
+gceDEBUG_MESSAGE_TYPE;
+
+/******************************************************************************\
+****************************** Object Declarations *****************************
+\******************************************************************************/
+
+typedef struct _gckCONTEXT          * gckCONTEXT;
+typedef struct _gcoCMDBUF           * gcoCMDBUF;
+typedef struct _gcsSTATE_DELTA      * gcsSTATE_DELTA_PTR;
+typedef struct _gcsQUEUE            * gcsQUEUE_PTR;
+typedef struct _gcoQUEUE            * gcoQUEUE;
+typedef struct _gcsHAL_INTERFACE    * gcsHAL_INTERFACE_PTR;
+typedef struct _gcs2D_PROFILE       * gcs2D_PROFILE_PTR;
+
+#if gcdENABLE_VG
+typedef struct _gcoVGHARDWARE *			gcoVGHARDWARE;
+typedef struct _gcoVGBUFFER *           gcoVGBUFFER;
+typedef struct _gckVGHARDWARE *         gckVGHARDWARE;
+typedef struct _gcsVGCONTEXT *			gcsVGCONTEXT_PTR;
+typedef struct _gcsVGCONTEXT_MAP *		gcsVGCONTEXT_MAP_PTR;
+typedef struct _gcsVGCMDQUEUE *			gcsVGCMDQUEUE_PTR;
+typedef struct _gcsTASK_MASTER_TABLE *	gcsTASK_MASTER_TABLE_PTR;
+typedef struct _gckVGKERNEL *			gckVGKERNEL;
+typedef void *					        gctTHREAD;
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __gc_hal_enum_h_ */
diff --git a/attic/gc_hal_kernel_buffer.h b/attic/gc_hal_kernel_buffer.h
new file mode 100644
index 0000000..24edc0b
--- /dev/null
+++ b/attic/gc_hal_kernel_buffer.h
@@ -0,0 +1,192 @@
+/****************************************************************************
+*
+*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*
+*    This program is free software; you can redistribute it and/or modify
+*    it under the terms of the GNU General Public License as published by
+*    the Free Software Foundation; either version 2 of the license, or
+*    (at your option) any later version.
+*
+*    This program is distributed in the hope that it will be useful,
+*    but WITHOUT ANY WARRANTY; without even the implied warranty of
+*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+*    GNU General Public License for more details.
+*
+*    You should have received a copy of the GNU General Public License
+*    along with this program; if not write to the Free Software
+*    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*
+*****************************************************************************/
+
+
+
+
+#ifndef __gc_hal_kernel_buffer_h_
+#define __gc_hal_kernel_buffer_h_
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/******************************************************************************\
+************************ Command Buffer and Event Objects **********************
+\******************************************************************************/
+
+/* The number of context buffers per user. */
+#define gcdCONTEXT_BUFFER_COUNT 2
+
+/* State delta record. */
+typedef struct _gcsSTATE_DELTA_RECORD * gcsSTATE_DELTA_RECORD_PTR;
+typedef struct _gcsSTATE_DELTA_RECORD
+{
+    /* State address. */
+    gctUINT                     address;
+
+    /* State mask. */
+    gctUINT32                   mask;
+
+    /* State data. */
+    gctUINT32                   data;
+}
+gcsSTATE_DELTA_RECORD;
+
+/* State delta. */
+typedef struct _gcsSTATE_DELTA
+{
+    /* For debugging: the number of delta in the order of creation. */
+#if gcmIS_DEBUG(gcdDEBUG_CODE)
+    gctUINT                     num;
+#endif
+
+    /* For dumping. */
+#if gcdDUMP
+    gcoOS                       os;
+#endif
+
+    /* Main state delta ID. Every time state delta structure gets reinitialized,
+       main ID is incremented. If main state ID overflows, all map entry IDs get
+       reinitialized to make sure there is no potential erroneous match after
+       the overflow.*/
+    gctUINT                     id;
+
+    /* The number of contexts pending modification by the delta. */
+    gctINT                      refCount;
+
+    /* Vertex element count for the delta buffer. */
+    gctUINT                     elementCount;
+
+    /* Number of states currently stored in the record array. */
+    gctUINT                     recordCount;
+
+    /* Record array; holds all modified states. */
+    gcsSTATE_DELTA_RECORD_PTR   recordArray;
+
+    /* Map entry ID is used for map entry validation. If map entry ID does not
+       match the main state delta ID, the entry and the corresponding state are
+       considered not in use. */
+    gctUINT_PTR                 mapEntryID;
+    gctUINT                     mapEntryIDSize;
+
+    /* If the map entry ID matches the main state delta ID, index points to
+       the state record in the record array. */
+    gctUINT_PTR                 mapEntryIndex;
+
+    /* Previous and next state deltas. */
+    gcsSTATE_DELTA_PTR          prev;
+    gcsSTATE_DELTA_PTR          next;
+}
+gcsSTATE_DELTA;
+
+/* Command buffer object. */
+struct _gcoCMDBUF
+{
+    /* The object. */
+    gcsOBJECT                   object;
+
+    /* Command buffer entry and exit pipes. */
+    gcePIPE_SELECT              entryPipe;
+    gcePIPE_SELECT              exitPipe;
+
+    /* Feature usage flags. */
+    gctBOOL                     using2D;
+    gctBOOL                     using3D;
+    gctBOOL                     usingFilterBlit;
+    gctBOOL                     usingPalette;
+
+    /* Physical address of command buffer. */
+    gctPHYS_ADDR                physical;
+
+    /* Logical address of command buffer. */
+    gctPOINTER                  logical;
+
+    /* Number of bytes in command buffer. */
+    gctSIZE_T                   bytes;
+
+    /* Start offset into the command buffer. */
+    gctUINT32                   startOffset;
+
+    /* Current offset into the command buffer. */
+    gctUINT32                   offset;
+
+    /* Number of free bytes in command buffer. */
+    gctSIZE_T                   free;
+
+    /* Location of the last reserved area. */
+    gctPOINTER                  lastReserve;
+    gctUINT                     lastOffset;
+
+#if gcdSECURE_USER
+    /* Hint array for the current command buffer. */
+    gctUINT                     hintArraySize;
+    gctUINT32_PTR               hintArray;
+    gctUINT32_PTR               hintArrayTail;
+#endif
+
+#if gcmIS_DEBUG(gcdDEBUG_CODE)
+    /* Last load state command location and hardware address. */
+    gctUINT32_PTR               lastLoadStatePtr;
+    gctUINT32                   lastLoadStateAddress;
+    gctUINT32                   lastLoadStateCount;
+#endif
+};
+
+typedef struct _gcsQUEUE
+{
+    /* Pointer to next gcsQUEUE structure. */
+    gcsQUEUE_PTR                next;
+
+    /* Event information. */
+    gcsHAL_INTERFACE            iface;
+}
+gcsQUEUE;
+
+/* Event queue. */
+struct _gcoQUEUE
+{
+    /* The object. */
+    gcsOBJECT                   object;
+
+    /* Pointer to current event queue. */
+    gcsQUEUE_PTR                head;
+    gcsQUEUE_PTR                tail;
+
+#ifdef __QNXNTO__
+    /* Buffer for records. */
+    gcsQUEUE_PTR                records;
+    gctUINT32                   freeBytes;
+    gctUINT32                   offset;
+#else
+    /* List of free records. */
+    gcsQUEUE_PTR                freeList;
+#endif
+    #define gcdIN_QUEUE_RECORD_LIMIT 16
+    /* Number of records currently in queue */
+    gctUINT32                   recordCount;
+};
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __gc_hal_kernel_buffer_h_ */
diff --git a/attic/gc_hal_md5.h b/attic/gc_hal_md5.h
new file mode 100644
index 0000000..ac0f973
--- /dev/null
+++ b/attic/gc_hal_md5.h
@@ -0,0 +1,112 @@
+/****************************************************************************
+*
+*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*
+*    This program is free software; you can redistribute it and/or modify
+*    it under the terms of the GNU General Public License as published by
+*    the Free Software Foundation; either version 2 of the license, or
+*    (at your option) any later version.
+*
+*    This program is distributed in the hope that it will be useful,
+*    but WITHOUT ANY WARRANTY; without even the implied warranty of
+*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+*    GNU General Public License for more details.
+*
+*    You should have received a copy of the GNU General Public License
+*    along with this program; if not write to the Free Software
+*    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*
+*****************************************************************************/
+
+
+/*
+  Copyright (C) 1999, 2002 Aladdin Enterprises.  All rights reserved.
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+
+  L. Peter Deutsch
+  ghost@aladdin.com
+
+ */
+/* $Id: gc_hal_md5.h,v 1.1.6.1 2012/02/09 00:22:42 semih.demirer Exp $ */
+/*
+  Independent implementation of MD5 (RFC 1321).
+
+  This code implements the MD5 Algorithm defined in RFC 1321, whose
+  text is available at
+	http://www.ietf.org/rfc/rfc1321.txt
+  The code is derived from the text of the RFC, including the test suite
+  (section A.5) but excluding the rest of Appendix A.  It does not include
+  any code or documentation that is identified in the RFC as being
+  copyrighted.
+
+  The original and principal author of md5.h is L. Peter Deutsch
+  <ghost@aladdin.com>.  Other authors are noted in the change history
+  that follows (in reverse chronological order):
+
+  2002-04-13 lpd Removed support for non-ANSI compilers; removed
+	references to Ghostscript; clarified derivation from RFC 1321;
+	now handles byte order either statically or dynamically.
+  1999-11-04 lpd Edited comments slightly for automatic TOC extraction.
+  1999-10-18 lpd Fixed typo in header comment (ansi2knr rather than md5);
+	added conditionalization for C++ compilation from Martin
+	Purschke <purschke@bnl.gov>.
+  1999-05-03 lpd Original version.
+ */
+
+
+#ifndef __gc_hal_md5_h_
+#define __gc_hal_md5_h_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*
+ * This package supports both compile-time and run-time determination of CPU
+ * byte order.  If ARCH_IS_BIG_ENDIAN is defined as 0, the code will be
+ * compiled to run only on little-endian CPUs; if ARCH_IS_BIG_ENDIAN is
+ * defined as non-zero, the code will be compiled to run only on big-endian
+ * CPUs; if ARCH_IS_BIG_ENDIAN is not defined, the code will be compiled to
+ * run on either big- or little-endian CPUs, but will run slightly less
+ * efficiently on either one than if ARCH_IS_BIG_ENDIAN is defined.
+ */
+
+typedef unsigned char gctMD5_Byte; /* 8-bit byte */
+typedef unsigned int gctMD5_Word; /* 32-bit word */
+
+/* Define the state of the MD5 Algorithm. */
+typedef struct _gcsMD5_State {
+    gctMD5_Word count[2];	/* message length in bits, lsw first */
+    gctMD5_Word abcd[4];		/* digest buffer */
+    gctMD5_Byte buf[64];		/* accumulate block */
+} gcsMD5_State;
+
+/* Initialize the algorithm. */
+void gcoMD5_Init(gcsMD5_State *pms);
+
+/* Append a string to the message. */
+void gcoMD5_Append(gcsMD5_State *pms, const gctMD5_Byte *data, int nbytes);
+
+/* Finish the message and return the digest. */
+void gcoMD5_Finish(gcsMD5_State *pms, gctMD5_Byte digest[16]);
+
+#ifdef __cplusplus
+}  /* end extern "C" */
+#endif
+
+#endif /* md5_INCLUDED */
diff --git a/attic/gc_hal_mem.h b/attic/gc_hal_mem.h
new file mode 100644
index 0000000..e64f7e7
--- /dev/null
+++ b/attic/gc_hal_mem.h
@@ -0,0 +1,532 @@
+/****************************************************************************
+*
+*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*
+*    This program is free software; you can redistribute it and/or modify
+*    it under the terms of the GNU General Public License as published by
+*    the Free Software Foundation; either version 2 of the license, or
+*    (at your option) any later version.
+*
+*    This program is distributed in the hope that it will be useful,
+*    but WITHOUT ANY WARRANTY; without even the implied warranty of
+*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+*    GNU General Public License for more details.
+*
+*    You should have received a copy of the GNU General Public License
+*    along with this program; if not write to the Free Software
+*    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*
+*****************************************************************************/
+
+
+
+
+/*
+**	Include file for the local memory management.
+*/
+
+#ifndef __gc_hal_mem_h_
+#define __gc_hal_mem_h_
+#ifndef VIVANTE_NO_3D
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*******************************************************************************
+**  Usage:
+
+	The macros to declare MemPool type and functions are
+	gcmMEM_DeclareFSMemPool (Type, TypeName, Prefix)
+	gcmMEM_DeclareVSMemPool (Type, TypeName, Prefix)
+	gcmMEM_DeclareAFSMemPool(Type, TypeName, Prefix)
+
+	The data structures for MemPool are
+	typedef struct _gcsMEM_FS_MEM_POOL *	gcsMEM_FS_MEM_POOL;
+	typedef struct _gcsMEM_VS_MEM_POOL *	gcsMEM_VS_MEM_POOL;
+	typedef struct _gcsMEM_AFS_MEM_POOL *	gcsMEM_AFS_MEM_POOL;
+
+	The MemPool constructor and destructor functions are
+	gcfMEM_InitFSMemPool(gcsMEM_FS_MEM_POOL *, gcoOS, gctUINT, gctUINT);
+	gcfMEM_FreeFSMemPool(gcsMEM_FS_MEM_POOL *);
+	gcfMEM_InitVSMemPool(gcsMEM_VS_MEM_POOL *, gcoOS, gctUINT, gctBOOL);
+	gcfMEM_FreeVSMemPool(gcsMEM_VS_MEM_POOL *);
+	gcfMEM_InitAFSMemPool(gcsMEM_AFS_MEM_POOL *, gcoOS, gctUINT);
+	gcfMEM_FreeAFSMemPool(gcsMEM_AFS_MEM_POOL *);
+
+	FS:  for Fixed-Size data structures
+	VS:  for Variable-size data structures
+	AFS: for Array of Fixed-Size data structures
+
+
+	// Example 1: For a fixed-size data structure, struct gcsNode.
+	// It is used locally in a file, so the functions are static without prefix.
+	// At top level, declear allocate and free functions.
+	// The first argument is the data type.
+	// The second armument is the short name used in the fuctions.
+	gcmMEM_DeclareFSMemPool(struct gcsNode, Node, );
+
+	// The previous macro creates two inline functions,
+	// _AllocateNode and _FreeNode.
+
+	// In function or struct
+	gcsMEM_FS_MEM_POOL nodeMemPool;
+
+	// In function,
+	struct gcsNode * node;
+	gceSTATUS status;
+
+	// Before using the memory pool, initialize it.
+	// The second argument is the gcoOS object.
+	// The third argument is the number of data structures to allocate for each chunk.
+	status = gcfMEM_InitFSMemPool(&nodeMemPool, os, 100, sizeof(struct gcsNode));
+	...
+
+	// Allocate a node.
+	status = _AllocateNode(nodeMemPool, &node);
+	...
+	// Free a node.
+	_FreeNode(nodeMemPool, node);
+
+	// After using the memory pool, free it.
+	gcfMEM_FreeFSMemPool(&nodeMemPool);
+
+
+	// Example 2: For array of fixed-size data structures, struct gcsNode.
+	// It is used in several files, so the functions are extern with prefix.
+	// At top level, declear allocate and free functions.
+	// The first argument is the data type, and the second one is the short name
+	// used in the fuctions.
+	gcmMEM_DeclareAFSMemPool(struct gcsNode, NodeArray, gcfOpt);
+
+	// The previous macro creates two inline functions,
+	// gcfOpt_AllocateNodeArray and gcfOpt_FreeNodeArray.
+
+	// In function or struct
+	gcsMEM_AFS_MEM_POOL nodeArrayMemPool;
+
+	// In function,
+	struct gcsNode * nodeArray;
+	gceSTATUS status;
+
+	// Before using the array memory pool, initialize it.
+	// The second argument is the gcoOS object, the third is the number of data
+	// structures to allocate for each chunk.
+	status = gcfMEM_InitAFSMemPool(&nodeArrayMemPool, os, sizeof(struct gcsNode));
+	...
+
+	// Allocate a node array of size 100.
+	status = gcfOpt_AllocateNodeArray(nodeArrayMemPool, &nodeArray, 100);
+	...
+	// Free a node array.
+	gcfOpt_FreeNodeArray(&nodeArrayMemPool, nodeArray);
+
+	// After using the array memory pool, free it.
+	gcfMEM_FreeAFSMemPool(&nodeArrayMemPool);
+
+*******************************************************************************/
+
+/*******************************************************************************
+**	To switch back to use gcoOS_Allocate and gcoOS_Free, add
+**	#define USE_LOCAL_MEMORY_POOL 0
+**	before including this file.
+*******************************************************************************/
+#ifndef USE_LOCAL_MEMORY_POOL
+/*
+    USE_LOCAL_MEMORY_POOL
+
+    This define enables the local memory management to improve performance.
+*/
+#define USE_LOCAL_MEMORY_POOL		1
+#endif
+
+/*******************************************************************************
+**							Memory Pool Data Structures
+*******************************************************************************/
+#if USE_LOCAL_MEMORY_POOL
+	typedef struct _gcsMEM_FS_MEM_POOL *	gcsMEM_FS_MEM_POOL;
+	typedef struct _gcsMEM_VS_MEM_POOL *	gcsMEM_VS_MEM_POOL;
+	typedef struct _gcsMEM_AFS_MEM_POOL *	gcsMEM_AFS_MEM_POOL;
+#else
+	typedef gcoOS	gcsMEM_FS_MEM_POOL;
+	typedef gcoOS	gcsMEM_VS_MEM_POOL;
+	typedef gcoOS	gcsMEM_AFS_MEM_POOL;
+#endif
+
+/*******************************************************************************
+**							Memory Pool Macros
+*******************************************************************************/
+#if USE_LOCAL_MEMORY_POOL
+#define gcmMEM_DeclareFSMemPool(Type, TypeName, Prefix) \
+gceSTATUS \
+Prefix##_Allocate##TypeName( \
+	gcsMEM_FS_MEM_POOL		MemPool, \
+	Type **					Pointer \
+	) \
+{ \
+	return(gcfMEM_FSMemPoolGetANode(MemPool, (gctPOINTER *) Pointer)); \
+} \
+ \
+gceSTATUS \
+Prefix##_CAllocate##TypeName( \
+	gcsMEM_FS_MEM_POOL		MemPool, \
+	Type **					Pointer \
+	) \
+{ \
+	gceSTATUS				status; \
+    gcmHEADER_ARG("MemPool=0x%x Pointer=0x%x", MemPool, Pointer); \
+	gcmERR_RETURN(gcfMEM_FSMemPoolGetANode(MemPool, (gctPOINTER *) Pointer)); \
+	gcmVERIFY_OK(gcoOS_ZeroMemory(*(gctPOINTER *) Pointer, gcmSIZEOF(Type))); \
+    gcmFOOTER(); \
+	return gcvSTATUS_OK; \
+} \
+ \
+gceSTATUS \
+Prefix##_Free##TypeName( \
+	gcsMEM_FS_MEM_POOL		MemPool, \
+	Type *					Pointer \
+	) \
+{ \
+    gceSTATUS				status; \
+    gcmHEADER_ARG("MemPool=0x%x Pointer=0x%x", MemPool, Pointer); \
+    status = gcfMEM_FSMemPoolFreeANode(MemPool, (gctPOINTER) Pointer); \
+    gcmFOOTER(); \
+	return status; \
+} \
+ \
+gceSTATUS \
+Prefix##_Free##TypeName##List( \
+	gcsMEM_FS_MEM_POOL		MemPool, \
+	Type *					FirstPointer, \
+	Type *					LastPointer \
+	) \
+{ \
+    gceSTATUS               status; \
+    gcmHEADER_ARG("MemPool=0x%x FirstPointer=0x%x LastPointer=0x%x", MemPool, FirstPointer, LastPointer); \
+    status = gcfMEM_FSMemPoolFreeAList(MemPool, (gctPOINTER) FirstPointer, (gctPOINTER) LastPointer); \
+    gcmFOOTER(); \
+	return status; \
+}
+
+#define gcmMEM_DeclareVSMemPool(Type, TypeName, Prefix) \
+gceSTATUS \
+Prefix##_Allocate##TypeName( \
+	gcsMEM_FS_MEM_POOL		MemPool, \
+	Type **					Pointer, \
+	gctUINT					Size \
+	) \
+{ \
+    gceSTATUS               status;\
+    gcmHEADER_ARG("MemPool=0x%x Pointer=0x%x Size=%u", MemPool, Pointer, Size); \
+    status = gcfMEM_VSMemPoolGetANode(MemPool, Size, (gctPOINTER *) Pointer); \
+    gcmFOOTER(); \
+	return status; \
+} \
+ \
+gceSTATUS \
+ Prefix##_CAllocate##TypeName( \
+	gcsMEM_FS_MEM_POOL		MemPool, \
+	Type **					Pointer, \
+	gctUINT					Size \
+	) \
+{ \
+	gceSTATUS				status; \
+    gcmHEADER_ARG("MemPool=0x%x Pointer=0x%x Size=%u", MemPool, Pointer, Size); \
+	gcmERR_RETURN(gcfMEM_VSMemPoolGetANode(MemPool, Size, (gctPOINTER *) Pointer)); \
+	gcmVERIFY_OK(gcoOS_ZeroMemory(*(gctPOINTER *) Pointer, size)); \
+    gcmFOOTER(); \
+	return gcvSTATUS_OK; \
+} \
+ \
+gceSTATUS \
+Prefix##_Free##TypeName( \
+	gcsMEM_FS_MEM_POOL		MemPool, \
+	Type *					Pointer \
+	) \
+{ \
+    gceSTATUS               status; \
+    gcmHEADER_ARG("MemPool=0x%x Pointer=0x%x", MemPool, Pinter); \
+    status = gcfMEM_VSMemPoolFreeANode(MemPool, (gctPOINTER) Pointer); \
+    gcmFOOTER(); \
+	return status; \
+}
+
+#define gcmMEM_DeclareAFSMemPool(Type, TypeName, Prefix) \
+gceSTATUS \
+Prefix##_Allocate##TypeName( \
+	gcsMEM_AFS_MEM_POOL		MemPool, \
+	Type **					Pointer, \
+	gctUINT					Count \
+	) \
+{ \
+    gceSTATUS               status; \
+    gcmHEADER_ARG("MemPool=0x%x Pointer=0x%x Count=%u", MemPool, Pointer, Count); \
+    status = gcfMEM_AFSMemPoolGetANode(MemPool, Count, (gctPOINTER *) Pointer); \
+    gcmFOOTER(); \
+	return status; \
+} \
+ \
+gceSTATUS \
+Prefix##_CAllocate##TypeName( \
+	gcsMEM_AFS_MEM_POOL		MemPool, \
+	Type **					Pointer, \
+	gctUINT					Count \
+	) \
+{ \
+	gceSTATUS				status; \
+    gcmHEADER_ARG("MemPool=0x%x Pointer=0x%x Count=%u", MemPool, Pointer, Count); \
+	gcmERR_RETURN(gcfMEM_AFSMemPoolGetANode(MemPool, Count, (gctPOINTER *) Pointer)); \
+	gcmVERIFY_OK(gcoOS_ZeroMemory(*(gctPOINTER *) Pointer, Count * gcmSIZEOF(Type))); \
+    gcmFOOTER(); \
+	return gcvSTATUS_OK; \
+} \
+ \
+gceSTATUS \
+Prefix##_Free##TypeName( \
+	gcsMEM_AFS_MEM_POOL		MemPool, \
+	Type *					Pointer \
+	) \
+{ \
+    gceSTATUS               status; \
+    gcmHEADER_ARG("MemPool=0x%x Pointer=0x%x", MemPool, Pointer); \
+    status = gcfMEM_AFSMemPoolFreeANode(MemPool, (gctPOINTER) Pointer); \
+    gcmFOOTER(); \
+	return status; \
+}
+
+#else
+
+#define gcmMEM_DeclareFSMemPool(Type, TypeName, Prefix) \
+gceSTATUS \
+Prefix##_Allocate##TypeName( \
+	gcsMEM_FS_MEM_POOL		MemPool, \
+	Type **					Pointer \
+	) \
+{ \
+    gceSTATUS               status; \
+    gcmHEADER_ARG("MemPool=0x%x Pointer=0x%x", MemPool, Pointer); \
+    status = gcoOS_Allocate(MemPool, \
+							gcmSIZEOF(Type), \
+							(gctPOINTER *) Pointer); \
+    gcmFOOTER(); \
+	return status; \
+} \
+ \
+gceSTATUS \
+Prefix##_CAllocate##TypeName( \
+	gcsMEM_FS_MEM_POOL		MemPool, \
+	Type **					Pointer \
+	) \
+{ \
+	gceSTATUS				status; \
+    gcmHEADER_ARG("MemPool=0x%x Pointer=0x%x", MemPool, Pointer); \
+	gcmERR_RETURN(gcoOS_Allocate(MemPool, \
+							gcmSIZEOF(Type), \
+							(gctPOINTER *) Pointer)); \
+	gcmVERIFY_OK(gcoOS_ZeroMemory(*(gctPOINTER *) Pointer, gcmSIZEOF(Type))); \
+    gcmFOOTER(); \
+	return gcvSTATUS_OK; \
+} \
+ \
+gceSTATUS \
+Prefix##_Free##TypeName( \
+	gcsMEM_FS_MEM_POOL		MemPool, \
+	Type *					Pointer \
+	) \
+{ \
+    gceSTATUS				status; \
+    gcmHEADER_ARG("MemPool=0x%x Pointer=0x%x", MemPool, Pointer); \
+    status = gcmOS_SAFE_FREE(MemPool, Pointer); \
+    gcmFOOTER(); \
+	return status; \
+}
+
+#define gcmMEM_DeclareVSMemPool(Type, TypeName, Prefix) \
+gceSTATUS \
+Prefix##_Allocate##TypeName( \
+	gcsMEM_VS_MEM_POOL		MemPool, \
+	Type **					Pointer, \
+	gctUINT					Size \
+	) \
+{ \
+    gceSTATUS				status; \
+    gcmHEADER_ARG("MemPool=0x%x Pointer=0x%x Size=%u", MemPool, Pointer, Size); \
+    status = gcoOS_Allocate(MemPool, \
+							Size, \
+							(gctPOINTER *) Pointer); \
+    gcmFOOTER(); \
+	return status; \
+} \
+ \
+gceSTATUS \
+Prefix##_CAllocate##TypeName( \
+	gcsMEM_VS_MEM_POOL		MemPool, \
+	Type **					Pointer, \
+	gctUINT					Size \
+	) \
+{ \
+	gceSTATUS				status; \
+    gcmHEADER_ARG("MemPool=0x%x Pointer=0x%x Size=%u", MemPool, Pointer, Size); \
+	gcmERR_RETURN(gcoOS_Allocate(MemPool, \
+							Size, \
+							(gctPOINTER *) Pointer)); \
+	gcmVERIFY_OK(gcoOS_ZeroMemory(*(gctPOINTER *) Pointer, Size)); \
+    gcmFOOTER(); \
+	return gcvSTATUS_OK; \
+} \
+ \
+gceSTATUS \
+Prefix##_Free##TypeName( \
+	gcsMEM_VS_MEM_POOL		MemPool, \
+	Type *					Pointer \
+	) \
+{ \
+    gceSTATUS				status; \
+    gcmHEADER_ARG("MemPool=0x%x Pointer=0x%x", MemPool, Pointer); \
+    status = gcmOS_SAFE_FREE(MemPool, Pointer); \
+    gcmFOOTER(); \
+	return status; \
+}
+
+#define gcmMEM_DeclareAFSMemPool(Type, TypeName, Prefix) \
+gceSTATUS \
+Prefix##_Allocate##TypeName( \
+	gcsMEM_AFS_MEM_POOL		MemPool, \
+	Type **					Pointer, \
+	gctUINT					Count \
+	) \
+{ \
+    gceSTATUS				status; \
+    gcmHEADER_ARG("MemPool=0x%x Pointer=0x%x Count=%u", MemPool, Pointer, Count); \
+    status = gcoOS_Allocate(MemPool, \
+							Count * gcmSIZEOF(Type), \
+							(gctPOINTER *) Pointer); \
+    gcmFOOTER(); \
+	return status; \
+} \
+ \
+gceSTATUS \
+Prefix##_CAllocate##TypeName( \
+	gcsMEM_AFS_MEM_POOL		MemPool, \
+	Type **					Pointer, \
+	gctUINT					Count \
+	) \
+{ \
+	gceSTATUS				status; \
+    gcmHEADER_ARG("MemPool=0x%x Pointer=0x%x Count=%u", MemPool, Pointer, Count); \
+	gcmERR_RETURN(gcoOS_Allocate(MemPool, \
+							Count * gcmSIZEOF(Type), \
+							(gctPOINTER *) Pointer)); \
+	gcmVERIFY_OK(gcoOS_ZeroMemory(*(gctPOINTER *) Pointer, Count * gcmSIZEOF(Type))); \
+    gcmFOOTER(); \
+	return gcvSTATUS_OK; \
+} \
+ \
+gceSTATUS \
+Prefix##_Free##TypeName( \
+	gcsMEM_AFS_MEM_POOL		MemPool, \
+	Type *					Pointer \
+	) \
+{ \
+    gceSTATUS				status; \
+    gcmHEADER_ARG("MemPool=0x%x Pointer=0x%x", MemPool, Pointer); \
+    status = gcmOS_SAFE_FREE(MemPool, Pointer); \
+    gcmFOOTER(); \
+	return status; \
+}
+#endif
+
+/*******************************************************************************
+**							Memory Pool Data Functions
+*******************************************************************************/
+gceSTATUS
+gcfMEM_InitFSMemPool(
+	IN gcsMEM_FS_MEM_POOL * MemPool,
+	IN gcoOS				OS,
+	IN gctUINT				NodeCount,
+	IN gctUINT				NodeSize
+	);
+
+gceSTATUS
+gcfMEM_FreeFSMemPool(
+	IN gcsMEM_FS_MEM_POOL * MemPool
+	);
+
+gceSTATUS
+gcfMEM_FSMemPoolGetANode(
+	IN gcsMEM_FS_MEM_POOL	MemPool,
+	OUT gctPOINTER *		Node
+	);
+
+gceSTATUS
+gcfMEM_FSMemPoolFreeANode(
+	IN gcsMEM_FS_MEM_POOL	MemPool,
+	IN gctPOINTER			Node
+	);
+
+gceSTATUS
+gcfMEM_FSMemPoolFreeAList(
+	IN gcsMEM_FS_MEM_POOL	MemPool,
+	IN gctPOINTER			FirstNode,
+	IN gctPOINTER			LastNode
+	);
+
+gceSTATUS
+gcfMEM_InitVSMemPool(
+	IN gcsMEM_VS_MEM_POOL * MemPool,
+	IN gcoOS				OS,
+	IN gctUINT				BlockSize,
+	IN gctBOOL				RecycleFreeNode
+	);
+
+gceSTATUS
+gcfMEM_FreeVSMemPool(
+	IN gcsMEM_VS_MEM_POOL * MemPool
+	);
+
+gceSTATUS
+gcfMEM_VSMemPoolGetANode(
+	IN gcsMEM_VS_MEM_POOL	MemPool,
+	IN gctUINT				Size,
+	IN gctUINT				Alignment,
+	OUT gctPOINTER *		Node
+	);
+
+gceSTATUS
+gcfMEM_VSMemPoolFreeANode(
+	IN gcsMEM_VS_MEM_POOL	MemPool,
+	IN gctPOINTER			Node
+	);
+
+gceSTATUS
+gcfMEM_InitAFSMemPool(
+	IN gcsMEM_AFS_MEM_POOL *MemPool,
+	IN gcoOS				OS,
+	IN gctUINT				NodeCount,
+	IN gctUINT				NodeSize
+	);
+
+gceSTATUS
+gcfMEM_FreeAFSMemPool(
+	IN gcsMEM_AFS_MEM_POOL *MemPool
+	);
+
+gceSTATUS
+gcfMEM_AFSMemPoolGetANode(
+	IN gcsMEM_AFS_MEM_POOL	MemPool,
+	IN gctUINT				Count,
+	OUT gctPOINTER *		Node
+	);
+
+gceSTATUS
+gcfMEM_AFSMemPoolFreeANode(
+	IN gcsMEM_AFS_MEM_POOL	MemPool,
+	IN gctPOINTER			Node
+	);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* VIVANTE_NO_3D */
+#endif /* __gc_hal_mem_h_ */
diff --git a/attic/gc_hal_options.h b/attic/gc_hal_options.h
new file mode 100644
index 0000000..d01804f
--- /dev/null
+++ b/attic/gc_hal_options.h
@@ -0,0 +1,756 @@
+/****************************************************************************
+*
+*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*
+*    This program is free software; you can redistribute it and/or modify
+*    it under the terms of the GNU General Public License as published by
+*    the Free Software Foundation; either version 2 of the license, or
+*    (at your option) any later version.
+*
+*    This program is distributed in the hope that it will be useful,
+*    but WITHOUT ANY WARRANTY; without even the implied warranty of
+*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+*    GNU General Public License for more details.
+*
+*    You should have received a copy of the GNU General Public License
+*    along with this program; if not write to the Free Software
+*    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*
+*****************************************************************************/
+
+
+
+
+#ifndef __gc_hal_options_h_
+#define __gc_hal_options_h_
+
+/*
+    gcdPRINT_VERSION
+
+        Print HAL version.
+*/
+#ifndef gcdPRINT_VERSION
+#   define gcdPRINT_VERSION                     0
+#endif
+
+/*
+    USE_NEW_LINUX_SIGNAL
+
+        This define enables the Linux kernel signaling between kernel and user.
+*/
+#ifndef USE_NEW_LINUX_SIGNAL
+#   define USE_NEW_LINUX_SIGNAL                 0
+#endif
+
+/*
+    NO_USER_DIRECT_ACCESS_FROM_KERNEL
+
+        This define enables the Linux kernel behavior accessing user memory.
+*/
+#ifndef NO_USER_DIRECT_ACCESS_FROM_KERNEL
+#   define NO_USER_DIRECT_ACCESS_FROM_KERNEL    0
+#endif
+
+/*
+    VIVANTE_PROFILER
+
+        This define enables the profiler.
+*/
+#ifndef VIVANTE_PROFILER
+#   define VIVANTE_PROFILER                     0
+#endif
+
+/*
+    gcdUSE_VG
+
+        Enable VG HAL layer (only for GC350).
+*/
+#ifndef gcdUSE_VG
+#   define gcdUSE_VG                            0
+#endif
+
+/*
+    USE_SW_FB
+
+        Set to 1 if the frame buffer memory cannot be accessed by the GPU.
+*/
+#ifndef USE_SW_FB
+#   define USE_SW_FB                            0
+#endif
+
+/*
+    USE_SUPER_SAMPLING
+
+        This define enables super-sampling support.
+*/
+#define USE_SUPER_SAMPLING                      0
+
+/*
+    PROFILE_HAL_COUNTERS
+
+        This define enables HAL counter profiling support.  HW and SHADER
+        counter profiling depends on this.
+*/
+#ifndef PROFILE_HAL_COUNTERS
+#   define PROFILE_HAL_COUNTERS                 1
+#endif
+
+/*
+    PROFILE_HW_COUNTERS
+
+        This define enables HW counter profiling support.
+*/
+#ifndef PROFILE_HW_COUNTERS
+#   define PROFILE_HW_COUNTERS                  1
+#endif
+
+/*
+    PROFILE_SHADER_COUNTERS
+
+        This define enables SHADER counter profiling support.
+*/
+#ifndef PROFILE_SHADER_COUNTERS
+#   define PROFILE_SHADER_COUNTERS              1
+#endif
+
+/*
+    COMMAND_PROCESSOR_VERSION
+
+        The version of the command buffer and task manager.
+*/
+#define COMMAND_PROCESSOR_VERSION               1
+
+/*
+    gcdDUMP
+
+        When set to 1, a dump of all states and memory uploads, as well as other
+        hardware related execution will be printed to the debug console.  This
+        data can be used for playing back applications.
+*/
+#ifndef gcdDUMP
+#   define gcdDUMP                              0
+#endif
+
+/*
+    gcdDUMP_API
+
+        When set to 1, a high level dump of the EGL and GL/VG APs's are
+        captured.
+*/
+#ifndef gcdDUMP_API
+#   define gcdDUMP_API                          0
+#endif
+
+/*
+    gcdDUMP_FRAMERATE
+        When set to a value other than zero, averaqe frame rate will be dumped.
+        The value set is the starting frame that the average will be calculated.
+        This is needed because sometimes first few frames are too slow to be included
+        in the average. Frame count starts from 1.
+*/
+#ifndef gcdDUMP_FRAMERATE
+#   define gcdDUMP_FRAMERATE					0
+#endif
+
+
+/*
+    gcdDUMP_IN_KERNEL
+
+        When set to 1, all dumps will happen in the kernel.  This is handy if
+        you want the kernel to dump its command buffers as well and the data
+        needs to be in sync.
+*/
+#ifndef gcdDUMP_IN_KERNEL
+#   define gcdDUMP_IN_KERNEL                    0
+#endif
+
+/*
+    gcdDUMP_COMMAND
+
+        When set to non-zero, the command queue will dump all incoming command
+        and context buffers as well as all other modifications to the command
+        queue.
+*/
+#ifndef gcdDUMP_COMMAND
+#   define gcdDUMP_COMMAND                      0
+#endif
+
+/*
+    gcdDUMP_FRAME_TGA
+
+    When set to a value other than 0, a dump of the frame specified by the value,
+    will be done into frame.tga. Frame count starts from 1.
+ */
+#ifndef gcdDUMP_FRAME_TGA
+#define gcdDUMP_FRAME_TGA                       0
+#endif
+/*
+    gcdNULL_DRIVER
+
+    Set to 1 for infinite speed hardware.
+    Set to 2 for bypassing the HAL.
+    Set to 3 for bypassing the drivers.
+*/
+#ifndef gcdNULL_DRIVER
+#   define gcdNULL_DRIVER  0
+#endif
+
+/*
+    gcdENABLE_TIMEOUT_DETECTION
+
+        Enable timeout detection.
+*/
+#ifndef gcdENABLE_TIMEOUT_DETECTION
+#   define gcdENABLE_TIMEOUT_DETECTION          0
+#endif
+
+/*
+    gcdCMD_BUFFER_SIZE
+
+        Number of bytes in a command buffer.
+*/
+#ifndef gcdCMD_BUFFER_SIZE
+#   define gcdCMD_BUFFER_SIZE                   (128 << 10)
+#endif
+
+/*
+    gcdCMD_BUFFERS
+
+        Number of command buffers to use per client.
+*/
+#ifndef gcdCMD_BUFFERS
+#   define gcdCMD_BUFFERS                       2
+#endif
+
+/*
+    gcdMAX_CMD_BUFFERS
+
+        Maximum number of command buffers to use per client.
+*/
+#ifndef gcdMAX_CMD_BUFFERS
+#   define gcdMAX_CMD_BUFFERS                   8
+#endif
+
+/*
+    gcdCOMMAND_QUEUES
+
+        Number of command queues in the kernel.
+*/
+#ifndef gcdCOMMAND_QUEUES
+#   define gcdCOMMAND_QUEUES                    2
+#endif
+
+/*
+    gcdPOWER_CONTROL_DELAY
+
+        The delay in milliseconds required to wait until the GPU has woke up
+        from a suspend or power-down state.  This is system dependent because
+        the bus clock also needs to stabalize.
+*/
+#ifndef gcdPOWER_CONTROL_DELAY
+#   define gcdPOWER_CONTROL_DELAY               0
+#endif
+
+/*
+    gcdMMU_SIZE
+
+        Size of the MMU page table in bytes.  Each 4 bytes can hold 4kB worth of
+        virtual data.
+*/
+#ifndef gcdMMU_SIZE
+#   define gcdMMU_SIZE                          (128 << 10)
+#endif
+
+/*
+    gcdSECURE_USER
+
+        Use logical addresses instead of physical addresses in user land.  In
+        this case a hint table is created for both command buffers and context
+        buffers, and that hint table will be used to patch up those buffers in
+        the kernel when they are ready to submit.
+*/
+#ifndef gcdSECURE_USER
+#   define gcdSECURE_USER                       0
+#endif
+
+/*
+    gcdSECURE_CACHE_SLOTS
+
+        Number of slots in the logical to DMA address cache table.  Each time a
+        logical address needs to be translated into a DMA address for the GPU,
+        this cache will be walked.  The replacement scheme is LRU.
+*/
+#ifndef gcdSECURE_CACHE_SLOTS
+#   define gcdSECURE_CACHE_SLOTS                1024
+#endif
+
+/*
+    gcdSECURE_CACHE_METHOD
+
+        Replacement scheme used for Secure Cache.  The following options are
+        available:
+
+            gcdSECURE_CACHE_LRU
+                A standard LRU cache.
+
+            gcdSECURE_CACHE_LINEAR
+                A linear walker with the idea that an application will always
+                render the scene in a similar way, so the next entry in the
+                cache should be a hit most of the time.
+
+            gcdSECURE_CACHE_HASH
+                A 256-entry hash table.
+
+            gcdSECURE_CACHE_TABLE
+                A simple cache but with potential of a lot of cache replacement.
+*/
+#ifndef gcdSECURE_CACHE_METHOD
+#   define gcdSECURE_CACHE_METHOD               gcdSECURE_CACHE_HASH
+#endif
+
+/*
+    gcdREGISTER_ACCESS_FROM_USER
+
+        Set to 1 to allow IOCTL calls to get through from user land.  This
+        should only be in debug or development drops.
+*/
+#ifndef gcdREGISTER_ACCESS_FROM_USER
+#   define gcdREGISTER_ACCESS_FROM_USER         1
+#endif
+
+/*
+    gcdHEAP_SIZE
+
+        Set the allocation size for the internal heaps.  Each time a heap is
+        full, a new heap will be allocated with this minmimum amount of bytes.
+        The bigger this size, the fewer heaps there are to allocate, the better
+        the performance.  However, heaps won't be freed until they are
+        completely free, so there might be some more memory waste if the size is
+        too big.
+*/
+#ifndef gcdHEAP_SIZE
+#   define gcdHEAP_SIZE                         (64 << 10)
+#endif
+
+/*
+    gcdPOWER_MANAGEMENT
+
+        This define enables the power management code.
+*/
+#ifndef gcdPOWER_MANAGEMENT
+#   define gcdPOWER_MANAGEMENT                  1
+#endif
+
+/*
+    gcdFPGA_BUILD
+
+        This define enables work arounds for FPGA images.
+*/
+#ifndef gcdFPGA_BUILD
+#   define gcdFPGA_BUILD                        0
+#endif
+
+/*
+    gcdGPU_TIMEOUT
+
+        This define specified the number of milliseconds the system will wait
+        before it broadcasts the GPU is stuck.  In other words, it will define
+        the timeout of any operation that needs to wait for the GPU.
+
+        If the value is 0, no timeout will be checked for.
+*/
+#ifndef gcdGPU_TIMEOUT
+#   if gcdFPGA_BUILD
+#       define gcdGPU_TIMEOUT                   0
+#   else
+#       define gcdGPU_TIMEOUT                   (2000 * 5)
+#   endif
+#endif
+
+/*
+    gcdGPU_ADVANCETIMER
+
+        it is advance timer.
+*/
+#ifndef gcdGPU_ADVANCETIMER
+#   define gcdGPU_ADVANCETIMER                  250
+#endif
+
+/*
+    gcdSTATIC_LINK
+
+        This define disalbes static linking;
+*/
+#ifndef gcdSTATIC_LINK
+#   define gcdSTATIC_LINK                       0
+#endif
+
+/*
+    gcdUSE_NEW_HEAP
+
+        Setting this define to 1 enables new heap.
+*/
+#ifndef gcdUSE_NEW_HEAP
+#   define gcdUSE_NEW_HEAP                      0
+#endif
+
+/*
+    gcdCMD_NO_2D_CONTEXT
+
+        This define enables no-context 2D command buffer.
+*/
+#ifndef gcdCMD_NO_2D_CONTEXT
+#   define gcdCMD_NO_2D_CONTEXT                 1
+#endif
+
+/*
+    gcdENABLE_BANK_ALIGNMENT
+
+    When enabled, video memory is allocated bank aligned. The vendor can modify
+    _GetSurfaceBankAlignment() and gcoSURF_GetBankOffsetBytes() to define how
+    different types of allocations are bank and channel aligned.
+    When disabled (default), no bank alignment is done.
+*/
+#ifndef gcdENABLE_BANK_ALIGNMENT
+#   define gcdENABLE_BANK_ALIGNMENT             0
+#endif
+
+/*
+    gcdBANK_BIT_START
+
+    Specifies the start bit of the bank (inclusive).
+*/
+#ifndef gcdBANK_BIT_START
+#   define gcdBANK_BIT_START                    12
+#endif
+
+/*
+    gcdBANK_BIT_END
+
+    Specifies the end bit of the bank (inclusive).
+*/
+#ifndef gcdBANK_BIT_END
+#   define gcdBANK_BIT_END                      14
+#endif
+
+/*
+    gcdBANK_CHANNEL_BIT
+
+    When set, video memory when allocated bank aligned is allocated such that
+    render and depth buffer addresses alternate on the channel bit specified.
+    This option has an effect only when gcdENABLE_BANK_ALIGNMENT is enabled.
+    When disabled (default), no alteration is done.
+*/
+#ifndef gcdBANK_CHANNEL_BIT
+#   define gcdBANK_CHANNEL_BIT                  7
+#endif
+
+/*
+    gcdDYNAMIC_SPEED
+
+        When non-zero, it informs the kernel driver to use the speed throttling
+        broadcasting functions to inform the system the GPU should be spet up or
+        slowed down. It will send a broadcast for slowdown each "interval"
+        specified by this define in milliseconds
+        (gckOS_BroadcastCalibrateSpeed).
+*/
+#ifndef gcdDYNAMIC_SPEED
+#    define gcdDYNAMIC_SPEED                    2000
+#endif
+
+/*
+    gcdDYNAMIC_EVENT_THRESHOLD
+
+        When non-zero, it specifies the maximum number of available events at
+        which the kernel driver will issue a broadcast to speed up the GPU
+        (gckOS_BroadcastHurry).
+*/
+#ifndef gcdDYNAMIC_EVENT_THRESHOLD
+#    define gcdDYNAMIC_EVENT_THRESHOLD          5
+#endif
+
+/*
+    gcdENABLE_PROFILING
+
+        Enable profiling macros.
+*/
+#ifndef gcdENABLE_PROFILING
+#   define gcdENABLE_PROFILING                  0
+#endif
+
+/*
+    gcdENABLE_128B_MERGE
+
+        Enable 128B merge for the BUS control.
+*/
+#ifndef gcdENABLE_128B_MERGE
+#   define gcdENABLE_128B_MERGE                 0
+#endif
+
+/*
+    gcdFRAME_DB
+
+        When non-zero, it specified the number of frames inside the frame
+        database. The frame DB will collect per-frame timestamps and hardware
+        counters.
+*/
+#ifndef gcdFRAME_DB
+#   define gcdFRAME_DB                          0
+#   define gcdFRAME_DB_RESET                    0
+#   define gcdFRAME_DB_NAME                     "/var/log/frameDB.log"
+#endif
+
+/*
+    gcdENABLE_VG
+            enable the 2D openVG
+*/
+
+#ifndef gcdENABLE_VG
+#   define gcdENABLE_VG                         0
+#endif
+
+/*
+    gcdDYNAMIC_MAP_RESERVED_MEMORY
+
+        When gcvPOOL_SYSTEM is constructed from RESERVED memory,
+        driver can map the whole reserved memory to kernel space
+        at the beginning, or just map a piece of memory when need
+        to access.
+
+        Notice:
+        -  It's only for the 2D openVG. For other cores, there is
+           _NO_ need to map reserved memory to kernel.
+        -  It's meaningless when memory is allocated by
+           gckOS_AllocateContiguous, in that case, memory is always
+           mapped by system when allocated.
+*/
+#ifndef gcdDYNAMIC_MAP_RESERVED_MEMORY
+#   define gcdDYNAMIC_MAP_RESERVED_MEMORY      1
+#endif
+
+/*
+   gcdPAGED_MEMORY_CACHEABLE
+
+        When non-zero, paged memory will be cacheable.
+
+        Normally, driver will detemines whether a video memory
+        is cacheable or not. When cacheable is not neccessary,
+        it will be writecombine.
+
+        This option is only for those SOC which can't enable
+        writecombine without enabling cacheable.
+*/
+
+#ifndef gcdPAGED_MEMORY_CACHEABLE
+#   define gcdPAGED_MEMORY_CACHEABLE            0
+#endif
+
+/*
+   gcdNONPAGED_MEMORY_CACHEABLE
+
+        When non-zero, non paged memory will be cacheable.
+*/
+
+#ifndef gcdNONPAGED_MEMORY_CACHEABLE
+#   define gcdNONPAGED_MEMORY_CACHEABLE         0
+#endif
+
+/*
+   gcdNONPAGED_MEMORY_BUFFERABLE
+
+        When non-zero, non paged memory will be bufferable.
+        gcdNONPAGED_MEMORY_BUFFERABLE and gcdNONPAGED_MEMORY_CACHEABLE
+        can't be set 1 at same time
+*/
+
+#ifndef gcdNONPAGED_MEMORY_BUFFERABLE
+#   define gcdNONPAGED_MEMORY_BUFFERABLE        1
+#endif
+
+/*
+    gcdENABLE_INFINITE_SPEED_HW
+            enable the Infinte HW , this is for 2D openVG
+*/
+
+#ifndef gcdENABLE_INFINITE_SPEED_HW
+#   define gcdENABLE_INFINITE_SPEED_HW          0
+#endif
+
+/*
+    gcdENABLE_TS_DOUBLE_BUFFER
+            enable the TS double buffer, this is for 2D openVG
+*/
+
+#ifndef gcdENABLE_TS_DOUBLE_BUFFER
+#   define gcdENABLE_TS_DOUBLE_BUFFER           1
+#endif
+
+/*
+    gcd6000_SUPPORT
+
+    Temporary define to enable/disable 6000 support.
+ */
+#ifndef gcd6000_SUPPORT
+#   define gcd6000_SUPPORT                      0
+#endif
+
+/*
+    gcdPOWEROFF_TIMEOUT
+
+        When non-zero, GPU will power off automatically from
+        idle state, and gcdPOWEROFF_TIMEOUT is also the default
+        timeout in milliseconds.
+ */
+
+#ifndef gcdPOWEROFF_TIMEOUT
+#   define gcdPOWEROFF_TIMEOUT                  300
+#endif
+
+/*
+    gcdUSE_VIDMEM_PER_PID
+*/
+#ifndef gcdUSE_VIDMEM_PER_PID
+#   define gcdUSE_VIDMEM_PER_PID                0
+#endif
+
+/*
+    QNX_SINGLE_THREADED_DEBUGGING
+*/
+#ifndef QNX_SINGLE_THREADED_DEBUGGING
+#   define QNX_SINGLE_THREADED_DEBUGGING        0
+#endif
+
+/*
+    gcdENABLE_RECOVERY
+
+        This define enables the recovery code.
+*/
+#ifndef gcdENABLE_RECOVERY
+#   define gcdENABLE_RECOVERY                   1
+#endif
+
+/*
+    gcdRENDER_THREADS
+
+        Number of render threads. Make it zero, and there will be no render
+        threads.
+*/
+#ifndef gcdRENDER_THREADS
+#   define gcdRENDER_THREADS                    0
+#endif
+
+/*
+    gcdSMP
+
+        This define enables SMP support.
+
+        Currently, it only works on Linux/Android,
+        Kbuild will config it according to whether
+        CONFIG_SMP is set.
+
+*/
+#ifndef gcdSMP
+#   define gcdSMP                               0
+#endif
+
+/*
+    gcdSUPPORT_SWAP_RECTANGLE
+
+        Support swap with a specific rectangle.
+
+        Set the rectangle with eglSetSwapRectangleANDROID api.
+*/
+#ifndef gcdSUPPORT_SWAP_RECTANGLE
+#   define gcdSUPPORT_SWAP_RECTANGLE            0
+#endif
+
+/*
+    gcdDEFER_RESOLVES
+
+        Support deferred resolves for 3D apps.
+*/
+#ifndef gcdDEFER_RESOLVES
+#   define gcdDEFER_RESOLVES                    0
+#endif
+
+/*
+    gcdCOPYBLT_OPTIMIZATION
+
+        Combine dirty areas resulting from Android's copyBlt.
+*/
+#ifndef gcdCOPYBLT_OPTIMIZATION
+#   define gcdCOPYBLT_OPTIMIZATION              0
+#endif
+
+/*
+    gcdGPU_LINEAR_BUFFER_ENABLED
+
+        Use linear buffer for GPU apps so HWC can do 2D composition.
+*/
+#ifndef gcdGPU_LINEAR_BUFFER_ENABLED
+#   define gcdGPU_LINEAR_BUFFER_ENABLED         0
+#endif
+
+/*
+    gcdSHARED_RESOLVE_BUFFER_ENABLED
+
+        Use shared resolve buffer for all app buffers.
+*/
+#ifndef gcdSHARED_RESOLVE_BUFFER_ENABLED
+#   define gcdSHARED_RESOLVE_BUFFER_ENABLED         0
+#endif
+
+/*
+     gcdUSE_TRIANGLE_STRIP_PATCH
+ */
+#ifndef gcdUSE_TRIANGLE_STRIP_PATCH
+#   define gcdUSE_TRIANGLE_STRIP_PATCH            1
+#endif
+
+/*
+    gcdENABLE_OUTER_CACHE_PATCH
+
+        Enable the outer cache patch.
+*/
+#ifndef gcdENABLE_OUTER_CACHE_PATCH
+#   define gcdENABLE_OUTER_CACHE_PATCH          0
+#endif
+
+#ifndef gcdANDROID_UNALIGNED_LINEAR_COMPOSITION_ADJUST
+#   define  gcdANDROID_UNALIGNED_LINEAR_COMPOSITION_ADJUST    0
+#endif
+
+#ifndef gcdSHARED_PAGETABLE
+#   define gcdSHARED_PAGETABLE                  1
+#endif
+
+#ifndef gcdUSE_OPENCL
+#   define gcdUSE_OPENCL                        0
+#endif
+
+/*
+    gcdBLOB_CACHE_ENABLED
+        When non-zero, Android blob cache extension will be enabled.
+        Otherwise, caching will be by-passed.
+ */
+
+#ifndef gcdBLOB_CACHE_ENABLED
+#   define gcdBLOB_CACHE_ENABLED                0
+#endif
+
+/*
+    gcdSMALL_BLOCK_SIZE
+
+        When non-zero, a part of VIDMEM will be reserved for requests
+        whose requesting size is less than gcdSMALL_BLOCK_SIZE.
+
+        For Linux, it's the size of a page. If this requeset fallbacks
+        to gcvPOOL_CONTIGUOUS or gcvPOOL_VIRTUAL, memory will be wasted
+        because they allocate a page at least.
+ */
+#ifndef gcdSMALL_BLOCK_SIZE
+#   define gcdSMALL_BLOCK_SIZE                  4096
+#   define gcdRATIO_FOR_SMALL_MEMORY            32
+#endif
+
+#endif /* __gc_hal_options_h_ */
diff --git a/attic/gc_hal_profiler.h b/attic/gc_hal_profiler.h
new file mode 100644
index 0000000..ee4a2ce
--- /dev/null
+++ b/attic/gc_hal_profiler.h
@@ -0,0 +1,1311 @@
+/****************************************************************************
+*
+*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*
+*    This program is free software; you can redistribute it and/or modify
+*    it under the terms of the GNU General Public License as published by
+*    the Free Software Foundation; either version 2 of the license, or
+*    (at your option) any later version.
+*
+*    This program is distributed in the hope that it will be useful,
+*    but WITHOUT ANY WARRANTY; without even the implied warranty of
+*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+*    GNU General Public License for more details.
+*
+*    You should have received a copy of the GNU General Public License
+*    along with this program; if not write to the Free Software
+*    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*
+*****************************************************************************/
+
+
+#ifndef __gc_hal_profiler_h_
+#define __gc_hal_profiler_h_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define GLVERTEX_OBJECT 10
+#define GLVERTEX_OBJECT_BYTES 11
+
+#define GLINDEX_OBJECT 20
+#define GLINDEX_OBJECT_BYTES 21
+
+#define GLTEXTURE_OBJECT 30
+#define GLTEXTURE_OBJECT_BYTES 31
+
+#if VIVANTE_PROFILER
+#define gcmPROFILE_GC(Enum, Value)  gcoPROFILER_Count(gcvNULL, Enum, Value)
+#else
+#define gcmPROFILE_GC(Enum, Value)  do { } while (gcvFALSE)
+#endif
+
+#ifndef gcdNEW_PROFILER_FILE
+#define gcdNEW_PROFILER_FILE    1
+#endif
+
+/* OpenGL ES11 API IDs. */
+#define	ES11_ACTIVETEXTURE				1
+#define	ES11_ALPHAFUNC					(ES11_ACTIVETEXTURE				+ 1)
+#define	ES11_ALPHAFUNCX					(ES11_ALPHAFUNC					+ 1)
+#define	ES11_BINDBUFFER					(ES11_ALPHAFUNCX 				+ 1)
+#define	ES11_BINDTEXTURE				(ES11_BINDBUFFER 				+ 1)
+#define	ES11_BLENDFUNC					(ES11_BINDTEXTURE				+ 1)
+#define	ES11_BUFFERDATA					(ES11_BLENDFUNC					+ 1)
+#define	ES11_BUFFERSUBDATA				(ES11_BUFFERDATA				+ 1)
+#define	ES11_CLEAR						(ES11_BUFFERSUBDATA				+ 1)
+#define	ES11_CLEARCOLOR					(ES11_CLEAR						+ 1)
+#define	ES11_CLEARCOLORX				(ES11_CLEARCOLOR				+ 1)
+#define	ES11_CLEARDEPTHF				(ES11_CLEARCOLORX 				+ 1)
+#define	ES11_CLEARDEPTHX				(ES11_CLEARDEPTHF 				+ 1)
+#define	ES11_CLEARSTENCIL				(ES11_CLEARDEPTHX 				+ 1)
+#define	ES11_CLIENTACTIVETEXTURE    	(ES11_CLEARSTENCIL				+ 1)
+#define	ES11_CLIPPLANEF      			(ES11_CLIENTACTIVETEXTURE		+ 1)
+#define	ES11_CLIPPLANEX      			(ES11_CLIPPLANEF       			+ 1)
+#define	ES11_COLOR4F 					(ES11_CLIPPLANEX       			+ 1)
+#define	ES11_COLOR4UB        			(ES11_COLOR4F					+ 1)
+#define	ES11_COLOR4X 					(ES11_COLOR4UB					+ 1)
+#define	ES11_COLORMASK       			(ES11_COLOR4X					+ 1)
+#define	ES11_COLORPOINTER    			(ES11_COLORMASK        			+ 1)
+#define	ES11_COMPRESSEDTEXIMAGE2D   	(ES11_COLORPOINTER     			+ 1)
+#define	ES11_COMPRESSEDTEXSUBIMAGE2D	(ES11_COMPRESSEDTEXIMAGE2D    	+ 1)
+#define	ES11_COPYTEXIMAGE2D  			(ES11_COMPRESSEDTEXSUBIMAGE2D 	+ 1)
+#define	ES11_COPYTEXSUBIMAGE2D      	(ES11_COPYTEXIMAGE2D   			+ 1)
+#define	ES11_CULLFACE        			(ES11_COPYTEXSUBIMAGE2D			+ 1)
+#define	ES11_DELETEBUFFERS   			(ES11_CULLFACE         			+ 1)
+#define	ES11_DELETETEXTURES  			(ES11_DELETEBUFFERS    			+ 1)
+#define	ES11_DEPTHFUNC       			(ES11_DELETETEXTURES   			+ 1)
+#define	ES11_DEPTHMASK       			(ES11_DEPTHFUNC        			+ 1)
+#define	ES11_DEPTHRANGEF     			(ES11_DEPTHMASK        			+ 1)
+#define	ES11_DEPTHRANGEX     			(ES11_DEPTHRANGEF      			+ 1)
+#define	ES11_DISABLE 					(ES11_DEPTHRANGEX      			+ 1)
+#define	ES11_DISABLECLIENTSTATE     	(ES11_DISABLE					+ 1)
+#define	ES11_DRAWARRAYS      			(ES11_DISABLECLIENTSTATE		+ 1)
+#define	ES11_DRAWELEMENTS    			(ES11_DRAWARRAYS       			+ 1)
+#define	ES11_ENABLE  					(ES11_DRAWELEMENTS     			+ 1)
+#define	ES11_ENABLECLIENTSTATE      	(ES11_ENABLE					+ 1)
+#define	ES11_FINISH  					(ES11_ENABLECLIENTSTATE			+ 1)
+#define	ES11_FLUSH   					(ES11_FINISH   					+ 1)
+#define	ES11_FOGF    					(ES11_FLUSH    					+ 1)
+#define	ES11_FOGFV   					(ES11_FOGF     					+ 1)
+#define	ES11_FOGX    					(ES11_FOGFV    					+ 1)
+#define	ES11_FOGXV   					(ES11_FOGX     					+ 1)
+#define	ES11_FRONTFACE       			(ES11_FOGXV    					+ 1)
+#define	ES11_FRUSTUMF        			(ES11_FRONTFACE        			+ 1)
+#define	ES11_FRUSTUMX        			(ES11_FRUSTUMF         			+ 1)
+#define	ES11_GENBUFFERS      			(ES11_FRUSTUMX         			+ 1)
+#define	ES11_GENTEXTURES     			(ES11_GENBUFFERS       			+ 1)
+#define	ES11_GETBOOLEANV     			(ES11_GENTEXTURES      			+ 1)
+#define	ES11_GETBUFFERPARAMETERIV   	(ES11_GETBOOLEANV      			+ 1)
+#define	ES11_GETCLIPPLANEF   			(ES11_GETBUFFERPARAMETERIV		+ 1)
+#define	ES11_GETCLIPPLANEX   			(ES11_GETCLIPPLANEF    			+ 1)
+#define	ES11_GETERROR        			(ES11_GETCLIPPLANEX    			+ 1)
+#define	ES11_GETFIXEDV       			(ES11_GETERROR         			+ 1)
+#define	ES11_GETFLOATV       			(ES11_GETFIXEDV        			+ 1)
+#define	ES11_GETINTEGERV     			(ES11_GETFLOATV        			+ 1)
+#define	ES11_GETLIGHTFV      			(ES11_GETINTEGERV      			+ 1)
+#define	ES11_GETLIGHTXV      			(ES11_GETLIGHTFV       			+ 1)
+#define	ES11_GETMATERIALFV   			(ES11_GETLIGHTXV       			+ 1)
+#define	ES11_GETMATERIALXV   			(ES11_GETMATERIALFV    			+ 1)
+#define	ES11_GETPOINTERV     			(ES11_GETMATERIALXV    			+ 1)
+#define	ES11_GETSTRING       			(ES11_GETPOINTERV      			+ 1)
+#define	ES11_GETTEXENVFV     			(ES11_GETSTRING        			+ 1)
+#define	ES11_GETTEXENVIV     			(ES11_GETTEXENVFV      			+ 1)
+#define	ES11_GETTEXENVXV     			(ES11_GETTEXENVIV      			+ 1)
+#define	ES11_GETTEXPARAMETERFV      	(ES11_GETTEXENVXV      			+ 1)
+#define	ES11_GETTEXPARAMETERIV      	(ES11_GETTEXPARAMETERFV       	+ 1)
+#define	ES11_GETTEXPARAMETERXV      	(ES11_GETTEXPARAMETERIV       	+ 1)
+#define	ES11_HINT    					(ES11_GETTEXPARAMETERXV       	+ 1)
+#define	ES11_ISBUFFER        			(ES11_HINT     					+ 1)
+#define	ES11_ISENABLED       			(ES11_ISBUFFER 			        + 1)
+#define	ES11_ISTEXTURE       			(ES11_ISENABLED			        + 1)
+#define	ES11_LIGHTF  					(ES11_ISTEXTURE			        + 1)
+#define	ES11_LIGHTFV 					(ES11_LIGHTF   					+ 1)
+#define	ES11_LIGHTMODELF     			(ES11_LIGHTFV  					+ 1)
+#define	ES11_LIGHTMODELFV    			(ES11_LIGHTMODELF      			+ 1)
+#define	ES11_LIGHTMODELX     			(ES11_LIGHTMODELFV     			+ 1)
+#define	ES11_LIGHTMODELXV    			(ES11_LIGHTMODELX      			+ 1)
+#define	ES11_LIGHTX  					(ES11_LIGHTMODELXV     			+ 1)
+#define	ES11_LIGHTXV 					(ES11_LIGHTX   					+ 1)
+#define	ES11_LINEWIDTH       			(ES11_LIGHTXV  					+ 1)
+#define	ES11_LINEWIDTHX      			(ES11_LINEWIDTH        			+ 1)
+#define	ES11_LOADIDENTITY    			(ES11_LINEWIDTHX       			+ 1)
+#define	ES11_LOADMATRIXF     			(ES11_LOADIDENTITY     			+ 1)
+#define	ES11_LOADMATRIXX     			(ES11_LOADMATRIXF      			+ 1)
+#define	ES11_LOGICOP 					(ES11_LOADMATRIXX      			+ 1)
+#define	ES11_MATERIALF       			(ES11_LOGICOP					+ 1)
+#define	ES11_MATERIALFV      			(ES11_MATERIALF        			+ 1)
+#define	ES11_MATERIALX       			(ES11_MATERIALFV       			+ 1)
+#define	ES11_MATERIALXV      			(ES11_MATERIALX        			+ 1)
+#define	ES11_MATRIXMODE      			(ES11_MATERIALXV       			+ 1)
+#define	ES11_MULTITEXCOORD4F 			(ES11_MATRIXMODE       			+ 1)
+#define	ES11_MULTITEXCOORD4X 			(ES11_MULTITEXCOORD4F  			+ 1)
+#define	ES11_MULTMATRIXF     			(ES11_MULTITEXCOORD4X  			+ 1)
+#define	ES11_MULTMATRIXX     			(ES11_MULTMATRIXF      			+ 1)
+#define	ES11_NORMAL3F        			(ES11_MULTMATRIXX      			+ 1)
+#define	ES11_NORMAL3X        			(ES11_NORMAL3F         			+ 1)
+#define	ES11_NORMALPOINTER   			(ES11_NORMAL3X         			+ 1)
+#define	ES11_ORTHOF  					(ES11_NORMALPOINTER    			+ 1)
+#define	ES11_ORTHOX  					(ES11_ORTHOF   					+ 1)
+#define	ES11_PIXELSTOREI     			(ES11_ORTHOX   					+ 1)
+#define	ES11_POINTPARAMETERF 			(ES11_PIXELSTOREI      			+ 1)
+#define	ES11_POINTPARAMETERFV    		(ES11_POINTPARAMETERF  			+ 1)
+#define	ES11_POINTPARAMETERX 			(ES11_POINTPARAMETERFV 			+ 1)
+#define	ES11_POINTPARAMETERXV    		(ES11_POINTPARAMETERX  			+ 1)
+#define	ES11_POINTSIZE       			(ES11_POINTPARAMETERXV 			+ 1)
+#define	ES11_POINTSIZEX      			(ES11_POINTSIZE        			+ 1)
+#define	ES11_POLYGONOFFSET   			(ES11_POINTSIZEX       			+ 1)
+#define	ES11_POLYGONOFFSETX  			(ES11_POLYGONOFFSET    			+ 1)
+#define	ES11_POPMATRIX       			(ES11_POLYGONOFFSETX   			+ 1)
+#define	ES11_PUSHMATRIX      			(ES11_POPMATRIX        			+ 1)
+#define	ES11_READPIXELS      			(ES11_PUSHMATRIX       			+ 1)
+#define	ES11_ROTATEF 					(ES11_READPIXELS       			+ 1)
+#define	ES11_ROTATEX 					(ES11_ROTATEF  					+ 1)
+#define	ES11_SAMPLECOVERAGE  			(ES11_ROTATEX  					+ 1)
+#define	ES11_SAMPLECOVERAGEX 			(ES11_SAMPLECOVERAGE   			+ 1)
+#define	ES11_SCALEF  					(ES11_SAMPLECOVERAGEX  			+ 1)
+#define	ES11_SCALEX  					(ES11_SCALEF   					+ 1)
+#define	ES11_SCISSOR 					(ES11_SCALEX   					+ 1)
+#define	ES11_SHADEMODEL      			(ES11_SCISSOR  					+ 1)
+#define	ES11_STENCILFUNC     			(ES11_SHADEMODEL       			+ 1)
+#define	ES11_STENCILMASK     			(ES11_STENCILFUNC      			+ 1)
+#define	ES11_STENCILOP       			(ES11_STENCILMASK      			+ 1)
+#define	ES11_TEXCOORDPOINTER 			(ES11_STENCILOP        			+ 1)
+#define	ES11_TEXENVF 					(ES11_TEXCOORDPOINTER  			+ 1)
+#define	ES11_TEXENVFV     				(ES11_TEXENVF					+ 1)
+#define	ES11_TEXENVI 					(ES11_TEXENVFV					+ 1)
+#define	ES11_TEXENVIV     				(ES11_TEXENVI  					+ 1)
+#define	ES11_TEXENVX 					(ES11_TEXENVIV 					+ 1)
+#define	ES11_TEXENVXV        			(ES11_TEXENVX  					+ 1)
+#define	ES11_TEXIMAGE2D      			(ES11_TEXENVXV         			+ 1)
+#define	ES11_TEXPARAMETERF   			(ES11_TEXIMAGE2D       			+ 1)
+#define	ES11_TEXPARAMETERFV  			(ES11_TEXPARAMETERF    			+ 1)
+#define	ES11_TEXPARAMETERI   			(ES11_TEXPARAMETERFV   			+ 1)
+#define	ES11_TEXPARAMETERIV  			(ES11_TEXPARAMETERI    			+ 1)
+#define	ES11_TEXPARAMETERX   			(ES11_TEXPARAMETERIV   			+ 1)
+#define	ES11_TEXPARAMETERXV  			(ES11_TEXPARAMETERX    			+ 1)
+#define	ES11_TEXSUBIMAGE2D   			(ES11_TEXPARAMETERXV   			+ 1)
+#define	ES11_TRANSLATEF      			(ES11_TEXSUBIMAGE2D    			+ 1)
+#define	ES11_TRANSLATEX      			(ES11_TRANSLATEF       			+ 1)
+#define	ES11_VERTEXPOINTER   			(ES11_TRANSLATEX       			+ 1)
+#define	ES11_VIEWPORT        			(ES11_VERTEXPOINTER    			+ 1)
+#define ES11_BLENDEQUATIONOES           (ES11_VIEWPORT         			+ 1)
+#define ES11_BLENDFUNCSEPERATEOES       (ES11_BLENDEQUATIONOES       	+ 1)
+#define ES11_BLENDEQUATIONSEPARATEOES   (ES11_BLENDFUNCSEPERATEOES    	+ 1)
+#define ES11_GLMAPBUFFEROES             (ES11_BLENDEQUATIONSEPARATEOES 	+ 1)
+#define ES11_GLUNMAPBUFFEROES           (ES11_GLMAPBUFFEROES     		+ 1)
+#define ES11_GLGETBUFFERPOINTERVOES     (ES11_GLUNMAPBUFFEROES         	+ 1)
+#define	ES11_CALLS   					(ES11_GLGETBUFFERPOINTERVOES   	+ 1)
+#define	ES11_DRAWCALLS       			(ES11_CALLS						+ 1)
+#define	ES11_STATECHANGECALLS    		(ES11_DRAWCALLS					+ 1)
+#define	ES11_POINTCOUNT      			(ES11_STATECHANGECALLS			+ 1)
+#define	ES11_LINECOUNT       			(ES11_POINTCOUNT       			+ 1)
+#define	ES11_TRIANGLECOUNT   			(ES11_LINECOUNT        			+ 1)
+
+/* OpenGL ES2X API IDs. */
+#define	ES20_ACTIVETEXTURE				1
+#define	ES20_ATTACHSHADER							(ES20_ACTIVETEXTURE							+	1)
+#define	ES20_BINDATTRIBLOCATION						(ES20_ATTACHSHADER							+	1)
+#define	ES20_BINDBUFFER								(ES20_BINDATTRIBLOCATION					+	1)
+#define	ES20_BINDFRAMEBUFFER						(ES20_BINDBUFFER							+	1)
+#define	ES20_BINDRENDERBUFFER						(ES20_BINDFRAMEBUFFER						+	1)
+#define	ES20_BINDTEXTURE							(ES20_BINDRENDERBUFFER						+	1)
+#define	ES20_BLENDCOLOR								(ES20_BINDTEXTURE							+	1)
+#define	ES20_BLENDEQUATION							(ES20_BLENDCOLOR							+	1)
+#define	ES20_BLENDEQUATIONSEPARATE					(ES20_BLENDEQUATION							+	1)
+#define	ES20_BLENDFUNC								(ES20_BLENDEQUATIONSEPARATE					+	1)
+#define	ES20_BLENDFUNCSEPARATE						(ES20_BLENDFUNC								+	1)
+#define	ES20_BUFFERDATA								(ES20_BLENDFUNCSEPARATE						+	1)
+#define	ES20_BUFFERSUBDATA							(ES20_BUFFERDATA							+	1)
+#define	ES20_CHECKFRAMEBUFFERSTATUS					(ES20_BUFFERSUBDATA							+	1)
+#define	ES20_CLEAR									(ES20_CHECKFRAMEBUFFERSTATUS				+	1)
+#define	ES20_CLEARCOLOR								(ES20_CLEAR									+	1)
+#define	ES20_CLEARDEPTHF							(ES20_CLEARCOLOR							+	1)
+#define	ES20_CLEARSTENCIL							(ES20_CLEARDEPTHF							+	1)
+#define	ES20_COLORMASK								(ES20_CLEARSTENCIL							+	1)
+#define	ES20_COMPILESHADER							(ES20_COLORMASK								+	1)
+#define	ES20_COMPRESSEDTEXIMAGE2D					(ES20_COMPILESHADER							+	1)
+#define	ES20_COMPRESSEDTEXSUBIMAGE2D				(ES20_COMPRESSEDTEXIMAGE2D					+	1)
+#define	ES20_COPYTEXIMAGE2D							(ES20_COMPRESSEDTEXSUBIMAGE2D				+	1)
+#define	ES20_COPYTEXSUBIMAGE2D						(ES20_COPYTEXIMAGE2D						+	1)
+#define	ES20_CREATEPROGRAM							(ES20_COPYTEXSUBIMAGE2D						+	1)
+#define	ES20_CREATESHADER							(ES20_CREATEPROGRAM							+	1)
+#define	ES20_CULLFACE								(ES20_CREATESHADER							+	1)
+#define	ES20_DELETEBUFFERS							(ES20_CULLFACE								+	1)
+#define	ES20_DELETEFRAMEBUFFERS						(ES20_DELETEBUFFERS							+	1)
+#define	ES20_DELETEPROGRAM							(ES20_DELETEFRAMEBUFFERS					+	1)
+#define	ES20_DELETERENDERBUFFERS					(ES20_DELETEPROGRAM							+	1)
+#define	ES20_DELETESHADER							(ES20_DELETERENDERBUFFERS					+	1)
+#define	ES20_DELETETEXTURES							(ES20_DELETESHADER							+	1)
+#define	ES20_DEPTHFUNC								(ES20_DELETETEXTURES						+	1)
+#define	ES20_DEPTHMASK								(ES20_DEPTHFUNC								+	1)
+#define	ES20_DEPTHRANGEF							(ES20_DEPTHMASK								+	1)
+#define	ES20_DETACHSHADER							(ES20_DEPTHRANGEF							+	1)
+#define	ES20_DISABLE								(ES20_DETACHSHADER							+	1)
+#define	ES20_DISABLEVERTEXATTRIBARRAY				(ES20_DISABLE								+	1)
+#define	ES20_DRAWARRAYS								(ES20_DISABLEVERTEXATTRIBARRAY				+	1)
+#define	ES20_DRAWELEMENTS							(ES20_DRAWARRAYS							+	1)
+#define	ES20_ENABLE									(ES20_DRAWELEMENTS							+	1)
+#define	ES20_ENABLEVERTEXATTRIBARRAY				(ES20_ENABLE								+	1)
+#define	ES20_FINISH									(ES20_ENABLEVERTEXATTRIBARRAY				+	1)
+#define	ES20_FLUSH									(ES20_FINISH								+	1)
+#define	ES20_FRAMEBUFFERRENDERBUFFER				(ES20_FLUSH									+	1)
+#define	ES20_FRAMEBUFFERTEXTURE2D					(ES20_FRAMEBUFFERRENDERBUFFER				+	1)
+#define	ES20_FRONTFACE								(ES20_FRAMEBUFFERTEXTURE2D					+	1)
+#define	ES20_GENBUFFERS								(ES20_FRONTFACE								+	1)
+#define	ES20_GENERATEMIPMAP							(ES20_GENBUFFERS							+	1)
+#define	ES20_GENFRAMEBUFFERS						(ES20_GENERATEMIPMAP						+	1)
+#define	ES20_GENRENDERBUFFERS						(ES20_GENFRAMEBUFFERS						+	1)
+#define	ES20_GENTEXTURES							(ES20_GENRENDERBUFFERS						+	1)
+#define	ES20_GETACTIVEATTRIB						(ES20_GENTEXTURES							+	1)
+#define	ES20_GETACTIVEUNIFORM						(ES20_GETACTIVEATTRIB						+	1)
+#define	ES20_GETATTACHEDSHADERS						(ES20_GETACTIVEUNIFORM						+	1)
+#define	ES20_GETATTRIBLOCATION						(ES20_GETATTACHEDSHADERS					+	1)
+#define	ES20_GETBOOLEANV							(ES20_GETATTRIBLOCATION						+	1)
+#define	ES20_GETBUFFERPARAMETERIV					(ES20_GETBOOLEANV							+	1)
+#define	ES20_GETERROR								(ES20_GETBUFFERPARAMETERIV					+	1)
+#define	ES20_GETFLOATV								(ES20_GETERROR								+	1)
+#define	ES20_GETFRAMEBUFFERATTACHMENTPARAMETERIV	(ES20_GETFLOATV								+	1)
+#define	ES20_GETINTEGERV							(ES20_GETFRAMEBUFFERATTACHMENTPARAMETERIV	+	1)
+#define	ES20_GETPROGRAMIV							(ES20_GETINTEGERV							+	1)
+#define	ES20_GETPROGRAMINFOLOG						(ES20_GETPROGRAMIV							+	1)
+#define	ES20_GETRENDERBUFFERPARAMETERIV				(ES20_GETPROGRAMINFOLOG						+	1)
+#define	ES20_GETSHADERIV							(ES20_GETRENDERBUFFERPARAMETERIV			+	1)
+#define	ES20_GETSHADERINFOLOG						(ES20_GETSHADERIV							+	1)
+#define	ES20_GETSHADERPRECISIONFORMAT				(ES20_GETSHADERINFOLOG						+	1)
+#define	ES20_GETSHADERSOURCE						(ES20_GETSHADERPRECISIONFORMAT				+	1)
+#define	ES20_GETSTRING								(ES20_GETSHADERSOURCE						+	1)
+#define	ES20_GETTEXPARAMETERFV						(ES20_GETSTRING								+	1)
+#define	ES20_GETTEXPARAMETERIV						(ES20_GETTEXPARAMETERFV						+	1)
+#define	ES20_GETUNIFORMFV							(ES20_GETTEXPARAMETERIV						+	1)
+#define	ES20_GETUNIFORMIV							(ES20_GETUNIFORMFV							+	1)
+#define	ES20_GETUNIFORMLOCATION						(ES20_GETUNIFORMIV							+	1)
+#define	ES20_GETVERTEXATTRIBFV						(ES20_GETUNIFORMLOCATION					+	1)
+#define	ES20_GETVERTEXATTRIBIV						(ES20_GETVERTEXATTRIBFV						+	1)
+#define	ES20_GETVERTEXATTRIBPOINTERV				(ES20_GETVERTEXATTRIBIV						+	1)
+#define	ES20_HINT									(ES20_GETVERTEXATTRIBPOINTERV				+	1)
+#define	ES20_ISBUFFER								(ES20_HINT									+	1)
+#define	ES20_ISENABLED								(ES20_ISBUFFER								+	1)
+#define	ES20_ISFRAMEBUFFER							(ES20_ISENABLED								+	1)
+#define	ES20_ISPROGRAM								(ES20_ISFRAMEBUFFER							+	1)
+#define	ES20_ISRENDERBUFFER							(ES20_ISPROGRAM								+	1)
+#define	ES20_ISSHADER								(ES20_ISRENDERBUFFER						+	1)
+#define	ES20_ISTEXTURE								(ES20_ISSHADER								+	1)
+#define	ES20_LINEWIDTH								(ES20_ISTEXTURE								+	1)
+#define	ES20_LINKPROGRAM							(ES20_LINEWIDTH								+	1)
+#define	ES20_PIXELSTOREI							(ES20_LINKPROGRAM							+	1)
+#define	ES20_POLYGONOFFSET							(ES20_PIXELSTOREI							+	1)
+#define	ES20_READPIXELS								(ES20_POLYGONOFFSET							+	1)
+#define	ES20_RELEASESHADERCOMPILER					(ES20_READPIXELS							+	1)
+#define	ES20_RENDERBUFFERSTORAGE					(ES20_RELEASESHADERCOMPILER					+	1)
+#define	ES20_SAMPLECOVERAGE							(ES20_RENDERBUFFERSTORAGE					+	1)
+#define	ES20_SCISSOR								(ES20_SAMPLECOVERAGE						+	1)
+#define	ES20_SHADERBINARY							(ES20_SCISSOR								+	1)
+#define	ES20_SHADERSOURCE							(ES20_SHADERBINARY							+	1)
+#define	ES20_STENCILFUNC							(ES20_SHADERSOURCE							+	1)
+#define	ES20_STENCILFUNCSEPARATE					(ES20_STENCILFUNC							+	1)
+#define	ES20_STENCILMASK							(ES20_STENCILFUNCSEPARATE					+	1)
+#define	ES20_STENCILMASKSEPARATE					(ES20_STENCILMASK							+	1)
+#define	ES20_STENCILOP								(ES20_STENCILMASKSEPARATE					+	1)
+#define	ES20_STENCILOPSEPARATE						(ES20_STENCILOP								+	1)
+#define	ES20_TEXIMAGE2D								(ES20_STENCILOPSEPARATE						+	1)
+#define	ES20_TEXPARAMETERF							(ES20_TEXIMAGE2D							+	1)
+#define	ES20_TEXPARAMETERFV							(ES20_TEXPARAMETERF							+	1)
+#define	ES20_TEXPARAMETERI							(ES20_TEXPARAMETERFV						+	1)
+#define	ES20_TEXPARAMETERIV							(ES20_TEXPARAMETERI							+	1)
+#define	ES20_TEXSUBIMAGE2D							(ES20_TEXPARAMETERIV						+	1)
+#define	ES20_UNIFORM1F								(ES20_TEXSUBIMAGE2D							+	1)
+#define	ES20_UNIFORM1FV								(ES20_UNIFORM1F								+	1)
+#define	ES20_UNIFORM1I								(ES20_UNIFORM1FV							+	1)
+#define	ES20_UNIFORM1IV								(ES20_UNIFORM1I								+	1)
+#define	ES20_UNIFORM2F								(ES20_UNIFORM1IV							+	1)
+#define	ES20_UNIFORM2FV								(ES20_UNIFORM2F								+	1)
+#define	ES20_UNIFORM2I								(ES20_UNIFORM2FV							+	1)
+#define	ES20_UNIFORM2IV								(ES20_UNIFORM2I								+	1)
+#define	ES20_UNIFORM3F								(ES20_UNIFORM2IV							+	1)
+#define	ES20_UNIFORM3FV								(ES20_UNIFORM3F								+	1)
+#define	ES20_UNIFORM3I								(ES20_UNIFORM3FV							+	1)
+#define	ES20_UNIFORM3IV								(ES20_UNIFORM3I								+	1)
+#define	ES20_UNIFORM4F								(ES20_UNIFORM3IV							+	1)
+#define	ES20_UNIFORM4FV								(ES20_UNIFORM4F								+	1)
+#define	ES20_UNIFORM4I								(ES20_UNIFORM4FV							+	1)
+#define	ES20_UNIFORM4IV								(ES20_UNIFORM4I								+	1)
+#define	ES20_UNIFORMMATRIX2FV						(ES20_UNIFORM4IV							+	1)
+#define	ES20_UNIFORMMATRIX3FV						(ES20_UNIFORMMATRIX2FV						+	1)
+#define	ES20_UNIFORMMATRIX4FV						(ES20_UNIFORMMATRIX3FV						+	1)
+#define	ES20_USEPROGRAM								(ES20_UNIFORMMATRIX4FV						+	1)
+#define	ES20_VALIDATEPROGRAM						(ES20_USEPROGRAM							+	1)
+#define	ES20_VERTEXATTRIB1F							(ES20_VALIDATEPROGRAM						+	1)
+#define	ES20_VERTEXATTRIB1FV						(ES20_VERTEXATTRIB1F						+	1)
+#define	ES20_VERTEXATTRIB2F							(ES20_VERTEXATTRIB1FV						+	1)
+#define	ES20_VERTEXATTRIB2FV						(ES20_VERTEXATTRIB2F						+	1)
+#define	ES20_VERTEXATTRIB3F							(ES20_VERTEXATTRIB2FV						+	1)
+#define	ES20_VERTEXATTRIB3FV						(ES20_VERTEXATTRIB3F						+	1)
+#define	ES20_VERTEXATTRIB4F							(ES20_VERTEXATTRIB3FV						+	1)
+#define	ES20_VERTEXATTRIB4FV						(ES20_VERTEXATTRIB4F						+	1)
+#define	ES20_VERTEXATTRIBPOINTER					(ES20_VERTEXATTRIB4FV						+	1)
+#define	ES20_VIEWPORT								(ES20_VERTEXATTRIBPOINTER					+	1)
+#define ES20_GETPROGRAMBINARYOES                    (ES20_VIEWPORT                              +   1)
+#define ES20_PROGRAMBINARYOES                       (ES20_GETPROGRAMBINARYOES                   +   1)
+#define ES20_TEXIMAGE3DOES                          (ES20_PROGRAMBINARYOES                      +   1)
+#define ES20_TEXSUBIMAGE3DOES                       (ES20_TEXIMAGE3DOES                         +   1)
+#define ES20_COPYSUBIMAGE3DOES                      (ES20_TEXSUBIMAGE3DOES                      +   1)
+#define ES20_COMPRESSEDTEXIMAGE3DOES                (ES20_COPYSUBIMAGE3DOES                     +   1)
+#define ES20_COMPRESSEDTEXSUBIMAGE3DOES             (ES20_COMPRESSEDTEXIMAGE3DOES               +   1)
+#define ES20_FRAMEBUFFERTEXTURE3DOES                (ES20_COMPRESSEDTEXSUBIMAGE3DOES            +   1)
+#define ES20_BINDVERTEXARRAYOES                     (ES20_FRAMEBUFFERTEXTURE3DOES               +   1)
+#define ES20_GENVERTEXARRAYOES                      (ES20_BINDVERTEXARRAYOES                    +   1)
+#define ES20_ISVERTEXARRAYOES                       (ES20_GENVERTEXARRAYOES                     +   1)
+#define ES20_DELETEVERTEXARRAYOES                   (ES20_ISVERTEXARRAYOES                      +   1)
+#define ES20_GLMAPBUFFEROES                         (ES20_DELETEVERTEXARRAYOES                  +   1)
+#define ES20_GLUNMAPBUFFEROES                       (ES20_GLMAPBUFFEROES                        +   1)
+#define ES20_GLGETBUFFERPOINTERVOES                 (ES20_GLUNMAPBUFFEROES                      +   1)
+#define	ES20_CALLS									(ES20_GLGETBUFFERPOINTERVOES				+	1)
+#define	ES20_DRAWCALLS								(ES20_CALLS									+	1)
+#define	ES20_STATECHANGECALLS						(ES20_DRAWCALLS								+	1)
+#define	ES20_POINTCOUNT								(ES20_STATECHANGECALLS						+	1)
+#define	ES20_LINECOUNT								(ES20_POINTCOUNT							+	1)
+#define	ES20_TRIANGLECOUNT							(ES20_LINECOUNT								+	1)
+
+/* OpenVG API IDs. */
+#define	VG11_APPENDPATH			     1
+#define	VG11_APPENDPATHDATA			(VG11_APPENDPATH				+ 1)
+#define	VG11_CHILDIMAGE				(VG11_APPENDPATHDATA			+ 1)
+#define	VG11_CLEAR					(VG11_CHILDIMAGE				+ 1)
+#define	VG11_CLEARGLYPH				(VG11_CLEAR						+ 1)
+#define	VG11_CLEARIMAGE				(VG11_CLEARGLYPH				+ 1)
+#define	VG11_CLEARPATH				(VG11_CLEARIMAGE				+ 1)
+#define	VG11_COLORMATRIX			(VG11_CLEARPATH					+ 1)
+#define	VG11_CONVOLVE				(VG11_COLORMATRIX				+ 1)
+#define	VG11_COPYIMAGE				(VG11_CONVOLVE					+ 1)
+#define	VG11_COPYMASK				(VG11_COPYIMAGE					+ 1)
+#define	VG11_COPYPIXELS				(VG11_COPYMASK					+ 1)
+#define	VG11_CREATEFONT				(VG11_COPYPIXELS				+ 1)
+#define	VG11_CREATEIMAGE			(VG11_CREATEFONT				+ 1)
+#define	VG11_CREATEMASKLAYER		(VG11_CREATEIMAGE				+ 1)
+#define	VG11_CREATEPAINT			(VG11_CREATEMASKLAYER			+ 1)
+#define	VG11_CREATEPATH				(VG11_CREATEPAINT				+ 1)
+#define	VG11_DESTROYFONT			(VG11_CREATEPATH				+ 1)
+#define	VG11_DESTROYIMAGE			(VG11_DESTROYFONT				+ 1)
+#define	VG11_DESTROYMASKLAYER		(VG11_DESTROYIMAGE				+ 1)
+#define	VG11_DESTROYPAINT			(VG11_DESTROYMASKLAYER			+ 1)
+#define	VG11_DESTROYPATH			(VG11_DESTROYPAINT				+ 1)
+#define	VG11_DRAWGLYPH				(VG11_DESTROYPATH				+ 1)
+#define	VG11_DRAWGLYPHS				(VG11_DRAWGLYPH					+ 1)
+#define	VG11_DRAWIMAGE				(VG11_DRAWGLYPHS				+ 1)
+#define	VG11_DRAWPATH				(VG11_DRAWIMAGE					+ 1)
+#define	VG11_FILLMASKLAYER			(VG11_DRAWPATH					+ 1)
+#define	VG11_FINISH					(VG11_FILLMASKLAYER				+ 1)
+#define	VG11_FLUSH					(VG11_FINISH					+ 1)
+#define	VG11_GAUSSIANBLUR			(VG11_FLUSH						+ 1)
+#define	VG11_GETCOLOR				(VG11_GAUSSIANBLUR				+ 1)
+#define	VG11_GETERROR				(VG11_GETCOLOR					+ 1)
+#define	VG11_GETF					(VG11_GETERROR					+ 1)
+#define	VG11_GETFV					(VG11_GETF						+ 1)
+#define	VG11_GETI					(VG11_GETFV						+ 1)
+#define	VG11_GETIMAGESUBDATA		(VG11_GETI						+ 1)
+#define	VG11_GETIV					(VG11_GETIMAGESUBDATA			+ 1)
+#define	VG11_GETMATRIX				(VG11_GETIV						+ 1)
+#define	VG11_GETPAINT				(VG11_GETMATRIX					+ 1)
+#define	VG11_GETPARAMETERF			(VG11_GETPAINT					+ 1)
+#define	VG11_GETPARAMETERFV			(VG11_GETPARAMETERF				+ 1)
+#define	VG11_GETPARAMETERI			(VG11_GETPARAMETERFV			+ 1)
+#define	VG11_GETPARAMETERIV			(VG11_GETPARAMETERI				+ 1)
+#define	VG11_GETPARAMETERVECTORSIZE	(VG11_GETPARAMETERIV			+ 1)
+#define	VG11_GETPARENT				(VG11_GETPARAMETERVECTORSIZE	+ 1)
+#define	VG11_GETPATHCAPABILITIES	(VG11_GETPARENT					+ 1)
+#define	VG11_GETPIXELS				(VG11_GETPATHCAPABILITIES		+ 1)
+#define	VG11_GETSTRING				(VG11_GETPIXELS					+ 1)
+#define	VG11_GETVECTORSIZE			(VG11_GETSTRING					+ 1)
+#define	VG11_HARDWAREQUERY			(VG11_GETVECTORSIZE				+ 1)
+#define	VG11_IMAGESUBDATA			(VG11_HARDWAREQUERY				+ 1)
+#define	VG11_INTERPOLATEPATH		(VG11_IMAGESUBDATA				+ 1)
+#define	VG11_LOADIDENTITY			(VG11_INTERPOLATEPATH			+ 1)
+#define	VG11_LOADMATRIX				(VG11_LOADIDENTITY				+ 1)
+#define	VG11_LOOKUP					(VG11_LOADMATRIX				+ 1)
+#define	VG11_LOOKUPSINGLE			(VG11_LOOKUP					+ 1)
+#define	VG11_MASK					(VG11_LOOKUPSINGLE				+ 1)
+#define	VG11_MODIFYPATHCOORDS		(VG11_MASK						+ 1)
+#define	VG11_MULTMATRIX				(VG11_MODIFYPATHCOORDS			+ 1)
+#define	VG11_PAINTPATTERN			(VG11_MULTMATRIX				+ 1)
+#define	VG11_PATHBOUNDS				(VG11_PAINTPATTERN				+ 1)
+#define	VG11_PATHLENGTH				(VG11_PATHBOUNDS				+ 1)
+#define	VG11_PATHTRANSFORMEDBOUNDS	(VG11_PATHLENGTH				+ 1)
+#define	VG11_POINTALONGPATH			(VG11_PATHTRANSFORMEDBOUNDS		+ 1)
+#define	VG11_READPIXELS				(VG11_POINTALONGPATH			+ 1)
+#define	VG11_REMOVEPATHCAPABILITIES	(VG11_READPIXELS				+ 1)
+#define	VG11_RENDERTOMASK			(VG11_REMOVEPATHCAPABILITIES	+ 1)
+#define	VG11_ROTATE					(VG11_RENDERTOMASK				+ 1)
+#define	VG11_SCALE					(VG11_ROTATE					+ 1)
+#define	VG11_SEPARABLECONVOLVE		(VG11_SCALE						+ 1)
+#define	VG11_SETCOLOR				(VG11_SEPARABLECONVOLVE			+ 1)
+#define	VG11_SETF					(VG11_SETCOLOR					+ 1)
+#define	VG11_SETFV					(VG11_SETF						+ 1)
+#define	VG11_SETGLYPHTOIMAGE		(VG11_SETFV						+ 1)
+#define	VG11_SETGLYPHTOPATH			(VG11_SETGLYPHTOIMAGE			+ 1)
+#define	VG11_SETI					(VG11_SETGLYPHTOPATH			+ 1)
+#define	VG11_SETIV					(VG11_SETI						+ 1)
+#define	VG11_SETPAINT				(VG11_SETIV						+ 1)
+#define	VG11_SETPARAMETERF			(VG11_SETPAINT					+ 1)
+#define	VG11_SETPARAMETERFV			(VG11_SETPARAMETERF				+ 1)
+#define	VG11_SETPARAMETERI			(VG11_SETPARAMETERFV			+ 1)
+#define	VG11_SETPARAMETERIV			(VG11_SETPARAMETERI				+ 1)
+#define	VG11_SETPIXELS				(VG11_SETPARAMETERIV			+ 1)
+#define	VG11_SHEAR					(VG11_SETPIXELS					+ 1)
+#define	VG11_TRANSFORMPATH			(VG11_SHEAR						+ 1)
+#define	VG11_TRANSLATE				(VG11_TRANSFORMPATH				+ 1)
+#define	VG11_WRITEPIXELS			(VG11_TRANSLATE					+ 1)
+#define VG11_CALLS                  (VG11_WRITEPIXELS               + 1)
+#define VG11_DRAWCALLS              (VG11_CALLS                     + 1)
+#define VG11_STATECHANGECALLS       (VG11_DRAWCALLS                 + 1)
+#define VG11_FILLCOUNT              (VG11_STATECHANGECALLS          + 1)
+#define VG11_STROKECOUNT            (VG11_FILLCOUNT                 + 1)
+/* End of Driver API ID Definitions. */
+
+/* HAL & MISC IDs. */
+#define HAL_VERTBUFNEWBYTEALLOC		1
+#define HAL_VERTBUFTOTALBYTEALLOC	(HAL_VERTBUFNEWBYTEALLOC 	+ 1)
+#define HAL_VERTBUFNEWOBJALLOC		(HAL_VERTBUFTOTALBYTEALLOC	+ 1)
+#define HAL_VERTBUFTOTALOBJALLOC	(HAL_VERTBUFNEWOBJALLOC		+ 1)
+#define HAL_INDBUFNEWBYTEALLOC		(HAL_VERTBUFTOTALOBJALLOC	+ 1)
+#define HAL_INDBUFTOTALBYTEALLOC	(HAL_INDBUFNEWBYTEALLOC		+ 1)
+#define HAL_INDBUFNEWOBJALLOC		(HAL_INDBUFTOTALBYTEALLOC	+ 1)
+#define HAL_INDBUFTOTALOBJALLOC		(HAL_INDBUFNEWOBJALLOC		+ 1)
+#define HAL_TEXBUFNEWBYTEALLOC		(HAL_INDBUFTOTALOBJALLOC	+ 1)
+#define HAL_TEXBUFTOTALBYTEALLOC	(HAL_TEXBUFNEWBYTEALLOC		+ 1)
+#define HAL_TEXBUFNEWOBJALLOC		(HAL_TEXBUFTOTALBYTEALLOC	+ 1)
+#define HAL_TEXBUFTOTALOBJALLOC		(HAL_TEXBUFNEWOBJALLOC		+ 1)
+
+#define GPU_CYCLES		1
+#define GPU_READ64BYTE	(GPU_CYCLES		+ 1)
+#define GPU_WRITE64BYTE	(GPU_READ64BYTE	+ 1)
+
+#define VS_INSTCOUNT			1
+#define VS_BRANCHINSTCOUNT		(VS_INSTCOUNT		+ 1)
+#define VS_TEXLDINSTCOUNT		(VS_BRANCHINSTCOUNT	+ 1)
+#define VS_RENDEREDVERTCOUNT	(VS_TEXLDINSTCOUNT	+ 1)
+
+#define PS_INSTCOUNT			1
+#define PS_BRANCHINSTCOUNT		(PS_INSTCOUNT		+ 1)
+#define PS_TEXLDINSTCOUNT		(PS_BRANCHINSTCOUNT	+ 1)
+#define PS_RENDEREDPIXCOUNT		(PS_TEXLDINSTCOUNT	+ 1)
+
+#define PA_INVERTCOUNT		1
+#define	PA_INPRIMCOUNT		(PA_INVERTCOUNT		+ 1)
+#define PA_OUTPRIMCOUNT		(PA_INPRIMCOUNT		+ 1)
+#define PA_DEPTHCLIPCOUNT	(PA_OUTPRIMCOUNT	+ 1)
+#define PA_TRIVIALREJCOUNT	(PA_DEPTHCLIPCOUNT	+ 1)
+#define PA_CULLCOUNT		(PA_TRIVIALREJCOUNT	+ 1)
+
+#define SE_TRIANGLECOUNT	1
+#define SE_LINECOUNT		(SE_TRIANGLECOUNT	+ 1)
+
+#define RA_VALIDPIXCOUNT		1
+#define RA_TOTALQUADCOUNT		(RA_VALIDPIXCOUNT		+ 1)
+#define RA_VALIDQUADCOUNTEZ		(RA_TOTALQUADCOUNT		+ 1)
+#define RA_TOTALPRIMCOUNT		(RA_VALIDQUADCOUNTEZ	+ 1)
+#define RA_PIPECACHEMISSCOUNT	(RA_TOTALPRIMCOUNT		+ 1)
+#define RA_PREFCACHEMISSCOUNT	(RA_PIPECACHEMISSCOUNT	+ 1)
+#define RA_EEZCULLCOUNT			(RA_PREFCACHEMISSCOUNT	+ 1)
+
+#define TX_TOTBILINEARREQ		1
+#define TX_TOTTRILINEARREQ		(TX_TOTBILINEARREQ		+ 1)
+#define TX_TOTDISCARDTEXREQ		(TX_TOTTRILINEARREQ		+ 1)
+#define TX_TOTTEXREQ			(TX_TOTDISCARDTEXREQ	+ 1)
+#define TX_MEMREADCOUNT			(TX_TOTTEXREQ			+ 1)
+#define TX_MEMREADIN8BCOUNT		(TX_MEMREADCOUNT		+ 1)
+#define TX_CACHEMISSCOUNT		(TX_MEMREADIN8BCOUNT	+ 1)
+#define TX_CACHEHITTEXELCOUNT	(TX_CACHEMISSCOUNT		+ 1)
+#define TX_CACHEMISSTEXELCOUNT	(TX_CACHEHITTEXELCOUNT	+ 1)
+
+#define PE_KILLEDBYCOLOR	1
+#define PE_KILLEDBYDEPTH	(PE_KILLEDBYCOLOR	+ 1)
+#define PE_DRAWNBYCOLOR		(PE_KILLEDBYDEPTH	+ 1)
+#define PE_DRAWNBYDEPTH		(PE_DRAWNBYCOLOR	+ 1)
+
+#define MC_READREQ8BPIPE	1
+#define MC_READREQ8BIP		(MC_READREQ8BPIPE	+ 1)
+#define MC_WRITEREQ8BPIPE	(MC_READREQ8BIP		+ 1)
+
+#define AXI_READREQSTALLED		1
+#define AXI_WRITEREQSTALLED		(AXI_READREQSTALLED		+ 1)
+#define AXI_WRITEDATASTALLED	(AXI_WRITEREQSTALLED	+ 1)
+
+#define PVS_INSTRCOUNT		1
+#define PVS_ALUINSTRCOUNT	(PVS_INSTRCOUNT		+ 1)
+#define PVS_TEXINSTRCOUNT	(PVS_ALUINSTRCOUNT	+ 1)
+#define PVS_ATTRIBCOUNT		(PVS_TEXINSTRCOUNT	+ 1)
+#define PVS_UNIFORMCOUNT	(PVS_ATTRIBCOUNT	+ 1)
+#define PVS_FUNCTIONCOUNT	(PVS_UNIFORMCOUNT	+ 1)
+
+#define PPS_INSTRCOUNT		1
+#define PPS_ALUINSTRCOUNT	(PPS_INSTRCOUNT		+ 1)
+#define PPS_TEXINSTRCOUNT	(PPS_ALUINSTRCOUNT	+ 1)
+#define PPS_ATTRIBCOUNT		(PPS_TEXINSTRCOUNT	+ 1)
+#define PPS_UNIFORMCOUNT	(PPS_ATTRIBCOUNT	+ 1)
+#define PPS_FUNCTIONCOUNT 	(PPS_UNIFORMCOUNT	+ 1)
+/* End of MISC Counter IDs. */
+
+#ifdef gcdNEW_PROFILER_FILE
+
+/* Category Constants. */
+#define VPHEADER        0x010000
+#define VPG_INFO        0x020000
+#define VPG_TIME        0x030000
+#define VPG_MEM         0x040000
+#define VPG_ES11        0x050000
+#define VPG_ES20        0x060000
+#define VPG_VG11        0x070000
+#define VPG_HAL         0x080000
+#define VPG_HW          0x090000
+#define VPG_GPU         0x0a0000
+#define VPG_VS          0x0b0000
+#define VPG_PS          0x0c0000
+#define VPG_PA          0x0d0000
+#define VPG_SETUP       0x0e0000
+#define VPG_RA          0x0f0000
+#define VPG_TX          0x100000
+#define VPG_PE          0x110000
+#define VPG_MC          0x120000
+#define VPG_AXI         0x130000
+#define VPG_PROG        0x140000
+#define VPG_PVS         0x150000
+#define VPG_PPS         0x160000
+#define VPG_FRAME       0x170000
+#define VPG_END         0xff0000
+
+/* Info. */
+#define VPC_INFOCOMPANY         (VPG_INFO + 1)
+#define VPC_INFOVERSION         (VPC_INFOCOMPANY + 1)
+#define VPC_INFORENDERER        (VPC_INFOVERSION + 1)
+#define VPC_INFOREVISION        (VPC_INFORENDERER + 1)
+#define VPC_INFODRIVER          (VPC_INFOREVISION + 1)
+#define VPC_INFODRIVERMODE      (VPC_INFODRIVER + 1)
+#define VPC_INFOSCREENSIZE      (VPC_INFODRIVERMODE + 1)
+
+/* Counter Constants. */
+#define VPC_ELAPSETIME  		(VPG_TIME + 1)
+#define VPC_CPUTIME             (VPC_ELAPSETIME + 1)
+
+#define VPC_MEMMAXRES           (VPG_MEM + 1)
+#define VPC_MEMSHARED           (VPC_MEMMAXRES + 1)
+#define VPC_MEMUNSHAREDDATA     (VPC_MEMSHARED + 1)
+#define VPC_MEMUNSHAREDSTACK    (VPC_MEMUNSHAREDDATA + 1)
+
+/* OpenGL ES11 Counters. */
+#define	VPC_ES11ACTIVETEXTURE			(VPG_ES11 +	ES11_ACTIVETEXTURE)
+#define	VPC_ES11ALPHAFUNC				(VPG_ES11 +	ES11_ALPHAFUNC)
+#define	VPC_ES11ALPHAFUNCX				(VPG_ES11 +	ES11_ALPHAFUNCX)
+#define	VPC_ES11BINDBUFFER				(VPG_ES11 +	ES11_BINDBUFFER)
+#define	VPC_ES11BINDTEXTURE				(VPG_ES11 +	ES11_BINDTEXTURE)
+#define	VPC_ES11BLENDFUNC				(VPG_ES11 +	ES11_BLENDFUNC)
+#define	VPC_ES11BUFFERDATA				(VPG_ES11 +	ES11_BUFFERDATA)
+#define	VPC_ES11BUFFERSUBDATA			(VPG_ES11 +	ES11_BUFFERSUBDATA)
+#define	VPC_ES11CLEAR					(VPG_ES11 +	ES11_CLEAR)
+#define	VPC_ES11CLEARCOLOR				(VPG_ES11 +	ES11_CLEARCOLOR)
+#define	VPC_ES11CLEARCOLORX				(VPG_ES11 +	ES11_CLEARCOLORX)
+#define	VPC_ES11CLEARDEPTHF				(VPG_ES11 +	ES11_CLEARDEPTHF)
+#define	VPC_ES11CLEARDEPTHX				(VPG_ES11 +	ES11_CLEARDEPTHX)
+#define	VPC_ES11CLEARSTENCIL			(VPG_ES11 +	ES11_CLEARSTENCIL)
+#define	VPC_ES11CLIENTACTIVETEXTURE		(VPG_ES11 +	ES11_CLIENTACTIVETEXTURE)
+#define	VPC_ES11CLIPPLANEF				(VPG_ES11 +	ES11_CLIPPLANEF)
+#define	VPC_ES11CLIPPLANEX				(VPG_ES11 +	ES11_CLIPPLANEX)
+#define	VPC_ES11COLOR4F					(VPG_ES11 +	ES11_COLOR4F)
+#define	VPC_ES11COLOR4UB				(VPG_ES11 +	ES11_COLOR4UB)
+#define	VPC_ES11COLOR4X					(VPG_ES11 +	ES11_COLOR4X)
+#define	VPC_ES11COLORMASK				(VPG_ES11 +	ES11_COLORMASK)
+#define	VPC_ES11COLORPOINTER			(VPG_ES11 +	ES11_COLORPOINTER)
+#define	VPC_ES11COMPRESSEDTEXIMAGE2D	(VPG_ES11 +	ES11_COMPRESSEDTEXIMAGE2D)
+#define	VPC_ES11COMPRESSEDTEXSUBIMAGE2D	(VPG_ES11 +	ES11_COMPRESSEDTEXSUBIMAGE2D)
+#define	VPC_ES11COPYTEXIMAGE2D			(VPG_ES11 +	ES11_COPYTEXIMAGE2D)
+#define	VPC_ES11COPYTEXSUBIMAGE2D		(VPG_ES11 +	ES11_COPYTEXSUBIMAGE2D)
+#define	VPC_ES11CULLFACE				(VPG_ES11 +	ES11_CULLFACE)
+#define	VPC_ES11DELETEBUFFERS			(VPG_ES11 +	ES11_DELETEBUFFERS)
+#define	VPC_ES11DELETETEXTURES			(VPG_ES11 +	ES11_DELETETEXTURES)
+#define	VPC_ES11DEPTHFUNC				(VPG_ES11 +	ES11_DEPTHFUNC)
+#define	VPC_ES11DEPTHMASK				(VPG_ES11 +	ES11_DEPTHMASK)
+#define	VPC_ES11DEPTHRANGEF				(VPG_ES11 +	ES11_DEPTHRANGEF)
+#define	VPC_ES11DEPTHRANGEX				(VPG_ES11 +	ES11_DEPTHRANGEX)
+#define	VPC_ES11DISABLE					(VPG_ES11 +	ES11_DISABLE)
+#define	VPC_ES11DISABLECLIENTSTATE		(VPG_ES11 +	ES11_DISABLECLIENTSTATE)
+#define	VPC_ES11DRAWARRAYS				(VPG_ES11 +	ES11_DRAWARRAYS)
+#define	VPC_ES11DRAWELEMENTS			(VPG_ES11 +	ES11_DRAWELEMENTS)
+#define	VPC_ES11ENABLE					(VPG_ES11 +	ES11_ENABLE)
+#define	VPC_ES11ENABLECLIENTSTATE		(VPG_ES11 +	ES11_ENABLECLIENTSTATE)
+#define	VPC_ES11FINISH					(VPG_ES11 +	ES11_FINISH)
+#define	VPC_ES11FLUSH					(VPG_ES11 +	ES11_FLUSH)
+#define	VPC_ES11FOGF					(VPG_ES11 +	ES11_FOGF)
+#define	VPC_ES11FOGFV					(VPG_ES11 +	ES11_FOGFV)
+#define	VPC_ES11FOGX					(VPG_ES11 +	ES11_FOGX)
+#define	VPC_ES11FOGXV					(VPG_ES11 +	ES11_FOGXV)
+#define	VPC_ES11FRONTFACE				(VPG_ES11 +	ES11_FRONTFACE)
+#define	VPC_ES11FRUSTUMF				(VPG_ES11 +	ES11_FRUSTUMF)
+#define	VPC_ES11FRUSTUMX				(VPG_ES11 +	ES11_FRUSTUMX)
+#define	VPC_ES11GENBUFFERS				(VPG_ES11 +	ES11_GENBUFFERS)
+#define	VPC_ES11GENTEXTURES				(VPG_ES11 +	ES11_GENTEXTURES)
+#define	VPC_ES11GETBOOLEANV				(VPG_ES11 +	ES11_GETBOOLEANV)
+#define	VPC_ES11GETBUFFERPARAMETERIV	(VPG_ES11 +	ES11_GETBUFFERPARAMETERIV)
+#define	VPC_ES11GETCLIPPLANEF			(VPG_ES11 +	ES11_GETCLIPPLANEF)
+#define	VPC_ES11GETCLIPPLANEX			(VPG_ES11 +	ES11_GETCLIPPLANEX)
+#define	VPC_ES11GETERROR				(VPG_ES11 +	ES11_GETERROR)
+#define	VPC_ES11GETFIXEDV				(VPG_ES11 +	ES11_GETFIXEDV)
+#define	VPC_ES11GETFLOATV				(VPG_ES11 +	ES11_GETFLOATV)
+#define	VPC_ES11GETINTEGERV				(VPG_ES11 +	ES11_GETINTEGERV)
+#define	VPC_ES11GETLIGHTFV				(VPG_ES11 +	ES11_GETLIGHTFV)
+#define	VPC_ES11GETLIGHTXV				(VPG_ES11 +	ES11_GETLIGHTXV)
+#define	VPC_ES11GETMATERIALFV			(VPG_ES11 +	ES11_GETMATERIALFV)
+#define	VPC_ES11GETMATERIALXV			(VPG_ES11 +	ES11_GETMATERIALXV)
+#define	VPC_ES11GETPOINTERV				(VPG_ES11 +	ES11_GETPOINTERV)
+#define	VPC_ES11GETSTRING				(VPG_ES11 +	ES11_GETSTRING)
+#define	VPC_ES11GETTEXENVFV				(VPG_ES11 +	ES11_GETTEXENVFV)
+#define	VPC_ES11GETTEXENVIV				(VPG_ES11 +	ES11_GETTEXENVIV)
+#define	VPC_ES11GETTEXENVXV				(VPG_ES11 +	ES11_GETTEXENVXV)
+#define	VPC_ES11GETTEXPARAMETERFV		(VPG_ES11 +	ES11_GETTEXPARAMETERFV)
+#define	VPC_ES11GETTEXPARAMETERIV		(VPG_ES11 +	ES11_GETTEXPARAMETERIV)
+#define	VPC_ES11GETTEXPARAMETERXV		(VPG_ES11 +	ES11_GETTEXPARAMETERXV)
+#define	VPC_ES11HINT					(VPG_ES11 +	ES11_HINT)
+#define	VPC_ES11ISBUFFER				(VPG_ES11 +	ES11_ISBUFFER)
+#define	VPC_ES11ISENABLED				(VPG_ES11 +	ES11_ISENABLED)
+#define	VPC_ES11ISTEXTURE				(VPG_ES11 +	ES11_ISTEXTURE)
+#define	VPC_ES11LIGHTF					(VPG_ES11 +	ES11_LIGHTF)
+#define	VPC_ES11LIGHTFV					(VPG_ES11 +	ES11_LIGHTFV)
+#define	VPC_ES11LIGHTMODELF				(VPG_ES11 +	ES11_LIGHTMODELF)
+#define	VPC_ES11LIGHTMODELFV			(VPG_ES11 +	ES11_LIGHTMODELFV)
+#define	VPC_ES11LIGHTMODELX				(VPG_ES11 +	ES11_LIGHTMODELX)
+#define	VPC_ES11LIGHTMODELXV			(VPG_ES11 +	ES11_LIGHTMODELXV)
+#define	VPC_ES11LIGHTX					(VPG_ES11 +	ES11_LIGHTX)
+#define	VPC_ES11LIGHTXV					(VPG_ES11 +	ES11_LIGHTXV)
+#define	VPC_ES11LINEWIDTH				(VPG_ES11 +	ES11_LINEWIDTH)
+#define	VPC_ES11LINEWIDTHX				(VPG_ES11 +	ES11_LINEWIDTHX)
+#define	VPC_ES11LOADIDENTITY			(VPG_ES11 +	ES11_LOADIDENTITY)
+#define	VPC_ES11LOADMATRIXF				(VPG_ES11 +	ES11_LOADMATRIXF)
+#define	VPC_ES11LOADMATRIXX				(VPG_ES11 +	ES11_LOADMATRIXX)
+#define	VPC_ES11LOGICOP					(VPG_ES11 +	ES11_LOGICOP)
+#define	VPC_ES11MATERIALF				(VPG_ES11 +	ES11_MATERIALF)
+#define	VPC_ES11MATERIALFV				(VPG_ES11 +	ES11_MATERIALFV)
+#define	VPC_ES11MATERIALX				(VPG_ES11 +	ES11_MATERIALX)
+#define	VPC_ES11MATERIALXV				(VPG_ES11 +	ES11_MATERIALXV)
+#define	VPC_ES11MATRIXMODE				(VPG_ES11 +	ES11_MATRIXMODE)
+#define	VPC_ES11MULTITEXCOORD4F			(VPG_ES11 +	ES11_MULTITEXCOORD4F)
+#define	VPC_ES11MULTITEXCOORD4X			(VPG_ES11 +	ES11_MULTITEXCOORD4X)
+#define	VPC_ES11MULTMATRIXF				(VPG_ES11 +	ES11_MULTMATRIXF)
+#define	VPC_ES11MULTMATRIXX				(VPG_ES11 +	ES11_MULTMATRIXX)
+#define	VPC_ES11NORMAL3F				(VPG_ES11 +	ES11_NORMAL3F)
+#define	VPC_ES11NORMAL3X				(VPG_ES11 +	ES11_NORMAL3X)
+#define	VPC_ES11NORMALPOINTER			(VPG_ES11 +	ES11_NORMALPOINTER)
+#define	VPC_ES11ORTHOF					(VPG_ES11 +	ES11_ORTHOF)
+#define	VPC_ES11ORTHOX					(VPG_ES11 +	ES11_ORTHOX)
+#define	VPC_ES11PIXELSTOREI				(VPG_ES11 +	ES11_PIXELSTOREI)
+#define	VPC_ES11POINTPARAMETERF			(VPG_ES11 +	ES11_POINTPARAMETERF)
+#define	VPC_ES11POINTPARAMETERFV		(VPG_ES11 +	ES11_POINTPARAMETERFV)
+#define	VPC_ES11POINTPARAMETERX			(VPG_ES11 +	ES11_POINTPARAMETERX)
+#define	VPC_ES11POINTPARAMETERXV		(VPG_ES11 +	ES11_POINTPARAMETERXV)
+#define	VPC_ES11POINTSIZE				(VPG_ES11 +	ES11_POINTSIZE)
+#define	VPC_ES11POINTSIZEX				(VPG_ES11 +	ES11_POINTSIZEX)
+#define	VPC_ES11POLYGONOFFSET			(VPG_ES11 +	ES11_POLYGONOFFSET)
+#define	VPC_ES11POLYGONOFFSETX			(VPG_ES11 +	ES11_POLYGONOFFSETX)
+#define	VPC_ES11POPMATRIX				(VPG_ES11 +	ES11_POPMATRIX)
+#define	VPC_ES11PUSHMATRIX				(VPG_ES11 +	ES11_PUSHMATRIX)
+#define	VPC_ES11READPIXELS				(VPG_ES11 +	ES11_READPIXELS)
+#define	VPC_ES11ROTATEF					(VPG_ES11 +	ES11_ROTATEF)
+#define	VPC_ES11ROTATEX					(VPG_ES11 +	ES11_ROTATEX)
+#define	VPC_ES11SAMPLECOVERAGE			(VPG_ES11 +	ES11_SAMPLECOVERAGE)
+#define	VPC_ES11SAMPLECOVERAGEX			(VPG_ES11 +	ES11_SAMPLECOVERAGEX)
+#define	VPC_ES11SCALEF					(VPG_ES11 +	ES11_SCALEF)
+#define	VPC_ES11SCALEX					(VPG_ES11 +	ES11_SCALEX)
+#define	VPC_ES11SCISSOR					(VPG_ES11 +	ES11_SCISSOR)
+#define	VPC_ES11SHADEMODEL				(VPG_ES11 +	ES11_SHADEMODEL)
+#define	VPC_ES11STENCILFUNC				(VPG_ES11 +	ES11_STENCILFUNC)
+#define	VPC_ES11STENCILMASK				(VPG_ES11 +	ES11_STENCILMASK)
+#define	VPC_ES11STENCILOP				(VPG_ES11 +	ES11_STENCILOP)
+#define	VPC_ES11TEXCOORDPOINTER			(VPG_ES11 +	ES11_TEXCOORDPOINTER)
+#define	VPC_ES11TEXENVF					(VPG_ES11 +	ES11_TEXENVF)
+#define	VPC_ES11TEXENVFV				(VPG_ES11 +	ES11_TEXENVFV)
+#define	VPC_ES11TEXENVI					(VPG_ES11 +	ES11_TEXENVI)
+#define	VPC_ES11TEXENVIV				(VPG_ES11 +	ES11_TEXENVIV)
+#define	VPC_ES11TEXENVX					(VPG_ES11 +	ES11_TEXENVX)
+#define	VPC_ES11TEXENVXV				(VPG_ES11 +	ES11_TEXENVXV)
+#define	VPC_ES11TEXIMAGE2D				(VPG_ES11 +	ES11_TEXIMAGE2D)
+#define	VPC_ES11TEXPARAMETERF			(VPG_ES11 +	ES11_TEXPARAMETERF)
+#define	VPC_ES11TEXPARAMETERFV			(VPG_ES11 +	ES11_TEXPARAMETERFV)
+#define	VPC_ES11TEXPARAMETERI			(VPG_ES11 +	ES11_TEXPARAMETERI)
+#define	VPC_ES11TEXPARAMETERIV			(VPG_ES11 +	ES11_TEXPARAMETERIV)
+#define	VPC_ES11TEXPARAMETERX			(VPG_ES11 +	ES11_TEXPARAMETERX)
+#define	VPC_ES11TEXPARAMETERXV			(VPG_ES11 +	ES11_TEXPARAMETERXV)
+#define	VPC_ES11TEXSUBIMAGE2D			(VPG_ES11 +	ES11_TEXSUBIMAGE2D)
+#define	VPC_ES11TRANSLATEF				(VPG_ES11 +	ES11_TRANSLATEF)
+#define	VPC_ES11TRANSLATEX				(VPG_ES11 +	ES11_TRANSLATEX)
+#define	VPC_ES11VERTEXPOINTER			(VPG_ES11 +	ES11_VERTEXPOINTER)
+#define	VPC_ES11VIEWPORT				(VPG_ES11 +	ES11_VIEWPORT)
+/* OpenGL ES11 Statics Counter IDs. */
+#define	VPC_ES11CALLS					(VPG_ES11 +	ES11_CALLS)
+#define	VPC_ES11DRAWCALLS				(VPG_ES11 +	ES11_DRAWCALLS)
+#define	VPC_ES11STATECHANGECALLS		(VPG_ES11 +	ES11_STATECHANGECALLS)
+#define	VPC_ES11POINTCOUNT				(VPG_ES11 +	ES11_POINTCOUNT)
+#define	VPC_ES11LINECOUNT				(VPG_ES11 +	ES11_LINECOUNT)
+#define	VPC_ES11TRIANGLECOUNT			(VPG_ES11 +	ES11_TRIANGLECOUNT)
+
+/* OpenGLES 2.x */
+#define	VPC_ES20ACTIVETEXTURE						(VPG_ES20 +	ES20_ACTIVETEXTURE)
+#define	VPC_ES20ATTACHSHADER						(VPG_ES20 +	ES20_ATTACHSHADER)
+#define	VPC_ES20BINDATTRIBLOCATION					(VPG_ES20 +	ES20_BINDATTRIBLOCATION)
+#define	VPC_ES20BINDBUFFER							(VPG_ES20 +	ES20_BINDBUFFER)
+#define	VPC_ES20BINDFRAMEBUFFER						(VPG_ES20 +	ES20_BINDFRAMEBUFFER)
+#define	VPC_ES20BINDRENDERBUFFER					(VPG_ES20 +	ES20_BINDRENDERBUFFER)
+#define	VPC_ES20BINDTEXTURE							(VPG_ES20 +	ES20_BINDTEXTURE)
+#define	VPC_ES20BLENDCOLOR							(VPG_ES20 +	ES20_BLENDCOLOR)
+#define	VPC_ES20BLENDEQUATION						(VPG_ES20 +	ES20_BLENDEQUATION)
+#define	VPC_ES20BLENDEQUATIONSEPARATE				(VPG_ES20 +	ES20_BLENDEQUATIONSEPARATE)
+#define	VPC_ES20BLENDFUNC							(VPG_ES20 +	ES20_BLENDFUNC)
+#define	VPC_ES20BLENDFUNCSEPARATE					(VPG_ES20 +	ES20_BLENDFUNCSEPARATE)
+#define	VPC_ES20BUFFERDATA							(VPG_ES20 +	ES20_BUFFERDATA)
+#define	VPC_ES20BUFFERSUBDATA						(VPG_ES20 +	ES20_BUFFERSUBDATA)
+#define	VPC_ES20CHECKFRAMEBUFFERSTATUS				(VPG_ES20 +	ES20_CHECKFRAMEBUFFERSTATUS)
+#define	VPC_ES20CLEAR								(VPG_ES20 +	ES20_CLEAR)
+#define	VPC_ES20CLEARCOLOR							(VPG_ES20 +	ES20_CLEARCOLOR)
+#define	VPC_ES20CLEARDEPTHF							(VPG_ES20 +	ES20_CLEARDEPTHF)
+#define	VPC_ES20CLEARSTENCIL						(VPG_ES20 +	ES20_CLEARSTENCIL)
+#define	VPC_ES20COLORMASK							(VPG_ES20 +	ES20_COLORMASK)
+#define	VPC_ES20COMPILESHADER						(VPG_ES20 +	ES20_COMPILESHADER)
+#define	VPC_ES20COMPRESSEDTEXIMAGE2D				(VPG_ES20 +	ES20_COMPRESSEDTEXIMAGE2D)
+#define	VPC_ES20COMPRESSEDTEXSUBIMAGE2D				(VPG_ES20 +	ES20_COMPRESSEDTEXSUBIMAGE2D)
+#define	VPC_ES20COPYTEXIMAGE2D						(VPG_ES20 +	ES20_COPYTEXIMAGE2D)
+#define	VPC_ES20COPYTEXSUBIMAGE2D					(VPG_ES20 +	ES20_COPYTEXSUBIMAGE2D)
+#define	VPC_ES20CREATEPROGRAM						(VPG_ES20 +	ES20_CREATEPROGRAM)
+#define	VPC_ES20CREATESHADER						(VPG_ES20 +	ES20_CREATESHADER)
+#define	VPC_ES20CULLFACE							(VPG_ES20 +	ES20_CULLFACE)
+#define	VPC_ES20DELETEBUFFERS						(VPG_ES20 +	ES20_DELETEBUFFERS)
+#define	VPC_ES20DELETEFRAMEBUFFERS					(VPG_ES20 +	ES20_DELETEFRAMEBUFFERS)
+#define	VPC_ES20DELETEPROGRAM						(VPG_ES20 +	ES20_DELETEPROGRAM)
+#define	VPC_ES20DELETERENDERBUFFERS					(VPG_ES20 +	ES20_DELETERENDERBUFFERS)
+#define	VPC_ES20DELETESHADER						(VPG_ES20 +	ES20_DELETESHADER)
+#define	VPC_ES20DELETETEXTURES						(VPG_ES20 +	ES20_DELETETEXTURES)
+#define	VPC_ES20DEPTHFUNC							(VPG_ES20 +	ES20_DEPTHFUNC)
+#define	VPC_ES20DEPTHMASK							(VPG_ES20 +	ES20_DEPTHMASK)
+#define	VPC_ES20DEPTHRANGEF							(VPG_ES20 +	ES20_DEPTHRANGEF)
+#define	VPC_ES20DETACHSHADER						(VPG_ES20 +	ES20_DETACHSHADER)
+#define	VPC_ES20DISABLE								(VPG_ES20 +	ES20_DISABLE)
+#define	VPC_ES20DISABLEVERTEXATTRIBARRAY			(VPG_ES20 +	ES20_DISABLEVERTEXATTRIBARRAY)
+#define	VPC_ES20DRAWARRAYS							(VPG_ES20 +	ES20_DRAWARRAYS)
+#define	VPC_ES20DRAWELEMENTS						(VPG_ES20 +	ES20_DRAWELEMENTS)
+#define	VPC_ES20ENABLE								(VPG_ES20 +	ES20_ENABLE)
+#define	VPC_ES20ENABLEVERTEXATTRIBARRAY				(VPG_ES20 +	ES20_ENABLEVERTEXATTRIBARRAY)
+#define	VPC_ES20FINISH								(VPG_ES20 +	ES20_FINISH)
+#define	VPC_ES20FLUSH								(VPG_ES20 +	ES20_FLUSH)
+#define	VPC_ES20FRAMEBUFFERRENDERBUFFER				(VPG_ES20 +	ES20_FRAMEBUFFERRENDERBUFFER)
+#define	VPC_ES20FRAMEBUFFERTEXTURE2D				(VPG_ES20 +	ES20_FRAMEBUFFERTEXTURE2D)
+#define	VPC_ES20FRONTFACE							(VPG_ES20 +	ES20_FRONTFACE)
+#define	VPC_ES20GENBUFFERS							(VPG_ES20 +	ES20_GENBUFFERS)
+#define	VPC_ES20GENERATEMIPMAP						(VPG_ES20 +	ES20_GENERATEMIPMAP)
+#define	VPC_ES20GENFRAMEBUFFERS						(VPG_ES20 +	ES20_GENFRAMEBUFFERS)
+#define	VPC_ES20GENRENDERBUFFERS					(VPG_ES20 +	ES20_GENRENDERBUFFERS)
+#define	VPC_ES20GENTEXTURES							(VPG_ES20 +	ES20_GENTEXTURES)
+#define	VPC_ES20GETACTIVEATTRIB						(VPG_ES20 +	ES20_GETACTIVEATTRIB)
+#define	VPC_ES20GETACTIVEUNIFORM					(VPG_ES20 +	ES20_GETACTIVEUNIFORM)
+#define	VPC_ES20GETATTACHEDSHADERS					(VPG_ES20 +	ES20_GETATTACHEDSHADERS)
+#define	VPC_ES20GETATTRIBLOCATION					(VPG_ES20 +	ES20_GETATTRIBLOCATION)
+#define	VPC_ES20GETBOOLEANV							(VPG_ES20 +	ES20_GETBOOLEANV)
+#define	VPC_ES20GETBUFFERPARAMETERIV				(VPG_ES20 +	ES20_GETBUFFERPARAMETERIV)
+#define	VPC_ES20GETERROR							(VPG_ES20 +	ES20_GETERROR)
+#define	VPC_ES20GETFLOATV							(VPG_ES20 +	ES20_GETFLOATV)
+#define	VPC_ES20GETFRAMEBUFFERATTACHMENTPARAMETERIV	(VPG_ES20 +	ES20_GETFRAMEBUFFERATTACHMENTPARAMETERIV)
+#define	VPC_ES20GETINTEGERV							(VPG_ES20 +	ES20_GETINTEGERV)
+#define	VPC_ES20GETPROGRAMIV						(VPG_ES20 +	ES20_GETPROGRAMIV)
+#define	VPC_ES20GETPROGRAMINFOLOG					(VPG_ES20 +	ES20_GETPROGRAMINFOLOG)
+#define	VPC_ES20GETRENDERBUFFERPARAMETERIV			(VPG_ES20 +	ES20_GETRENDERBUFFERPARAMETERIV)
+#define	VPC_ES20GETSHADERIV							(VPG_ES20 +	ES20_GETSHADERIV)
+#define	VPC_ES20GETSHADERINFOLOG					(VPG_ES20 +	ES20_GETSHADERINFOLOG)
+#define	VPC_ES20GETSHADERPRECISIONFORMAT			(VPG_ES20 +	ES20_GETSHADERPRECISIONFORMAT)
+#define	VPC_ES20GETSHADERSOURCE						(VPG_ES20 +	ES20_GETSHADERSOURCE)
+#define	VPC_ES20GETSTRING							(VPG_ES20 +	ES20_GETSTRING)
+#define	VPC_ES20GETTEXPARAMETERFV					(VPG_ES20 +	ES20_GETTEXPARAMETERFV)
+#define	VPC_ES20GETTEXPARAMETERIV					(VPG_ES20 +	ES20_GETTEXPARAMETERIV)
+#define	VPC_ES20GETUNIFORMFV						(VPG_ES20 +	ES20_GETUNIFORMFV)
+#define	VPC_ES20GETUNIFORMIV						(VPG_ES20 +	ES20_GETUNIFORMIV)
+#define	VPC_ES20GETUNIFORMLOCATION					(VPG_ES20 +	ES20_GETUNIFORMLOCATION)
+#define	VPC_ES20GETVERTEXATTRIBFV					(VPG_ES20 +	ES20_GETVERTEXATTRIBFV)
+#define	VPC_ES20GETVERTEXATTRIBIV					(VPG_ES20 +	ES20_GETVERTEXATTRIBIV)
+#define	VPC_ES20GETVERTEXATTRIBPOINTERV				(VPG_ES20 +	ES20_GETVERTEXATTRIBPOINTERV)
+#define	VPC_ES20HINT								(VPG_ES20 +	ES20_HINT)
+#define	VPC_ES20ISBUFFER							(VPG_ES20 +	ES20_ISBUFFER)
+#define	VPC_ES20ISENABLED							(VPG_ES20 +	ES20_ISENABLED)
+#define	VPC_ES20ISFRAMEBUFFER						(VPG_ES20 +	ES20_ISFRAMEBUFFER)
+#define	VPC_ES20ISPROGRAM							(VPG_ES20 +	ES20_ISPROGRAM)
+#define	VPC_ES20ISRENDERBUFFER						(VPG_ES20 +	ES20_ISRENDERBUFFER)
+#define	VPC_ES20ISSHADER							(VPG_ES20 +	ES20_ISSHADER)
+#define	VPC_ES20ISTEXTURE							(VPG_ES20 +	ES20_ISTEXTURE)
+#define	VPC_ES20LINEWIDTH							(VPG_ES20 +	ES20_LINEWIDTH)
+#define	VPC_ES20LINKPROGRAM							(VPG_ES20 +	ES20_LINKPROGRAM)
+#define	VPC_ES20PIXELSTOREI							(VPG_ES20 +	ES20_PIXELSTOREI)
+#define	VPC_ES20POLYGONOFFSET						(VPG_ES20 +	ES20_POLYGONOFFSET)
+#define	VPC_ES20READPIXELS							(VPG_ES20 +	ES20_READPIXELS)
+#define	VPC_ES20RELEASESHADERCOMPILER				(VPG_ES20 +	ES20_RELEASESHADERCOMPILER)
+#define	VPC_ES20RENDERBUFFERSTORAGE					(VPG_ES20 +	ES20_RENDERBUFFERSTORAGE)
+#define	VPC_ES20SAMPLECOVERAGE						(VPG_ES20 +	ES20_SAMPLECOVERAGE)
+#define	VPC_ES20SCISSOR								(VPG_ES20 +	ES20_SCISSOR)
+#define	VPC_ES20SHADERBINARY						(VPG_ES20 +	ES20_SHADERBINARY)
+#define	VPC_ES20SHADERSOURCE						(VPG_ES20 +	ES20_SHADERSOURCE)
+#define	VPC_ES20STENCILFUNC							(VPG_ES20 +	ES20_STENCILFUNC)
+#define	VPC_ES20STENCILFUNCSEPARATE					(VPG_ES20 +	ES20_STENCILFUNCSEPARATE)
+#define	VPC_ES20STENCILMASK							(VPG_ES20 +	ES20_STENCILMASK)
+#define	VPC_ES20STENCILMASKSEPARATE					(VPG_ES20 +	ES20_STENCILMASKSEPARATE)
+#define	VPC_ES20STENCILOP							(VPG_ES20 +	ES20_STENCILOP)
+#define	VPC_ES20STENCILOPSEPARATE					(VPG_ES20 +	ES20_STENCILOPSEPARATE)
+#define	VPC_ES20TEXIMAGE2D							(VPG_ES20 +	ES20_TEXIMAGE2D)
+#define	VPC_ES20TEXPARAMETERF						(VPG_ES20 +	ES20_TEXPARAMETERF)
+#define	VPC_ES20TEXPARAMETERFV						(VPG_ES20 +	ES20_TEXPARAMETERFV)
+#define	VPC_ES20TEXPARAMETERI						(VPG_ES20 +	ES20_TEXPARAMETERI)
+#define	VPC_ES20TEXPARAMETERIV						(VPG_ES20 +	ES20_TEXPARAMETERIV)
+#define	VPC_ES20TEXSUBIMAGE2D						(VPG_ES20 +	ES20_TEXSUBIMAGE2D)
+#define	VPC_ES20UNIFORM1F							(VPG_ES20 +	ES20_UNIFORM1F)
+#define	VPC_ES20UNIFORM1FV							(VPG_ES20 +	ES20_UNIFORM1FV)
+#define	VPC_ES20UNIFORM1I							(VPG_ES20 +	ES20_UNIFORM1I)
+#define	VPC_ES20UNIFORM1IV							(VPG_ES20 +	ES20_UNIFORM1IV)
+#define	VPC_ES20UNIFORM2F							(VPG_ES20 +	ES20_UNIFORM2F)
+#define	VPC_ES20UNIFORM2FV							(VPG_ES20 +	ES20_UNIFORM2FV)
+#define	VPC_ES20UNIFORM2I							(VPG_ES20 +	ES20_UNIFORM2I)
+#define	VPC_ES20UNIFORM2IV							(VPG_ES20 +	ES20_UNIFORM2IV)
+#define	VPC_ES20UNIFORM3F							(VPG_ES20 +	ES20_UNIFORM3F)
+#define	VPC_ES20UNIFORM3FV							(VPG_ES20 +	ES20_UNIFORM3FV)
+#define	VPC_ES20UNIFORM3I							(VPG_ES20 +	ES20_UNIFORM3I)
+#define	VPC_ES20UNIFORM3IV							(VPG_ES20 +	ES20_UNIFORM3IV)
+#define	VPC_ES20UNIFORM4F							(VPG_ES20 +	ES20_UNIFORM4F)
+#define	VPC_ES20UNIFORM4FV							(VPG_ES20 +	ES20_UNIFORM4FV)
+#define	VPC_ES20UNIFORM4I							(VPG_ES20 +	ES20_UNIFORM4I)
+#define	VPC_ES20UNIFORM4IV							(VPG_ES20 +	ES20_UNIFORM4IV)
+#define	VPC_ES20UNIFORMMATRIX2FV					(VPG_ES20 +	ES20_UNIFORMMATRIX2FV)
+#define	VPC_ES20UNIFORMMATRIX3FV					(VPG_ES20 +	ES20_UNIFORMMATRIX3FV)
+#define	VPC_ES20UNIFORMMATRIX4FV					(VPG_ES20 +	ES20_UNIFORMMATRIX4FV)
+#define	VPC_ES20USEPROGRAM							(VPG_ES20 +	ES20_USEPROGRAM)
+#define	VPC_ES20VALIDATEPROGRAM						(VPG_ES20 +	ES20_VALIDATEPROGRAM)
+#define	VPC_ES20VERTEXATTRIB1F						(VPG_ES20 +	ES20_VERTEXATTRIB1F)
+#define	VPC_ES20VERTEXATTRIB1FV						(VPG_ES20 +	ES20_VERTEXATTRIB1FV)
+#define	VPC_ES20VERTEXATTRIB2F						(VPG_ES20 +	ES20_VERTEXATTRIB2F)
+#define	VPC_ES20VERTEXATTRIB2FV						(VPG_ES20 +	ES20_VERTEXATTRIB2FV)
+#define	VPC_ES20VERTEXATTRIB3F						(VPG_ES20 +	ES20_VERTEXATTRIB3F)
+#define	VPC_ES20VERTEXATTRIB3FV						(VPG_ES20 +	ES20_VERTEXATTRIB3FV)
+#define	VPC_ES20VERTEXATTRIB4F						(VPG_ES20 +	ES20_VERTEXATTRIB4F)
+#define	VPC_ES20VERTEXATTRIB4FV						(VPG_ES20 +	ES20_VERTEXATTRIB4FV)
+#define	VPC_ES20VERTEXATTRIBPOINTER					(VPG_ES20 +	ES20_VERTEXATTRIBPOINTER)
+#define	VPC_ES20VIEWPORT							(VPG_ES20 +	ES20_VIEWPORT)
+/* OpenGL ES20 Statistics Counter IDs. */
+#define	VPC_ES20CALLS								(VPG_ES20 +	ES20_CALLS)
+#define	VPC_ES20DRAWCALLS							(VPG_ES20 +	ES20_DRAWCALLS)
+#define	VPC_ES20STATECHANGECALLS					(VPG_ES20 +	ES20_STATECHANGECALLS)
+#define	VPC_ES20POINTCOUNT							(VPG_ES20 +	ES20_POINTCOUNT)
+#define	VPC_ES20LINECOUNT							(VPG_ES20 +	ES20_LINECOUNT)
+#define	VPC_ES20TRIANGLECOUNT						(VPG_ES20 +	ES20_TRIANGLECOUNT)
+
+/* VG11 Counters. */
+#define	VPC_VG11APPENDPATH				(VPG_VG11 +	VG11_APPENDPATH)
+#define	VPC_VG11APPENDPATHDATA			(VPG_VG11 +	VG11_APPENDPATHDATA)
+#define	VPC_VG11CHILDIMAGE				(VPG_VG11 +	VG11_CHILDIMAGE)
+#define	VPC_VG11CLEAR					(VPG_VG11 +	VG11_CLEAR)
+#define	VPC_VG11CLEARGLYPH				(VPG_VG11 +	VG11_CLEARGLYPH)
+#define	VPC_VG11CLEARIMAGE				(VPG_VG11 +	VG11_CLEARIMAGE)
+#define	VPC_VG11CLEARPATH				(VPG_VG11 +	VG11_CLEARPATH)
+#define	VPC_VG11COLORMATRIX				(VPG_VG11 +	VG11_COLORMATRIX)
+#define	VPC_VG11CONVOLVE				(VPG_VG11 +	VG11_CONVOLVE)
+#define	VPC_VG11COPYIMAGE				(VPG_VG11 +	VG11_COPYIMAGE)
+#define	VPC_VG11COPYMASK				(VPG_VG11 +	VG11_COPYMASK)
+#define	VPC_VG11COPYPIXELS				(VPG_VG11 +	VG11_COPYPIXELS)
+#define	VPC_VG11CREATEFONT				(VPG_VG11 +	VG11_CREATEFONT)
+#define	VPC_VG11CREATEIMAGE				(VPG_VG11 +	VG11_CREATEIMAGE)
+#define	VPC_VG11CREATEMASKLAYER			(VPG_VG11 +	VG11_CREATEMASKLAYER)
+#define	VPC_VG11CREATEPAINT				(VPG_VG11 +	VG11_CREATEPAINT)
+#define	VPC_VG11CREATEPATH				(VPG_VG11 +	VG11_CREATEPATH)
+#define	VPC_VG11DESTROYFONT				(VPG_VG11 +	VG11_DESTROYFONT)
+#define	VPC_VG11DESTROYIMAGE			(VPG_VG11 +	VG11_DESTROYIMAGE)
+#define	VPC_VG11DESTROYMASKLAYER		(VPG_VG11 +	VG11_DESTROYMASKLAYER)
+#define	VPC_VG11DESTROYPAINT			(VPG_VG11 +	VG11_DESTROYPAINT)
+#define	VPC_VG11DESTROYPATH				(VPG_VG11 +	VG11_DESTROYPATH)
+#define	VPC_VG11DRAWGLYPH				(VPG_VG11 +	VG11_DRAWGLYPH)
+#define	VPC_VG11DRAWGLYPHS				(VPG_VG11 +	VG11_DRAWGLYPHS)
+#define	VPC_VG11DRAWIMAGE				(VPG_VG11 +	VG11_DRAWIMAGE)
+#define	VPC_VG11DRAWPATH				(VPG_VG11 +	VG11_DRAWPATH)
+#define	VPC_VG11FILLMASKLAYER			(VPG_VG11 +	VG11_FILLMASKLAYER)
+#define	VPC_VG11FINISH					(VPG_VG11 +	VG11_FINISH)
+#define	VPC_VG11FLUSH					(VPG_VG11 +	VG11_FLUSH)
+#define	VPC_VG11GAUSSIANBLUR			(VPG_VG11 +	VG11_GAUSSIANBLUR)
+#define	VPC_VG11GETCOLOR				(VPG_VG11 +	VG11_GETCOLOR)
+#define	VPC_VG11GETERROR				(VPG_VG11 +	VG11_GETERROR)
+#define	VPC_VG11GETF					(VPG_VG11 +	VG11_GETF)
+#define	VPC_VG11GETFV					(VPG_VG11 +	VG11_GETFV)
+#define	VPC_VG11GETI					(VPG_VG11 +	VG11_GETI)
+#define	VPC_VG11GETIMAGESUBDATA			(VPG_VG11 +	VG11_GETIMAGESUBDATA)
+#define	VPC_VG11GETIV					(VPG_VG11 +	VG11_GETIV)
+#define	VPC_VG11GETMATRIX				(VPG_VG11 +	VG11_GETMATRIX)
+#define	VPC_VG11GETPAINT				(VPG_VG11 +	VG11_GETPAINT)
+#define	VPC_VG11GETPARAMETERF			(VPG_VG11 +	VG11_GETPARAMETERF)
+#define	VPC_VG11GETPARAMETERFV			(VPG_VG11 +	VG11_GETPARAMETERFV)
+#define	VPC_VG11GETPARAMETERI			(VPG_VG11 +	VG11_GETPARAMETERI)
+#define	VPC_VG11GETPARAMETERIV			(VPG_VG11 +	VG11_GETPARAMETERIV)
+#define	VPC_VG11GETPARAMETERVECTORSIZE	(VPG_VG11 +	VG11_GETPARAMETERVECTORSIZE)
+#define	VPC_VG11GETPARENT				(VPG_VG11 +	VG11_GETPARENT)
+#define	VPC_VG11GETPATHCAPABILITIES		(VPG_VG11 +	VG11_GETPATHCAPABILITIES)
+#define	VPC_VG11GETPIXELS				(VPG_VG11 +	VG11_GETPIXELS)
+#define	VPC_VG11GETSTRING				(VPG_VG11 +	VG11_GETSTRING)
+#define	VPC_VG11GETVECTORSIZE			(VPG_VG11 +	VG11_GETVECTORSIZE)
+#define	VPC_VG11HARDWAREQUERY			(VPG_VG11 +	VG11_HARDWAREQUERY)
+#define	VPC_VG11IMAGESUBDATA			(VPG_VG11 +	VG11_IMAGESUBDATA)
+#define	VPC_VG11INTERPOLATEPATH			(VPG_VG11 +	VG11_INTERPOLATEPATH)
+#define	VPC_VG11LOADIDENTITY			(VPG_VG11 +	VG11_LOADIDENTITY)
+#define	VPC_VG11LOADMATRIX				(VPG_VG11 +	VG11_LOADMATRIX)
+#define	VPC_VG11LOOKUP					(VPG_VG11 +	VG11_LOOKUP)
+#define	VPC_VG11LOOKUPSINGLE			(VPG_VG11 +	VG11_LOOKUPSINGLE)
+#define	VPC_VG11MASK					(VPG_VG11 +	VG11_MASK)
+#define	VPC_VG11MODIFYPATHCOORDS		(VPG_VG11 +	VG11_MODIFYPATHCOORDS)
+#define	VPC_VG11MULTMATRIX				(VPG_VG11 +	VG11_MULTMATRIX)
+#define	VPC_VG11PAINTPATTERN			(VPG_VG11 +	VG11_PAINTPATTERN)
+#define	VPC_VG11PATHBOUNDS				(VPG_VG11 +	VG11_PATHBOUNDS)
+#define	VPC_VG11PATHLENGTH				(VPG_VG11 +	VG11_PATHLENGTH)
+#define	VPC_VG11PATHTRANSFORMEDBOUNDS	(VPG_VG11 +	VG11_PATHTRANSFORMEDBOUNDS)
+#define	VPC_VG11POINTALONGPATH			(VPG_VG11 +	VG11_POINTALONGPATH)
+#define	VPC_VG11READPIXELS				(VPG_VG11 +	VG11_READPIXELS)
+#define	VPC_VG11REMOVEPATHCAPABILITIES	(VPG_VG11 +	VG11_REMOVEPATHCAPABILITIES)
+#define	VPC_VG11RENDERTOMASK			(VPG_VG11 +	VG11_RENDERTOMASK)
+#define	VPC_VG11ROTATE					(VPG_VG11 +	VG11_ROTATE)
+#define	VPC_VG11SCALE					(VPG_VG11 +	VG11_SCALE)
+#define	VPC_VG11SEPARABLECONVOLVE		(VPG_VG11 +	VG11_SEPARABLECONVOLVE)
+#define	VPC_VG11SETCOLOR				(VPG_VG11 +	VG11_SETCOLOR)
+#define	VPC_VG11SETF					(VPG_VG11 +	VG11_SETF)
+#define	VPC_VG11SETFV					(VPG_VG11 +	VG11_SETFV)
+#define	VPC_VG11SETGLYPHTOIMAGE			(VPG_VG11 +	VG11_SETGLYPHTOIMAGE)
+#define	VPC_VG11SETGLYPHTOPATH			(VPG_VG11 +	VG11_SETGLYPHTOPATH)
+#define	VPC_VG11SETI					(VPG_VG11 +	VG11_SETI)
+#define	VPC_VG11SETIV					(VPG_VG11 +	VG11_SETIV)
+#define	VPC_VG11SETPAINT				(VPG_VG11 +	VG11_SETPAINT)
+#define	VPC_VG11SETPARAMETERF			(VPG_VG11 +	VG11_SETPARAMETERF)
+#define	VPC_VG11SETPARAMETERFV			(VPG_VG11 +	VG11_SETPARAMETERFV)
+#define	VPC_VG11SETPARAMETERI			(VPG_VG11 +	VG11_SETPARAMETERI)
+#define	VPC_VG11SETPARAMETERIV			(VPG_VG11 +	VG11_SETPARAMETERIV)
+#define	VPC_VG11SETPIXELS				(VPG_VG11 +	VG11_SETPIXELS)
+#define	VPC_VG11SHEAR					(VPG_VG11 +	VG11_SHEAR)
+#define	VPC_VG11TRANSFORMPATH			(VPG_VG11 +	VG11_TRANSFORMPATH)
+#define	VPC_VG11TRANSLATE				(VPG_VG11 +	VG11_TRANSLATE)
+#define	VPC_VG11WRITEPIXELS				(VPG_VG11 +	VG11_WRITEPIXELS)
+/* OpenVG Statistics Counter IDs. */
+#define	VPC_VG11CALLS					(VPG_VG11 +	VG11_CALLS)
+#define	VPC_VG11DRAWCALLS				(VPG_VG11 +	VG11_DRAWCALLS)
+#define	VPC_VG11STATECHANGECALLS		(VPG_VG11 +	VG11_STATECHANGECALLS)
+#define	VPC_VG11FILLCOUNT				(VPG_VG11 +	VG11_FILLCOUNT)
+#define	VPC_VG11STROKECOUNT				(VPG_VG11 +	VG11_STROKECOUNT)
+
+/* HAL Counters. */
+#define VPC_HALVERTBUFNEWBYTEALLOC      (VPG_HAL + HAL_VERTBUFNEWBYTEALLOC)
+#define VPC_HALVERTBUFTOTALBYTEALLOC    (VPG_HAL + HAL_VERTBUFTOTALBYTEALLOC)
+#define VPC_HALVERTBUFNEWOBJALLOC       (VPG_HAL + HAL_VERTBUFNEWOBJALLOC)
+#define VPC_HALVERTBUFTOTALOBJALLOC     (VPG_HAL + HAL_VERTBUFTOTALOBJALLOC)
+#define VPC_HALINDBUFNEWBYTEALLOC       (VPG_HAL + HAL_INDBUFNEWBYTEALLOC)
+#define VPC_HALINDBUFTOTALBYTEALLOC     (VPG_HAL + HAL_INDBUFTOTALBYTEALLOC)
+#define VPC_HALINDBUFNEWOBJALLOC        (VPG_HAL + HAL_INDBUFNEWOBJALLOC)
+#define VPC_HALINDBUFTOTALOBJALLOC      (VPG_HAL + HAL_INDBUFTOTALOBJALLOC)
+#define VPC_HALTEXBUFNEWBYTEALLOC       (VPG_HAL + HAL_TEXBUFNEWBYTEALLOC)
+#define VPC_HALTEXBUFTOTALBYTEALLOC     (VPG_HAL + HAL_TEXBUFTOTALBYTEALLOC)
+#define VPC_HALTEXBUFNEWOBJALLOC        (VPG_HAL + HAL_TEXBUFNEWOBJALLOC)
+#define VPC_HALTEXBUFTOTALOBJALLOC      (VPG_HAL + HAL_TEXBUFTOTALOBJALLOC)
+
+/* HW: GPU Counters. */
+#define VPC_GPUCYCLES                   (VPG_GPU + GPU_CYCLES)
+#define VPC_GPUREAD64BYTE               (VPG_GPU + GPU_READ64BYTE)
+#define VPC_GPUWRITE64BYTE              (VPG_GPU + GPU_WRITE64BYTE)
+
+/* HW: Shader Counters. */
+#define VPC_VSINSTCOUNT                 (VPG_VS + VS_INSTCOUNT)
+#define VPC_VSBRANCHINSTCOUNT           (VPG_VS + VS_BRANCHINSTCOUNT)
+#define VPC_VSTEXLDINSTCOUNT            (VPG_VS + VS_TEXLDINSTCOUNT)
+#define VPC_VSRENDEREDVERTCOUNT         (VPG_VS + VS_RENDEREDVERTCOUNT)
+/* HW: PS Count. */
+#define VPC_PSINSTCOUNT             	(VPG_PS + PS_INSTCOUNT)
+#define VPC_PSBRANCHINSTCOUNT       	(VPG_PS + PS_BRANCHINSTCOUNT)
+#define VPC_PSTEXLDINSTCOUNT        	(VPG_PS + PS_TEXLDINSTCOUNT)
+#define VPC_PSRENDEREDPIXCOUNT          (VPG_PS + PS_RENDEREDPIXCOUNT)
+
+
+/* HW: PA Counters. */
+#define VPC_PAINVERTCOUNT               (VPG_PA + PA_INVERTCOUNT)
+#define VPC_PAINPRIMCOUNT               (VPG_PA + PA_INPRIMCOUNT)
+#define VPC_PAOUTPRIMCOUNT              (VPG_PA + PA_OUTPRIMCOUNT)
+#define VPC_PADEPTHCLIPCOUNT            (VPG_PA + PA_DEPTHCLIPCOUNT)
+#define VPC_PATRIVIALREJCOUNT           (VPG_PA + PA_TRIVIALREJCOUNT)
+#define VPC_PACULLCOUNT                 (VPG_PA + PA_CULLCOUNT)
+
+/* HW: Setup Counters. */
+#define VPC_SETRIANGLECOUNT             (VPG_SETUP + SE_TRIANGLECOUNT)
+#define VPC_SELINECOUNT                 (VPG_SETUP + SE_LINECOUNT)
+
+/* HW: RA Counters. */
+#define VPC_RAVALIDPIXCOUNT             (VPG_RA + RA_VALIDPIXCOUNT)
+#define VPC_RATOTALQUADCOUNT            (VPG_RA + RA_TOTALQUADCOUNT)
+#define VPC_RAVALIDQUADCOUNTEZ          (VPG_RA + RA_VALIDQUADCOUNTEZ)
+#define VPC_RATOTALPRIMCOUNT            (VPG_RA + RA_TOTALPRIMCOUNT)
+#define VPC_RAPIPECACHEMISSCOUNT        (VPG_RA + RA_PIPECACHEMISSCOUNT)
+#define VPC_RAPREFCACHEMISSCOUNT        (VPG_RA + RA_PREFCACHEMISSCOUNT)
+#define VPC_RAEEZCULLCOUNT              (VPG_RA + RA_EEZCULLCOUNT)
+
+/* HW: TEX Counters. */
+#define VPC_TXTOTBILINEARREQ            (VPG_TX + TX_TOTBILINEARREQ)
+#define VPC_TXTOTTRILINEARREQ           (VPG_TX + TX_TOTTRILINEARREQ)
+#define VPC_TXTOTDISCARDTEXREQ          (VPG_TX + TX_TOTDISCARDTEXREQ)
+#define VPC_TXTOTTEXREQ                 (VPG_TX + TX_TOTTEXREQ)
+#define VPC_TXMEMREADCOUNT              (VPG_TX + TX_MEMREADCOUNT)
+#define VPC_TXMEMREADIN8BCOUNT          (VPG_TX + TX_MEMREADIN8BCOUNT)
+#define VPC_TXCACHEMISSCOUNT            (VPG_TX + TX_CACHEMISSCOUNT)
+#define VPC_TXCACHEHITTEXELCOUNT        (VPG_TX + TX_CACHEHITTEXELCOUNT)
+#define VPC_TXCACHEMISSTEXELCOUNT       (VPG_TX + TX_CACHEMISSTEXELCOUNT)
+
+/* HW: PE Counters. */
+#define VPC_PEKILLEDBYCOLOR             (VPG_PE + PE_KILLEDBYCOLOR)
+#define VPC_PEKILLEDBYDEPTH             (VPG_PE + PE_KILLEDBYDEPTH)
+#define VPC_PEDRAWNBYCOLOR              (VPG_PE + PE_DRAWNBYCOLOR)
+#define VPC_PEDRAWNBYDEPTH              (VPG_PE + PE_DRAWNBYDEPTH)
+
+/* HW: MC Counters. */
+#define VPC_MCREADREQ8BPIPE            	(VPG_MC + MC_READREQ8BPIPE)
+#define VPC_MCREADREQ8BIP               (VPG_MC + MC_READREQ8BIP)
+#define VPC_MCWRITEREQ8BPIPE            (VPG_MC + MC_WRITEREQ8BPIPE)
+
+/* HW: AXI Counters. */
+#define VPC_AXIREADREQSTALLED           (VPG_AXI + AXI_READREQSTALLED)
+#define VPC_AXIWRITEREQSTALLED          (VPG_AXI + AXI_WRITEREQSTALLED)
+#define VPC_AXIWRITEDATASTALLED         (VPG_AXI + AXI_WRITEDATASTALLED)
+
+/* PROGRAM: Shader program counters. */
+#define VPC_PVSINSTRCOUNT           (VPG_PVS + PVS_INSTRCOUNT)
+#define VPC_PVSALUINSTRCOUNT        (VPG_PVS + PVS_ALUINSTRCOUNT)
+#define VPC_PVSTEXINSTRCOUNT        (VPG_PVS + PVS_TEXINSTRCOUNT)
+#define VPC_PVSATTRIBCOUNT          (VPG_PVS + PVS_ATTRIBCOUNT)
+#define VPC_PVSUNIFORMCOUNT         (VPG_PVS + PVS_UNIFORMCOUNT)
+#define VPC_PVSFUNCTIONCOUNT        (VPG_PVS + PVS_FUNCTIONCOUNT)
+
+#define VPC_PPSINSTRCOUNT           (VPG_PPS + PPS_INSTRCOUNT)
+#define VPC_PPSALUINSTRCOUNT        (VPG_PPS + PPS_ALUINSTRCOUNT)
+#define VPC_PPSTEXINSTRCOUNT        (VPG_PPS + PPS_TEXINSTRCOUNT)
+#define VPC_PPSATTRIBCOUNT          (VPG_PPS + PPS_ATTRIBCOUNT)
+#define VPC_PPSUNIFORMCOUNT         (VPG_PPS + PPS_UNIFORMCOUNT)
+#define VPC_PPSFUNCTIONCOUNT        (VPG_PPS + PPS_FUNCTIONCOUNT)
+
+#endif
+
+
+/* HW profile information. */
+typedef struct _gcsPROFILER_COUNTERS
+{
+    /* HW static counters. */
+    gctUINT32       gpuClock;
+    gctUINT32       axiClock;
+    gctUINT32       shaderClock;
+
+    /* HW vairable counters. */
+    gctUINT32       gpuClockStart;
+    gctUINT32       gpuClockEnd;
+
+    /* HW vairable counters. */
+    gctUINT32       gpuCyclesCounter;
+    gctUINT32       gpuTotalRead64BytesPerFrame;
+    gctUINT32       gpuTotalWrite64BytesPerFrame;
+
+    /* PE */
+    gctUINT32       pe_pixel_count_killed_by_color_pipe;
+    gctUINT32       pe_pixel_count_killed_by_depth_pipe;
+    gctUINT32       pe_pixel_count_drawn_by_color_pipe;
+    gctUINT32       pe_pixel_count_drawn_by_depth_pipe;
+
+    /* SH */
+    gctUINT32       ps_inst_counter;
+    gctUINT32       rendered_pixel_counter;
+    gctUINT32       vs_inst_counter;
+    gctUINT32       rendered_vertice_counter;
+    gctUINT32       vtx_branch_inst_counter;
+    gctUINT32       vtx_texld_inst_counter;
+    gctUINT32       pxl_branch_inst_counter;
+    gctUINT32       pxl_texld_inst_counter;
+
+    /* PA */
+    gctUINT32       pa_input_vtx_counter;
+    gctUINT32       pa_input_prim_counter;
+    gctUINT32       pa_output_prim_counter;
+    gctUINT32       pa_depth_clipped_counter;
+    gctUINT32       pa_trivial_rejected_counter;
+    gctUINT32       pa_culled_counter;
+
+    /* SE */
+    gctUINT32       se_culled_triangle_count;
+    gctUINT32       se_culled_lines_count;
+
+    /* RA */
+    gctUINT32       ra_valid_pixel_count;
+    gctUINT32       ra_total_quad_count;
+    gctUINT32       ra_valid_quad_count_after_early_z;
+    gctUINT32       ra_total_primitive_count;
+    gctUINT32       ra_pipe_cache_miss_counter;
+    gctUINT32       ra_prefetch_cache_miss_counter;
+	gctUINT32       ra_eez_culled_counter;
+
+    /* TX */
+    gctUINT32       tx_total_bilinear_requests;
+    gctUINT32       tx_total_trilinear_requests;
+    gctUINT32       tx_total_discarded_texture_requests;
+    gctUINT32       tx_total_texture_requests;
+    gctUINT32       tx_mem_read_count;
+    gctUINT32       tx_mem_read_in_8B_count;
+    gctUINT32       tx_cache_miss_count;
+    gctUINT32       tx_cache_hit_texel_count;
+    gctUINT32       tx_cache_miss_texel_count;
+
+    /* MC */
+    gctUINT32       mc_total_read_req_8B_from_pipeline;
+    gctUINT32       mc_total_read_req_8B_from_IP;
+    gctUINT32       mc_total_write_req_8B_from_pipeline;
+
+    /* HI */
+    gctUINT32       hi_axi_cycles_read_request_stalled;
+    gctUINT32       hi_axi_cycles_write_request_stalled;
+    gctUINT32       hi_axi_cycles_write_data_stalled;
+}
+gcsPROFILER_COUNTERS;
+
+/* HAL profile information. */
+typedef struct _gcsPROFILER
+{
+    gctUINT32       enable;
+    gctBOOL         enableHal;
+    gctBOOL         enableHW;
+    gctBOOL         enableSH;
+
+    gctBOOL         useSocket;
+    gctINT          sockFd;
+
+    gctFILE         file;
+
+    /* Aggregate Information */
+
+    /* Clock Info */
+    gctUINT64       frameStart;
+    gctUINT64       frameEnd;
+
+    /* Current frame information */
+    gctUINT32       frameNumber;
+    gctUINT64       frameStartTimeusec;
+    gctUINT64       frameEndTimeusec;
+    gctUINT64       frameStartCPUTimeusec;
+    gctUINT64       frameEndCPUTimeusec;
+
+#if PROFILE_HAL_COUNTERS
+    gctUINT32       vertexBufferTotalBytesAlloc;
+    gctUINT32       vertexBufferNewBytesAlloc;
+    int             vertexBufferTotalObjectsAlloc;
+    int             vertexBufferNewObjectsAlloc;
+
+    gctUINT32       indexBufferTotalBytesAlloc;
+    gctUINT32       indexBufferNewBytesAlloc;
+    int             indexBufferTotalObjectsAlloc;
+    int             indexBufferNewObjectsAlloc;
+
+    gctUINT32       textureBufferTotalBytesAlloc;
+    gctUINT32       textureBufferNewBytesAlloc;
+    int             textureBufferTotalObjectsAlloc;
+    int             textureBufferNewObjectsAlloc;
+
+    gctUINT32       numCommits;
+    gctUINT32       drawPointCount;
+    gctUINT32       drawLineCount;
+    gctUINT32       drawTriangleCount;
+    gctUINT32       drawVertexCount;
+    gctUINT32       redundantStateChangeCalls;
+#endif
+
+	gctUINT32       prevVSInstCount;
+	gctUINT32       prevVSBranchInstCount;
+	gctUINT32       prevVSTexInstCount;
+	gctUINT32       prevVSVertexCount;
+	gctUINT32       prevPSInstCount;
+	gctUINT32       prevPSBranchInstCount;
+	gctUINT32       prevPSTexInstCount;
+	gctUINT32       prevPSPixelCount;
+
+}
+gcsPROFILER;
+
+/* Memory profile information. */
+struct _gcsMemProfile
+{
+    /* Memory Usage */
+    gctUINT32       videoMemUsed;
+    gctUINT32       systemMemUsed;
+    gctUINT32       commitBufferSize;
+    gctUINT32       contextBufferCopyBytes;
+};
+
+/* Shader profile information. */
+struct _gcsSHADER_PROFILER
+{
+    gctUINT32       shaderLength;
+    gctUINT32       shaderALUCycles;
+    gctUINT32       shaderTexLoadCycles;
+    gctUINT32       shaderTempRegCount;
+    gctUINT32       shaderSamplerRegCount;
+    gctUINT32       shaderInputRegCount;
+    gctUINT32       shaderOutputRegCount;
+};
+
+/* Initialize the gcsProfiler. */
+gceSTATUS
+gcoPROFILER_Initialize(
+    IN gcoHAL Hal
+    );
+
+/* Destroy the gcProfiler. */
+gceSTATUS
+gcoPROFILER_Destroy(
+    IN gcoHAL Hal
+    );
+
+/* Write data to profiler. */
+gceSTATUS
+gcoPROFILER_Write(
+    IN gcoHAL Hal,
+    IN gctSIZE_T ByteCount,
+    IN gctCONST_POINTER Data
+    );
+
+/* Flush data out. */
+gceSTATUS
+gcoPROFILER_Flush(
+    IN gcoHAL Hal
+    );
+
+/* Call to signal end of frame. */
+gceSTATUS
+gcoPROFILER_EndFrame(
+    IN gcoHAL Hal
+    );
+
+/* Increase profile counter Enum by Value. */
+gceSTATUS
+gcoPROFILER_Count(
+	IN gcoHAL Hal,
+	IN gctUINT32 Enum,
+	IN gctINT Value
+	);
+
+/* Profile input vertex shader. */
+gceSTATUS
+gcoPROFILER_ShaderVS(
+    IN gcoHAL Hal,
+    IN gctPOINTER Vs
+    );
+
+/* Profile input fragment shader. */
+gceSTATUS
+gcoPROFILER_ShaderFS(
+    IN gcoHAL Hal,
+    IN gctPOINTER Fs
+    );
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __gc_hal_profiler_h_ */
diff --git a/attic/gc_hal_raster.h b/attic/gc_hal_raster.h
new file mode 100644
index 0000000..c303462
--- /dev/null
+++ b/attic/gc_hal_raster.h
@@ -0,0 +1,933 @@
+/****************************************************************************
+*
+*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*
+*    This program is free software; you can redistribute it and/or modify
+*    it under the terms of the GNU General Public License as published by
+*    the Free Software Foundation; either version 2 of the license, or
+*    (at your option) any later version.
+*
+*    This program is distributed in the hope that it will be useful,
+*    but WITHOUT ANY WARRANTY; without even the implied warranty of
+*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+*    GNU General Public License for more details.
+*
+*    You should have received a copy of the GNU General Public License
+*    along with this program; if not write to the Free Software
+*    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*
+*****************************************************************************/
+
+
+
+
+#ifndef __gc_hal_raster_h_
+#define __gc_hal_raster_h_
+
+#include "gc_hal_enum.h"
+#include "gc_hal_types.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/******************************************************************************\
+****************************** Object Declarations *****************************
+\******************************************************************************/
+
+typedef struct _gcoBRUSH *				gcoBRUSH;
+typedef struct _gcoBRUSH_CACHE *  		gcoBRUSH_CACHE;
+
+/******************************************************************************\
+******************************** gcoBRUSH Object *******************************
+\******************************************************************************/
+
+/* Create a new solid color gcoBRUSH object. */
+gceSTATUS
+gcoBRUSH_ConstructSingleColor(
+	IN gcoHAL Hal,
+	IN gctUINT32 ColorConvert,
+	IN gctUINT32 Color,
+	IN gctUINT64 Mask,
+	gcoBRUSH * Brush
+	);
+
+/* Create a new monochrome gcoBRUSH object. */
+gceSTATUS
+gcoBRUSH_ConstructMonochrome(
+	IN gcoHAL Hal,
+	IN gctUINT32 OriginX,
+	IN gctUINT32 OriginY,
+	IN gctUINT32 ColorConvert,
+	IN gctUINT32 FgColor,
+	IN gctUINT32 BgColor,
+	IN gctUINT64 Bits,
+	IN gctUINT64 Mask,
+	gcoBRUSH * Brush
+	);
+
+/* Create a color gcoBRUSH object. */
+gceSTATUS
+gcoBRUSH_ConstructColor(
+	IN gcoHAL Hal,
+	IN gctUINT32 OriginX,
+	IN gctUINT32 OriginY,
+	IN gctPOINTER Address,
+	IN gceSURF_FORMAT Format,
+	IN gctUINT64 Mask,
+	gcoBRUSH * Brush
+	);
+
+/* Destroy an gcoBRUSH object. */
+gceSTATUS
+gcoBRUSH_Destroy(
+	IN gcoBRUSH Brush
+	);
+
+/******************************************************************************\
+******************************** gcoSURF Object *******************************
+\******************************************************************************/
+
+/* Set cipping rectangle. */
+gceSTATUS
+gcoSURF_SetClipping(
+	IN gcoSURF Surface
+	);
+
+/* Clear one or more rectangular areas. */
+gceSTATUS
+gcoSURF_Clear2D(
+	IN gcoSURF DestSurface,
+	IN gctUINT32 RectCount,
+	IN gcsRECT_PTR DestRect,
+	IN gctUINT32 LoColor,
+	IN gctUINT32 HiColor
+	);
+
+/* Draw one or more Bresenham lines. */
+gceSTATUS
+gcoSURF_Line(
+	IN gcoSURF Surface,
+	IN gctUINT32 LineCount,
+	IN gcsRECT_PTR Position,
+	IN gcoBRUSH Brush,
+	IN gctUINT8 FgRop,
+	IN gctUINT8 BgRop
+	);
+
+/* Generic rectangular blit. */
+gceSTATUS
+gcoSURF_Blit(
+	IN OPTIONAL gcoSURF SrcSurface,
+	IN gcoSURF DestSurface,
+	IN gctUINT32 RectCount,
+	IN OPTIONAL gcsRECT_PTR SrcRect,
+	IN gcsRECT_PTR DestRect,
+	IN OPTIONAL gcoBRUSH Brush,
+	IN gctUINT8 FgRop,
+	IN gctUINT8 BgRop,
+	IN OPTIONAL gceSURF_TRANSPARENCY Transparency,
+	IN OPTIONAL gctUINT32 TransparencyColor,
+	IN OPTIONAL gctPOINTER Mask,
+	IN OPTIONAL gceSURF_MONOPACK MaskPack
+	);
+
+/* Monochrome blit. */
+gceSTATUS
+gcoSURF_MonoBlit(
+	IN gcoSURF DestSurface,
+	IN gctPOINTER Source,
+	IN gceSURF_MONOPACK SourcePack,
+	IN gcsPOINT_PTR SourceSize,
+	IN gcsPOINT_PTR SourceOrigin,
+	IN gcsRECT_PTR DestRect,
+	IN OPTIONAL gcoBRUSH Brush,
+	IN gctUINT8 FgRop,
+	IN gctUINT8 BgRop,
+	IN gctBOOL ColorConvert,
+	IN gctUINT8 MonoTransparency,
+	IN gceSURF_TRANSPARENCY Transparency,
+	IN gctUINT32 FgColor,
+	IN gctUINT32 BgColor
+	);
+
+/* Filter blit. */
+gceSTATUS
+gcoSURF_FilterBlit(
+	IN gcoSURF SrcSurface,
+	IN gcoSURF DestSurface,
+	IN gcsRECT_PTR SrcRect,
+	IN gcsRECT_PTR DestRect,
+	IN gcsRECT_PTR DestSubRect
+	);
+
+/* Enable alpha blending engine in the hardware and disengage the ROP engine. */
+gceSTATUS
+gcoSURF_EnableAlphaBlend(
+	IN gcoSURF Surface,
+	IN gctUINT8 SrcGlobalAlphaValue,
+	IN gctUINT8 DstGlobalAlphaValue,
+	IN gceSURF_PIXEL_ALPHA_MODE SrcAlphaMode,
+	IN gceSURF_PIXEL_ALPHA_MODE DstAlphaMode,
+	IN gceSURF_GLOBAL_ALPHA_MODE SrcGlobalAlphaMode,
+	IN gceSURF_GLOBAL_ALPHA_MODE DstGlobalAlphaMode,
+	IN gceSURF_BLEND_FACTOR_MODE SrcFactorMode,
+	IN gceSURF_BLEND_FACTOR_MODE DstFactorMode,
+	IN gceSURF_PIXEL_COLOR_MODE SrcColorMode,
+	IN gceSURF_PIXEL_COLOR_MODE DstColorMode
+	);
+
+/* Disable alpha blending engine in the hardware and engage the ROP engine. */
+gceSTATUS
+gcoSURF_DisableAlphaBlend(
+	IN gcoSURF Surface
+	);
+
+/* Copy a rectangular area with format conversion. */
+gceSTATUS
+gcoSURF_CopyPixels(
+	IN gcoSURF Source,
+	IN gcoSURF Target,
+	IN gctINT SourceX,
+	IN gctINT SourceY,
+	IN gctINT TargetX,
+	IN gctINT TargetY,
+	IN gctINT Width,
+	IN gctINT Height
+	);
+
+/* Read surface pixel. */
+gceSTATUS
+gcoSURF_ReadPixel(
+	IN gcoSURF Surface,
+	IN gctPOINTER Memory,
+	IN gctINT X,
+	IN gctINT Y,
+	IN gceSURF_FORMAT Format,
+	OUT gctPOINTER PixelValue
+	);
+
+/* Write surface pixel. */
+gceSTATUS
+gcoSURF_WritePixel(
+	IN gcoSURF Surface,
+	IN gctPOINTER Memory,
+	IN gctINT X,
+	IN gctINT Y,
+	IN gceSURF_FORMAT Format,
+	IN gctPOINTER PixelValue
+	);
+
+gceSTATUS
+gcoSURF_SetDither(
+    IN gcoSURF Surface,
+    IN gctBOOL Dither
+    );
+/******************************************************************************\
+********************************** gco2D Object *********************************
+\******************************************************************************/
+
+/* Construct a new gco2D object. */
+gceSTATUS
+gco2D_Construct(
+	IN gcoHAL Hal,
+	OUT gco2D * Hardware
+	);
+
+/* Destroy an gco2D object. */
+gceSTATUS
+gco2D_Destroy(
+	IN gco2D Hardware
+	);
+
+/* Sets the maximum number of brushes in the brush cache. */
+gceSTATUS
+gco2D_SetBrushLimit(
+	IN gco2D Hardware,
+	IN gctUINT MaxCount
+	);
+
+/* Flush the brush. */
+gceSTATUS
+gco2D_FlushBrush(
+	IN gco2D Engine,
+	IN gcoBRUSH Brush,
+	IN gceSURF_FORMAT Format
+	);
+
+/* Program the specified solid color brush. */
+gceSTATUS
+gco2D_LoadSolidBrush(
+	IN gco2D Engine,
+	IN gceSURF_FORMAT Format,
+	IN gctUINT32 ColorConvert,
+	IN gctUINT32 Color,
+	IN gctUINT64 Mask
+	);
+
+gceSTATUS
+gco2D_LoadMonochromeBrush(
+    IN gco2D Engine,
+    IN gctUINT32 OriginX,
+    IN gctUINT32 OriginY,
+    IN gctUINT32 ColorConvert,
+    IN gctUINT32 FgColor,
+    IN gctUINT32 BgColor,
+    IN gctUINT64 Bits,
+    IN gctUINT64 Mask
+    );
+
+gceSTATUS
+gco2D_LoadColorBrush(
+    IN gco2D Engine,
+    IN gctUINT32 OriginX,
+    IN gctUINT32 OriginY,
+    IN gctUINT32 Address,
+    IN gceSURF_FORMAT Format,
+    IN gctUINT64 Mask
+    );
+
+/* Configure monochrome source. */
+gceSTATUS
+gco2D_SetMonochromeSource(
+	IN gco2D Engine,
+	IN gctBOOL ColorConvert,
+	IN gctUINT8 MonoTransparency,
+	IN gceSURF_MONOPACK DataPack,
+	IN gctBOOL CoordRelative,
+	IN gceSURF_TRANSPARENCY Transparency,
+	IN gctUINT32 FgColor,
+	IN gctUINT32 BgColor
+	);
+
+/* Configure color source. */
+gceSTATUS
+gco2D_SetColorSource(
+	IN gco2D Engine,
+	IN gctUINT32 Address,
+	IN gctUINT32 Stride,
+	IN gceSURF_FORMAT Format,
+	IN gceSURF_ROTATION Rotation,
+	IN gctUINT32 SurfaceWidth,
+	IN gctBOOL CoordRelative,
+	IN gceSURF_TRANSPARENCY Transparency,
+	IN gctUINT32 TransparencyColor
+	);
+
+/* Configure color source extension for full rotation. */
+gceSTATUS
+gco2D_SetColorSourceEx(
+	IN gco2D Engine,
+	IN gctUINT32 Address,
+	IN gctUINT32 Stride,
+	IN gceSURF_FORMAT Format,
+	IN gceSURF_ROTATION Rotation,
+	IN gctUINT32 SurfaceWidth,
+	IN gctUINT32 SurfaceHeight,
+	IN gctBOOL CoordRelative,
+	IN gceSURF_TRANSPARENCY Transparency,
+	IN gctUINT32 TransparencyColor
+	);
+
+/* Configure color source. */
+gceSTATUS
+gco2D_SetColorSourceAdvanced(
+	IN gco2D Engine,
+	IN gctUINT32 Address,
+	IN gctUINT32 Stride,
+	IN gceSURF_FORMAT Format,
+	IN gceSURF_ROTATION Rotation,
+	IN gctUINT32 SurfaceWidth,
+	IN gctUINT32 SurfaceHeight,
+	IN gctBOOL CoordRelative
+	);
+
+gceSTATUS
+gco2D_SetColorSourceN(
+    IN gco2D Engine,
+    IN gctUINT32 Address,
+    IN gctUINT32 Stride,
+    IN gceSURF_FORMAT Format,
+    IN gceSURF_ROTATION Rotation,
+    IN gctUINT32 SurfaceWidth,
+    IN gctUINT32 SurfaceHeight,
+    IN gctUINT32 SurfaceNumber
+    );
+
+/* Configure masked color source. */
+gceSTATUS
+gco2D_SetMaskedSource(
+	IN gco2D Engine,
+	IN gctUINT32 Address,
+	IN gctUINT32 Stride,
+	IN gceSURF_FORMAT Format,
+	IN gctBOOL CoordRelative,
+	IN gceSURF_MONOPACK MaskPack
+	);
+
+/* Configure masked color source extension for full rotation. */
+gceSTATUS
+gco2D_SetMaskedSourceEx(
+	IN gco2D Engine,
+	IN gctUINT32 Address,
+	IN gctUINT32 Stride,
+	IN gceSURF_FORMAT Format,
+	IN gctBOOL CoordRelative,
+	IN gceSURF_MONOPACK MaskPack,
+	IN gceSURF_ROTATION Rotation,
+	IN gctUINT32 SurfaceWidth,
+	IN gctUINT32 SurfaceHeight
+	);
+
+/* Setup the source rectangle. */
+gceSTATUS
+gco2D_SetSource(
+	IN gco2D Engine,
+	IN gcsRECT_PTR SrcRect
+	);
+
+/* Set clipping rectangle. */
+gceSTATUS
+gco2D_SetClipping(
+	IN gco2D Engine,
+	IN gcsRECT_PTR Rect
+	);
+
+/* Configure destination. */
+gceSTATUS
+gco2D_SetTarget(
+	IN gco2D Engine,
+	IN gctUINT32 Address,
+	IN gctUINT32 Stride,
+	IN gceSURF_ROTATION Rotation,
+	IN gctUINT32 SurfaceWidth
+	);
+
+/* Configure destination extension for full rotation. */
+gceSTATUS
+gco2D_SetTargetEx(
+	IN gco2D Engine,
+	IN gctUINT32 Address,
+	IN gctUINT32 Stride,
+	IN gceSURF_ROTATION Rotation,
+	IN gctUINT32 SurfaceWidth,
+	IN gctUINT32 SurfaceHeight
+	);
+
+/* Calculate and program the stretch factors. */
+gceSTATUS
+gco2D_SetStretchFactors(
+	IN gco2D Engine,
+	IN gctUINT32 HorFactor,
+	IN gctUINT32 VerFactor
+	);
+
+/* Calculate and program the stretch factors based on the rectangles. */
+gceSTATUS
+gco2D_SetStretchRectFactors(
+	IN gco2D Engine,
+	IN gcsRECT_PTR SrcRect,
+	IN gcsRECT_PTR DestRect
+	);
+
+/* Create a new solid color gcoBRUSH object. */
+gceSTATUS
+gco2D_ConstructSingleColorBrush(
+	IN gco2D Engine,
+	IN gctUINT32 ColorConvert,
+	IN gctUINT32 Color,
+	IN gctUINT64 Mask,
+	gcoBRUSH * Brush
+	);
+
+/* Create a new monochrome gcoBRUSH object. */
+gceSTATUS
+gco2D_ConstructMonochromeBrush(
+	IN gco2D Engine,
+	IN gctUINT32 OriginX,
+	IN gctUINT32 OriginY,
+	IN gctUINT32 ColorConvert,
+	IN gctUINT32 FgColor,
+	IN gctUINT32 BgColor,
+	IN gctUINT64 Bits,
+	IN gctUINT64 Mask,
+	gcoBRUSH * Brush
+	);
+
+/* Create a color gcoBRUSH object. */
+gceSTATUS
+gco2D_ConstructColorBrush(
+	IN gco2D Engine,
+	IN gctUINT32 OriginX,
+	IN gctUINT32 OriginY,
+	IN gctPOINTER Address,
+	IN gceSURF_FORMAT Format,
+	IN gctUINT64 Mask,
+	gcoBRUSH * Brush
+	);
+
+/* Clear one or more rectangular areas. */
+gceSTATUS
+gco2D_Clear(
+	IN gco2D Engine,
+	IN gctUINT32 RectCount,
+	IN gcsRECT_PTR Rect,
+	IN gctUINT32 Color32,
+	IN gctUINT8 FgRop,
+	IN gctUINT8 BgRop,
+	IN gceSURF_FORMAT DestFormat
+	);
+
+/* Draw one or more Bresenham lines. */
+gceSTATUS
+gco2D_Line(
+	IN gco2D Engine,
+	IN gctUINT32 LineCount,
+	IN gcsRECT_PTR Position,
+	IN gcoBRUSH Brush,
+	IN gctUINT8 FgRop,
+	IN gctUINT8 BgRop,
+	IN gceSURF_FORMAT DestFormat
+	);
+
+/* Draw one or more Bresenham lines based on the 32-bit color. */
+gceSTATUS
+gco2D_ColorLine(
+	IN gco2D Engine,
+	IN gctUINT32 LineCount,
+	IN gcsRECT_PTR Position,
+	IN gctUINT32 Color32,
+	IN gctUINT8 FgRop,
+	IN gctUINT8 BgRop,
+	IN gceSURF_FORMAT DestFormat
+	);
+
+/* Generic blit. */
+gceSTATUS
+gco2D_Blit(
+	IN gco2D Engine,
+	IN gctUINT32 RectCount,
+	IN gcsRECT_PTR Rect,
+	IN gctUINT8 FgRop,
+	IN gctUINT8 BgRop,
+	IN gceSURF_FORMAT DestFormat
+	);
+
+gceSTATUS
+gco2D_Blend(
+    IN gco2D Engine,
+    IN gctUINT32 SrcCount,
+    IN gctUINT32 RectCount,
+    IN gcsRECT_PTR Rect,
+    IN gctUINT8 FgRop,
+    IN gctUINT8 BgRop,
+    IN gceSURF_FORMAT DestFormat
+    );
+
+/* Batch blit. */
+gceSTATUS
+gco2D_BatchBlit(
+	IN gco2D Engine,
+	IN gctUINT32 RectCount,
+	IN gcsRECT_PTR SrcRect,
+	IN gcsRECT_PTR DestRect,
+	IN gctUINT8 FgRop,
+	IN gctUINT8 BgRop,
+	IN gceSURF_FORMAT DestFormat
+	);
+
+/* Stretch blit. */
+gceSTATUS
+gco2D_StretchBlit(
+	IN gco2D Engine,
+	IN gctUINT32 RectCount,
+	IN gcsRECT_PTR Rect,
+	IN gctUINT8 FgRop,
+	IN gctUINT8 BgRop,
+	IN gceSURF_FORMAT DestFormat
+	);
+
+/* Monochrome blit. */
+gceSTATUS
+gco2D_MonoBlit(
+	IN gco2D Engine,
+	IN gctPOINTER StreamBits,
+	IN gcsPOINT_PTR StreamSize,
+	IN gcsRECT_PTR StreamRect,
+	IN gceSURF_MONOPACK SrcStreamPack,
+	IN gceSURF_MONOPACK DestStreamPack,
+	IN gcsRECT_PTR DestRect,
+	IN gctUINT32 FgRop,
+	IN gctUINT32 BgRop,
+	IN gceSURF_FORMAT DestFormat
+	);
+
+/* Set kernel size. */
+gceSTATUS
+gco2D_SetKernelSize(
+	IN gco2D Engine,
+	IN gctUINT8 HorKernelSize,
+	IN gctUINT8 VerKernelSize
+	);
+
+/* Set filter type. */
+gceSTATUS
+gco2D_SetFilterType(
+	IN gco2D Engine,
+	IN gceFILTER_TYPE FilterType
+	);
+
+/* Set the filter kernel by user. */
+gceSTATUS
+gco2D_SetUserFilterKernel(
+	IN gco2D Engine,
+	IN gceFILTER_PASS_TYPE PassType,
+	IN gctUINT16_PTR KernelArray
+	);
+
+/* Select the pass(es) to be done for user defined filter. */
+gceSTATUS
+gco2D_EnableUserFilterPasses(
+	IN gco2D Engine,
+	IN gctBOOL HorPass,
+	IN gctBOOL VerPass
+	);
+
+/* Frees the temporary buffer allocated by filter blit operation. */
+gceSTATUS
+gco2D_FreeFilterBuffer(
+	IN gco2D Engine
+	);
+
+/* Filter blit. */
+gceSTATUS
+gco2D_FilterBlit(
+	IN gco2D Engine,
+	IN gctUINT32 SrcAddress,
+	IN gctUINT SrcStride,
+	IN gctUINT32 SrcUAddress,
+	IN gctUINT SrcUStride,
+	IN gctUINT32 SrcVAddress,
+	IN gctUINT SrcVStride,
+	IN gceSURF_FORMAT SrcFormat,
+	IN gceSURF_ROTATION SrcRotation,
+	IN gctUINT32 SrcSurfaceWidth,
+	IN gcsRECT_PTR SrcRect,
+	IN gctUINT32 DestAddress,
+	IN gctUINT DestStride,
+	IN gceSURF_FORMAT DestFormat,
+	IN gceSURF_ROTATION DestRotation,
+	IN gctUINT32 DestSurfaceWidth,
+	IN gcsRECT_PTR DestRect,
+	IN gcsRECT_PTR DestSubRect
+	);
+
+/* Filter blit extension for full rotation. */
+gceSTATUS
+gco2D_FilterBlitEx(
+	IN gco2D Engine,
+	IN gctUINT32 SrcAddress,
+	IN gctUINT SrcStride,
+	IN gctUINT32 SrcUAddress,
+	IN gctUINT SrcUStride,
+	IN gctUINT32 SrcVAddress,
+	IN gctUINT SrcVStride,
+	IN gceSURF_FORMAT SrcFormat,
+	IN gceSURF_ROTATION SrcRotation,
+	IN gctUINT32 SrcSurfaceWidth,
+	IN gctUINT32 SrcSurfaceHeight,
+	IN gcsRECT_PTR SrcRect,
+	IN gctUINT32 DestAddress,
+	IN gctUINT DestStride,
+	IN gceSURF_FORMAT DestFormat,
+	IN gceSURF_ROTATION DestRotation,
+	IN gctUINT32 DestSurfaceWidth,
+	IN gctUINT32 DestSurfaceHeight,
+	IN gcsRECT_PTR DestRect,
+	IN gcsRECT_PTR DestSubRect
+	);
+
+gceSTATUS
+gco2D_FilterBlitEx2(
+    IN gco2D                Engine,
+    IN gctUINT32_PTR        SrcAddresses,
+    IN gctUINT32            SrcAddressNum,
+    IN gctUINT32_PTR        SrcStrides,
+    IN gctUINT32            SrcStrideNum,
+    IN gceTILING            SrcTiling,
+    IN gceSURF_FORMAT       SrcFormat,
+    IN gceSURF_ROTATION     SrcRotation,
+    IN gctUINT32            SrcSurfaceWidth,
+    IN gctUINT32            SrcSurfaceHeight,
+    IN gcsRECT_PTR          SrcRect,
+    IN gctUINT32_PTR        DestAddresses,
+    IN gctUINT32            DestAddressNum,
+    IN gctUINT32_PTR        DestStrides,
+    IN gctUINT32            DestStrideNum,
+    IN gceTILING            DestTiling,
+    IN gceSURF_FORMAT       DestFormat,
+    IN gceSURF_ROTATION     DestRotation,
+    IN gctUINT32            DestSurfaceWidth,
+    IN gctUINT32            DestSurfaceHeight,
+    IN gcsRECT_PTR          DestRect,
+    IN gcsRECT_PTR          DestSubRect
+    );
+
+/* Enable alpha blending engine in the hardware and disengage the ROP engine. */
+gceSTATUS
+gco2D_EnableAlphaBlend(
+	IN gco2D Engine,
+	IN gctUINT8 SrcGlobalAlphaValue,
+	IN gctUINT8 DstGlobalAlphaValue,
+	IN gceSURF_PIXEL_ALPHA_MODE SrcAlphaMode,
+	IN gceSURF_PIXEL_ALPHA_MODE DstAlphaMode,
+	IN gceSURF_GLOBAL_ALPHA_MODE SrcGlobalAlphaMode,
+	IN gceSURF_GLOBAL_ALPHA_MODE DstGlobalAlphaMode,
+	IN gceSURF_BLEND_FACTOR_MODE SrcFactorMode,
+	IN gceSURF_BLEND_FACTOR_MODE DstFactorMode,
+	IN gceSURF_PIXEL_COLOR_MODE SrcColorMode,
+	IN gceSURF_PIXEL_COLOR_MODE DstColorMode
+	);
+
+/* Enable alpha blending engine in the hardware. */
+gceSTATUS
+gco2D_EnableAlphaBlendAdvanced(
+	IN gco2D Engine,
+	IN gceSURF_PIXEL_ALPHA_MODE SrcAlphaMode,
+	IN gceSURF_PIXEL_ALPHA_MODE DstAlphaMode,
+	IN gceSURF_GLOBAL_ALPHA_MODE SrcGlobalAlphaMode,
+	IN gceSURF_GLOBAL_ALPHA_MODE DstGlobalAlphaMode,
+	IN gceSURF_BLEND_FACTOR_MODE SrcFactorMode,
+	IN gceSURF_BLEND_FACTOR_MODE DstFactorMode
+	);
+
+/* Enable alpha blending engine with Porter Duff rule. */
+gceSTATUS
+gco2D_SetPorterDuffBlending(
+	IN gco2D Engine,
+	IN gce2D_PORTER_DUFF_RULE Rule
+	);
+
+/* Disable alpha blending engine in the hardware and engage the ROP engine. */
+gceSTATUS
+gco2D_DisableAlphaBlend(
+	IN gco2D Engine
+	);
+
+/* Retrieve the maximum number of 32-bit data chunks for a single DE command. */
+gctUINT32
+gco2D_GetMaximumDataCount(
+	void
+	);
+
+/* Retrieve the maximum number of rectangles, that can be passed in a single DE command. */
+gctUINT32
+gco2D_GetMaximumRectCount(
+	void
+	);
+
+/* Returns the pixel alignment of the surface. */
+gceSTATUS
+gco2D_GetPixelAlignment(
+	gceSURF_FORMAT Format,
+	gcsPOINT_PTR Alignment
+	);
+
+/* Retrieve monochrome stream pack size. */
+gceSTATUS
+gco2D_GetPackSize(
+	IN gceSURF_MONOPACK StreamPack,
+	OUT gctUINT32 * PackWidth,
+	OUT gctUINT32 * PackHeight
+	);
+
+/* Flush the 2D pipeline. */
+gceSTATUS
+gco2D_Flush(
+	IN gco2D Engine
+	);
+
+/* Load 256-entry color table for INDEX8 source surfaces. */
+gceSTATUS
+gco2D_LoadPalette(
+	IN gco2D Engine,
+	IN gctUINT FirstIndex,
+	IN gctUINT IndexCount,
+	IN gctPOINTER ColorTable,
+	IN gctBOOL ColorConvert
+	);
+
+/* Enable/disable 2D BitBlt mirrorring. */
+gceSTATUS
+gco2D_SetBitBlitMirror(
+	IN gco2D Engine,
+	IN gctBOOL HorizontalMirror,
+	IN gctBOOL VerticalMirror
+	);
+
+/*
+ * Set the transparency for source, destination and pattern.
+ * It also enable or disable the DFB color key mode.
+ */
+gceSTATUS
+gco2D_SetTransparencyAdvancedEx(
+    IN gco2D Engine,
+    IN gce2D_TRANSPARENCY SrcTransparency,
+    IN gce2D_TRANSPARENCY DstTransparency,
+    IN gce2D_TRANSPARENCY PatTransparency,
+    IN gctBOOL EnableDFBColorKeyMode
+	);
+
+/* Set the transparency for source, destination and pattern. */
+gceSTATUS
+gco2D_SetTransparencyAdvanced(
+	IN gco2D Engine,
+	IN gce2D_TRANSPARENCY SrcTransparency,
+	IN gce2D_TRANSPARENCY DstTransparency,
+	IN gce2D_TRANSPARENCY PatTransparency
+	);
+
+/* Set the source color key. */
+gceSTATUS
+gco2D_SetSourceColorKeyAdvanced(
+	IN gco2D Engine,
+	IN gctUINT32 ColorKey
+	);
+
+/* Set the source color key range. */
+gceSTATUS
+gco2D_SetSourceColorKeyRangeAdvanced(
+	IN gco2D Engine,
+	IN gctUINT32 ColorKeyLow,
+	IN gctUINT32 ColorKeyHigh
+	);
+
+/* Set the target color key. */
+gceSTATUS
+gco2D_SetTargetColorKeyAdvanced(
+	IN gco2D Engine,
+	IN gctUINT32 ColorKey
+	);
+
+/* Set the target color key range. */
+gceSTATUS
+gco2D_SetTargetColorKeyRangeAdvanced(
+	IN gco2D Engine,
+	IN gctUINT32 ColorKeyLow,
+	IN gctUINT32 ColorKeyHigh
+	);
+
+/* Set the YUV color space mode. */
+gceSTATUS
+gco2D_SetYUVColorMode(
+	IN gco2D Engine,
+	IN gce2D_YUV_COLOR_MODE Mode
+	);
+
+/* Setup the source global color value in ARGB8 format. */
+gceSTATUS gco2D_SetSourceGlobalColorAdvanced(
+	IN gco2D Engine,
+	IN gctUINT32 Color32
+	);
+
+/* Setup the target global color value in ARGB8 format. */
+gceSTATUS gco2D_SetTargetGlobalColorAdvanced(
+	IN gco2D Engine,
+	IN gctUINT32 Color32
+	);
+
+/* Setup the source and target pixel multiply modes. */
+gceSTATUS
+gco2D_SetPixelMultiplyModeAdvanced(
+	IN gco2D Engine,
+	IN gce2D_PIXEL_COLOR_MULTIPLY_MODE SrcPremultiplySrcAlpha,
+	IN gce2D_PIXEL_COLOR_MULTIPLY_MODE DstPremultiplyDstAlpha,
+	IN gce2D_GLOBAL_COLOR_MULTIPLY_MODE SrcPremultiplyGlobalMode,
+	IN gce2D_PIXEL_COLOR_MULTIPLY_MODE DstDemultiplyDstAlpha
+	);
+
+/* Set the GPU clock cycles after which the idle engine will keep auto-flushing. */
+gceSTATUS
+gco2D_SetAutoFlushCycles(
+	IN gco2D Engine,
+	IN gctUINT32 Cycles
+	);
+
+#if VIVANTE_PROFILER
+/* Read the profile registers available in the 2D engine and sets them in the profile.
+   The function will also reset the pixelsRendered counter every time.
+*/
+gceSTATUS
+gco2D_ProfileEngine(
+	IN gco2D Engine,
+	OPTIONAL gcs2D_PROFILE_PTR Profile
+	);
+#endif
+
+/* Enable or disable 2D dithering. */
+gceSTATUS
+gco2D_EnableDither(
+	IN gco2D Engine,
+	IN gctBOOL Enable
+	);
+
+gceSTATUS
+gco2D_SetGenericSource(
+    IN gco2D               Engine,
+    IN gctUINT32_PTR       Addresses,
+    IN gctUINT32           AddressNum,
+    IN gctUINT32_PTR       Strides,
+    IN gctUINT32           StrideNum,
+    IN gceTILING           Tiling,
+    IN gceSURF_FORMAT      Format,
+    IN gceSURF_ROTATION    Rotation,
+    IN gctUINT32           SurfaceWidth,
+    IN gctUINT32           SurfaceHeight
+);
+
+gceSTATUS
+gco2D_SetGenericTarget(
+    IN gco2D               Engine,
+    IN gctUINT32_PTR       Addresses,
+    IN gctUINT32           AddressNum,
+    IN gctUINT32_PTR       Strides,
+    IN gctUINT32           StrideNum,
+    IN gceTILING           Tiling,
+    IN gceSURF_FORMAT      Format,
+    IN gceSURF_ROTATION    Rotation,
+    IN gctUINT32           SurfaceWidth,
+    IN gctUINT32           SurfaceHeight
+);
+
+gceSTATUS
+gco2D_SetCurrentSourceIndex(
+    IN gco2D        Engine,
+    IN gctUINT32    SrcIndex
+    );
+
+gceSTATUS
+gco2D_MultiSourceBlit(
+    IN gco2D Engine,
+    IN gctUINT32 SourceMask,
+    IN gcsRECT_PTR DestRect,
+    IN gctUINT32 RectCount
+    );
+
+gceSTATUS
+gco2D_SetROP(
+    IN gco2D Engine,
+    IN gctUINT8 FgRop,
+    IN gctUINT8 BgRop
+    );
+
+gceSTATUS
+gco2D_SetGdiStretchMode(
+    IN gco2D Engine,
+    IN gctBOOL Enable
+    );
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __gc_hal_raster_h_ */
diff --git a/attic/gc_hal_rename.h b/attic/gc_hal_rename.h
new file mode 100644
index 0000000..ed6718d
--- /dev/null
+++ b/attic/gc_hal_rename.h
@@ -0,0 +1,250 @@
+/****************************************************************************
+*
+*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*
+*    This program is free software; you can redistribute it and/or modify
+*    it under the terms of the GNU General Public License as published by
+*    the Free Software Foundation; either version 2 of the license, or
+*    (at your option) any later version.
+*
+*    This program is distributed in the hope that it will be useful,
+*    but WITHOUT ANY WARRANTY; without even the implied warranty of
+*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+*    GNU General Public License for more details.
+*
+*    You should have received a copy of the GNU General Public License
+*    along with this program; if not write to the Free Software
+*    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*
+*****************************************************************************/
+
+
+
+
+#ifndef __gc_hal_rename_h_
+#define __gc_hal_rename_h_
+
+
+#if defined(_HAL2D_APPENDIX)
+
+#define _HAL2D_RENAME_2(api, appendix)  api ## appendix
+#define _HAL2D_RENAME_1(api, appendix)  _HAL2D_RENAME_2(api, appendix)
+#define gcmHAL2D(api)                   _HAL2D_RENAME_1(api, _HAL2D_APPENDIX)
+
+
+#define gckOS_Construct                 gcmHAL2D(gckOS_Construct)
+#define gckOS_Destroy                   gcmHAL2D(gckOS_Destroy)
+#define gckOS_QueryVideoMemory          gcmHAL2D(gckOS_QueryVideoMemory)
+#define gckOS_Allocate                  gcmHAL2D(gckOS_Allocate)
+#define gckOS_Free                      gcmHAL2D(gckOS_Free)
+#define gckOS_AllocateMemory            gcmHAL2D(gckOS_AllocateMemory)
+#define gckOS_FreeMemory                gcmHAL2D(gckOS_FreeMemory)
+#define gckOS_AllocatePagedMemory       gcmHAL2D(gckOS_AllocatePagedMemory)
+#define gckOS_AllocatePagedMemoryEx     gcmHAL2D(gckOS_AllocatePagedMemoryEx)
+#define gckOS_LockPages                 gcmHAL2D(gckOS_LockPages)
+#define gckOS_MapPages                  gcmHAL2D(gckOS_MapPages)
+#define gckOS_UnlockPages               gcmHAL2D(gckOS_UnlockPages)
+#define gckOS_FreePagedMemory           gcmHAL2D(gckOS_FreePagedMemory)
+#define gckOS_AllocateNonPagedMemory    gcmHAL2D(gckOS_AllocateNonPagedMemory)
+#define gckOS_FreeNonPagedMemory        gcmHAL2D(gckOS_FreeNonPagedMemory)
+#define gckOS_AllocateContiguous        gcmHAL2D(gckOS_AllocateContiguous)
+#define gckOS_FreeContiguous            gcmHAL2D(gckOS_FreeContiguous)
+#define gckOS_GetPageSize               gcmHAL2D(gckOS_GetPageSize)
+#define gckOS_GetPhysicalAddress        gcmHAL2D(gckOS_GetPhysicalAddress)
+#define gckOS_GetPhysicalAddressProcess     gcmHAL2D(gckOS_GetPhysicalAddressProcess)
+#define gckOS_MapPhysical                   gcmHAL2D(gckOS_MapPhysical)
+#define gckOS_UnmapPhysical             gcmHAL2D(gckOS_UnmapPhysical)
+#define gckOS_ReadRegister              gcmHAL2D(gckOS_ReadRegister)
+#define gckOS_WriteRegister             gcmHAL2D(gckOS_WriteRegister)
+#define gckOS_WriteMemory               gcmHAL2D(gckOS_WriteMemory)
+#define gckOS_MapMemory                 gcmHAL2D(gckOS_MapMemory)
+#define gckOS_UnmapMemory               gcmHAL2D(gckOS_UnmapMemory)
+#define gckOS_UnmapMemoryEx             gcmHAL2D(gckOS_UnmapMemoryEx)
+#define gckOS_CreateMutex               gcmHAL2D(gckOS_CreateMutex)
+#define gckOS_DeleteMutex               gcmHAL2D(gckOS_DeleteMutex)
+#define gckOS_AcquireMutex              gcmHAL2D(gckOS_AcquireMutex)
+#define gckOS_ReleaseMutex              gcmHAL2D(gckOS_ReleaseMutex)
+#define gckOS_AtomicExchange            gcmHAL2D(gckOS_AtomicExchange)
+#define gckOS_AtomicExchangePtr         gcmHAL2D(gckOS_AtomicExchangePtr)
+#define gckOS_AtomConstruct             gcmHAL2D(gckOS_AtomConstruct)
+#define gckOS_AtomDestroy               gcmHAL2D(gckOS_AtomDestroy)
+#define gckOS_AtomGet                   gcmHAL2D(gckOS_AtomGet)
+#define gckOS_AtomIncrement             gcmHAL2D(gckOS_AtomIncrement)
+#define gckOS_AtomDecrement             gcmHAL2D(gckOS_AtomDecrement)
+#define gckOS_Delay                     gcmHAL2D(gckOS_Delay)
+#define gckOS_GetTime                   gcmHAL2D(gckOS_GetTime)
+#define gckOS_MemoryBarrier             gcmHAL2D(gckOS_MemoryBarrier)
+#define gckOS_MapUserPointer            gcmHAL2D(gckOS_MapUserPointer)
+#define gckOS_UnmapUserPointer          gcmHAL2D(gckOS_UnmapUserPointer)
+#define gckOS_QueryNeedCopy             gcmHAL2D(gckOS_QueryNeedCopy)
+#define gckOS_CopyFromUserData          gcmHAL2D(gckOS_CopyFromUserData)
+#define gckOS_CopyToUserData            gcmHAL2D(gckOS_CopyToUserData)
+#define gckOS_MapUserPhysical           gcmHAL2D(gckOS_MapUserPhysical)
+#define gckOS_SuspendInterrupt          gcmHAL2D(gckOS_SuspendInterrupt)
+#define gckOS_ResumeInterrupt           gcmHAL2D(gckOS_ResumeInterrupt)
+#define gckOS_GetBaseAddress            gcmHAL2D(gckOS_GetBaseAddress)
+#define gckOS_MemCopy                   gcmHAL2D(gckOS_MemCopy)
+#define gckOS_ZeroMemory                gcmHAL2D(gckOS_ZeroMemory)
+#define gckOS_DeviceControl             gcmHAL2D(gckOS_DeviceControl)
+#define gckOS_GetProcessID              gcmHAL2D(gckOS_GetProcessID)
+#define gckOS_GetThreadID               gcmHAL2D(gckOS_GetThreadID)
+#define gckOS_CreateSignal              gcmHAL2D(gckOS_CreateSignal)
+#define gckOS_DestroySignal             gcmHAL2D(gckOS_DestroySignal)
+#define gckOS_Signal                    gcmHAL2D(gckOS_Signal)
+#define gckOS_WaitSignal                gcmHAL2D(gckOS_WaitSignal)
+#define gckOS_MapSignal                 gcmHAL2D(gckOS_MapSignal)
+#define gckOS_MapUserMemory             gcmHAL2D(gckOS_MapUserMemory)
+#define gckOS_UnmapUserMemory           gcmHAL2D(gckOS_UnmapUserMemory)
+#define gckOS_CreateUserSignal          gcmHAL2D(gckOS_CreateUserSignal)
+#define gckOS_DestroyUserSignal         gcmHAL2D(gckOS_DestroyUserSignal)
+#define gckOS_WaitUserSignal            gcmHAL2D(gckOS_WaitUserSignal)
+#define gckOS_SignalUserSignal          gcmHAL2D(gckOS_SignalUserSignal)
+#define gckOS_UserSignal                gcmHAL2D(gckOS_UserSignal)
+#define gckOS_UserSignal                gcmHAL2D(gckOS_UserSignal)
+#define gckOS_CacheClean                gcmHAL2D(gckOS_CacheClean)
+#define gckOS_CacheFlush                gcmHAL2D(gckOS_CacheFlush)
+#define gckOS_SetDebugLevel             gcmHAL2D(gckOS_SetDebugLevel)
+#define gckOS_SetDebugZone              gcmHAL2D(gckOS_SetDebugZone)
+#define gckOS_SetDebugLevelZone         gcmHAL2D(gckOS_SetDebugLevelZone)
+#define gckOS_SetDebugZones             gcmHAL2D(gckOS_SetDebugZones)
+#define gckOS_SetDebugFile              gcmHAL2D(gckOS_SetDebugFile)
+#define gckOS_Broadcast                 gcmHAL2D(gckOS_Broadcast)
+#define gckOS_SetGPUPower               gcmHAL2D(gckOS_SetGPUPower)
+#define gckOS_CreateSemaphore           gcmHAL2D(gckOS_CreateSemaphore)
+#define gckOS_DestroySemaphore          gcmHAL2D(gckOS_DestroySemaphore)
+#define gckOS_AcquireSemaphore          gcmHAL2D(gckOS_AcquireSemaphore)
+#define gckOS_ReleaseSemaphore          gcmHAL2D(gckOS_ReleaseSemaphore)
+#define gckHEAP_Construct               gcmHAL2D(gckHEAP_Construct)
+#define gckHEAP_Destroy                 gcmHAL2D(gckHEAP_Destroy)
+#define gckHEAP_Allocate                gcmHAL2D(gckHEAP_Allocate)
+#define gckHEAP_Free                    gcmHAL2D(gckHEAP_Free)
+#define gckHEAP_ProfileStart            gcmHAL2D(gckHEAP_ProfileStart)
+#define gckHEAP_ProfileEnd              gcmHAL2D(gckHEAP_ProfileEnd)
+#define gckHEAP_Test                    gcmHAL2D(gckHEAP_Test)
+#define gckVIDMEM_Construct             gcmHAL2D(gckVIDMEM_Construct)
+#define gckVIDMEM_Destroy               gcmHAL2D(gckVIDMEM_Destroy)
+#define gckVIDMEM_Allocate              gcmHAL2D(gckVIDMEM_Allocate)
+#define gckVIDMEM_AllocateLinear        gcmHAL2D(gckVIDMEM_AllocateLinear)
+#define gckVIDMEM_Free                  gcmHAL2D(gckVIDMEM_Free)
+#define gckVIDMEM_Lock                  gcmHAL2D(gckVIDMEM_Lock)
+#define gckVIDMEM_Unlock                gcmHAL2D(gckVIDMEM_Unlock)
+#define gckVIDMEM_ConstructVirtual      gcmHAL2D(gckVIDMEM_ConstructVirtual)
+#define gckVIDMEM_DestroyVirtual        gcmHAL2D(gckVIDMEM_DestroyVirtual)
+#define gckKERNEL_Construct             gcmHAL2D(gckKERNEL_Construct)
+#define gckKERNEL_Destroy               gcmHAL2D(gckKERNEL_Destroy)
+#define gckKERNEL_Dispatch              gcmHAL2D(gckKERNEL_Dispatch)
+#define gckKERNEL_QueryVideoMemory      gcmHAL2D(gckKERNEL_QueryVideoMemory)
+#define gckKERNEL_GetVideoMemoryPool    gcmHAL2D(gckKERNEL_GetVideoMemoryPool)
+#define gckKERNEL_MapVideoMemory        gcmHAL2D(gckKERNEL_MapVideoMemory)
+#define gckKERNEL_UnmapVideoMemory      gcmHAL2D(gckKERNEL_UnmapVideoMemory)
+#define gckKERNEL_MapMemory             gcmHAL2D(gckKERNEL_MapMemory)
+#define gckKERNEL_UnmapMemory           gcmHAL2D(gckKERNEL_UnmapMemory)
+#define gckKERNEL_Notify                gcmHAL2D(gckKERNEL_Notify)
+#define gckKERNEL_QuerySettings         gcmHAL2D(gckKERNEL_QuerySettings)
+#define gckKERNEL_Recovery              gcmHAL2D(gckKERNEL_Recovery)
+#define gckKERNEL_OpenUserData          gcmHAL2D(gckKERNEL_OpenUserData)
+#define gckKERNEL_CloseUserData         gcmHAL2D(gckKERNEL_CloseUserData)
+#define gckHARDWARE_Construct           gcmHAL2D(gckHARDWARE_Construct)
+#define gckHARDWARE_Destroy             gcmHAL2D(gckHARDWARE_Destroy)
+#define gckHARDWARE_QuerySystemMemory   gcmHAL2D(gckHARDWARE_QuerySystemMemory)
+#define gckHARDWARE_BuildVirtualAddress     gcmHAL2D(gckHARDWARE_BuildVirtualAddress)
+#define gckHARDWARE_QueryCommandBuffer      gcmHAL2D(gckHARDWARE_QueryCommandBuffer)
+#define gckHARDWARE_WaitLink            gcmHAL2D(gckHARDWARE_WaitLink)
+#define gckHARDWARE_Execute             gcmHAL2D(gckHARDWARE_Execute)
+#define gckHARDWARE_End                 gcmHAL2D(gckHARDWARE_End)
+#define gckHARDWARE_Nop                 gcmHAL2D(gckHARDWARE_Nop)
+#define gckHARDWARE_Wait                gcmHAL2D(gckHARDWARE_Wait)
+#define gckHARDWARE_PipeSelect          gcmHAL2D(gckHARDWARE_PipeSelect)
+#define gckHARDWARE_Link                gcmHAL2D(gckHARDWARE_Link)
+#define gckHARDWARE_Event               gcmHAL2D(gckHARDWARE_Event)
+#define gckHARDWARE_QueryMemory         gcmHAL2D(gckHARDWARE_QueryMemory)
+#define gckHARDWARE_QueryChipIdentity   gcmHAL2D(gckHARDWARE_QueryChipIdentity)
+#define gckHARDWARE_QueryChipSpecs      gcmHAL2D(gckHARDWARE_QueryChipSpecs)
+#define gckHARDWARE_QueryShaderCaps     gcmHAL2D(gckHARDWARE_QueryShaderCaps)
+#define gckHARDWARE_ConvertFormat       gcmHAL2D(gckHARDWARE_ConvertFormat)
+#define gckHARDWARE_SplitMemory         gcmHAL2D(gckHARDWARE_SplitMemory)
+#define gckHARDWARE_AlignToTile         gcmHAL2D(gckHARDWARE_AlignToTile)
+#define gckHARDWARE_UpdateQueueTail     gcmHAL2D(gckHARDWARE_UpdateQueueTail)
+#define gckHARDWARE_ConvertLogical      gcmHAL2D(gckHARDWARE_ConvertLogical)
+#define gckHARDWARE_ConvertPhysical     gcmHAL2D(gckHARDWARE_ConvertPhysical)
+#define gckHARDWARE_Interrupt           gcmHAL2D(gckHARDWARE_Interrupt)
+#define gckHARDWARE_SetMMU              gcmHAL2D(gckHARDWARE_SetMMU)
+#define gckHARDWARE_FlushMMU            gcmHAL2D(gckHARDWARE_FlushMMU)
+#define gckHARDWARE_GetIdle             gcmHAL2D(gckHARDWARE_GetIdle)
+#define gckHARDWARE_Flush               gcmHAL2D(gckHARDWARE_Flush)
+#define gckHARDWARE_SetFastClear        gcmHAL2D(gckHARDWARE_SetFastClear)
+#define gckHARDWARE_ReadInterrupt       gcmHAL2D(gckHARDWARE_ReadInterrupt)
+#define gckHARDWARE_SetPowerManagementState         gcmHAL2D(gckHARDWARE_SetPowerManagementState)
+#define gckHARDWARE_QueryPowerManagementState       gcmHAL2D(gckHARDWARE_QueryPowerManagementState)
+#define gckHARDWARE_ProfileEngine2D     gcmHAL2D(gckHARDWARE_ProfileEngine2D)
+#define gckHARDWARE_InitializeHardware  gcmHAL2D(gckHARDWARE_InitializeHardware)
+#define gckHARDWARE_Reset               gcmHAL2D(gckHARDWARE_Reset)
+#define gckINTERRUPT_Construct          gcmHAL2D(gckINTERRUPT_Construct)
+#define gckINTERRUPT_Destroy            gcmHAL2D(gckINTERRUPT_Destroy)
+#define gckINTERRUPT_SetHandler         gcmHAL2D(gckINTERRUPT_SetHandler)
+#define gckINTERRUPT_Notify             gcmHAL2D(gckINTERRUPT_Notify)
+#define gckEVENT_Construct              gcmHAL2D(gckEVENT_Construct)
+#define gckEVENT_Destroy                gcmHAL2D(gckEVENT_Destroy)
+#define gckEVENT_AddList                gcmHAL2D(gckEVENT_AddList)
+#define gckEVENT_FreeNonPagedMemory     gcmHAL2D(gckEVENT_FreeNonPagedMemory)
+#define gckEVENT_FreeContiguousMemory   gcmHAL2D(gckEVENT_FreeContiguousMemory)
+#define gckEVENT_FreeVideoMemory        gcmHAL2D(gckEVENT_FreeVideoMemory)
+#define gckEVENT_Signal                 gcmHAL2D(gckEVENT_Signal)
+#define gckEVENT_Unlock                 gcmHAL2D(gckEVENT_Unlock)
+#define gckEVENT_Submit                 gcmHAL2D(gckEVENT_Submit)
+#define gckEVENT_Commit                 gcmHAL2D(gckEVENT_Commit)
+#define gckEVENT_Notify                 gcmHAL2D(gckEVENT_Notify)
+#define gckEVENT_Interrupt              gcmHAL2D(gckEVENT_Interrupt)
+#define gckCOMMAND_Construct            gcmHAL2D(gckCOMMAND_Construct)
+#define gckCOMMAND_Destroy              gcmHAL2D(gckCOMMAND_Destroy)
+#define gckCOMMAND_EnterCommit          gcmHAL2D(gckCOMMAND_EnterCommit)
+#define gckCOMMAND_ExitCommit           gcmHAL2D(gckCOMMAND_ExitCommit)
+#define gckCOMMAND_Start                gcmHAL2D(gckCOMMAND_Start)
+#define gckCOMMAND_Stop                 gcmHAL2D(gckCOMMAND_Stop)
+#define gckCOMMAND_Commit               gcmHAL2D(gckCOMMAND_Commit)
+#define gckCOMMAND_Reserve              gcmHAL2D(gckCOMMAND_Reserve)
+#define gckCOMMAND_Execute              gcmHAL2D(gckCOMMAND_Execute)
+#define gckCOMMAND_Stall                gcmHAL2D(gckCOMMAND_Stall)
+#define gckCOMMAND_Attach               gcmHAL2D(gckCOMMAND_Attach)
+#define gckCOMMAND_Detach               gcmHAL2D(gckCOMMAND_Detach)
+#define gckMMU_Construct                gcmHAL2D(gckMMU_Construct)
+#define gckMMU_Destroy                  gcmHAL2D(gckMMU_Destroy)
+#define gckMMU_AllocatePages            gcmHAL2D(gckMMU_AllocatePages)
+#define gckMMU_FreePages                gcmHAL2D(gckMMU_FreePages)
+#define gckMMU_InsertNode               gcmHAL2D(gckMMU_InsertNode)
+#define gckMMU_RemoveNode               gcmHAL2D(gckMMU_RemoveNode)
+#define gckMMU_FreeHandleMemory         gcmHAL2D(gckMMU_FreeHandleMemory)
+#define gckMMU_Test                     gcmHAL2D(gckMMU_Test)
+#define gckHARDWARE_QueryProfileRegisters     gcmHAL2D(gckHARDWARE_QueryProfileRegisters)
+
+
+#define FindMdlMap                      gcmHAL2D(FindMdlMap)
+#define OnProcessExit                   gcmHAL2D(OnProcessExit)
+
+#define gckGALDEVICE_Destroy            gcmHAL2D(gckGALDEVICE_Destroy)
+#define gckOS_Print                     gcmHAL2D(gckOS_Print)
+#define gckGALDEVICE_FreeMemory         gcmHAL2D(gckGALDEVICE_FreeMemory)
+#define gckGALDEVICE_AllocateMemory     gcmHAL2D(gckGALDEVICE_AllocateMemory)
+#define gckOS_DebugBreak                gcmHAL2D(gckOS_DebugBreak)
+#define gckGALDEVICE_Release_ISR        gcmHAL2D(gckGALDEVICE_Release_ISR)
+#define gckOS_Verify                    gcmHAL2D(gckOS_Verify)
+#define gckCOMMAND_Release              gcmHAL2D(gckCOMMAND_Release)
+#define gckGALDEVICE_Stop               gcmHAL2D(gckGALDEVICE_Stop)
+#define gckGALDEVICE_Construct          gcmHAL2D(gckGALDEVICE_Construct)
+#define gckOS_DebugFatal                gcmHAL2D(gckOS_DebugFatal)
+#define gckOS_DebugTrace                gcmHAL2D(gckOS_DebugTrace)
+#define gckHARDWARE_GetBaseAddress      gcmHAL2D(gckHARDWARE_GetBaseAddress)
+#define gckGALDEVICE_Setup_ISR          gcmHAL2D(gckGALDEVICE_Setup_ISR)
+#define gckKERNEL_AttachProcess         gcmHAL2D(gckKERNEL_AttachProcess)
+#define gckKERNEL_AttachProcessEx       gcmHAL2D(gckKERNEL_AttachProcessEx)
+#define gckGALDEVICE_Start_Thread       gcmHAL2D(gckGALDEVICE_Start_Thread)
+#define gckHARDWARE_QueryIdle           gcmHAL2D(gckHARDWARE_QueryIdle)
+#define gckGALDEVICE_Start              gcmHAL2D(gckGALDEVICE_Start)
+#define gckOS_GetKernelLogical          gcmHAL2D(gckOS_GetKernelLogical)
+#define gckOS_DebugTraceZone            gcmHAL2D(gckOS_DebugTraceZone)
+#define gckGALDEVICE_Stop_Thread        gcmHAL2D(gckGALDEVICE_Stop_Thread)
+#define gckHARDWARE_NeedBaseAddress     gcmHAL2D(gckHARDWARE_NeedBaseAddress)
+
+#endif
+
+#endif /* __gc_hal_rename_h_ */
diff --git a/attic/gc_hal_types.h b/attic/gc_hal_types.h
new file mode 100644
index 0000000..e6d38c1
--- /dev/null
+++ b/attic/gc_hal_types.h
@@ -0,0 +1,970 @@
+/****************************************************************************
+*
+*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*
+*    This program is free software; you can redistribute it and/or modify
+*    it under the terms of the GNU General Public License as published by
+*    the Free Software Foundation; either version 2 of the license, or
+*    (at your option) any later version.
+*
+*    This program is distributed in the hope that it will be useful,
+*    but WITHOUT ANY WARRANTY; without even the implied warranty of
+*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+*    GNU General Public License for more details.
+*
+*    You should have received a copy of the GNU General Public License
+*    along with this program; if not write to the Free Software
+*    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*
+*****************************************************************************/
+
+
+
+
+#ifndef __gc_hal_types_h_
+#define __gc_hal_types_h_
+
+#include "gc_hal_version.h"
+#include "gc_hal_options.h"
+
+#ifdef _WIN32
+#pragma warning(disable:4127)   /* Conditional expression is constant (do { }
+                                ** while(0)). */
+#pragma warning(disable:4100)   /* Unreferenced formal parameter. */
+#pragma warning(disable:4204)   /* Non-constant aggregate initializer (C99). */
+#pragma warning(disable:4131)   /* Uses old-style declarator (for Bison and
+                                ** Flex generated files). */
+#pragma warning(disable:4206)   /* Translation unit is empty. */
+#endif
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/******************************************************************************\
+**  Platform macros.
+*/
+
+#if defined(__GNUC__)
+#   define gcdHAS_ELLIPSES      1       /* GCC always has it. */
+#elif defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L)
+#   define gcdHAS_ELLIPSES      1       /* C99 has it. */
+#elif defined(_MSC_VER) && (_MSC_VER >= 1500)
+#   define gcdHAS_ELLIPSES      1       /* MSVC 2007+ has it. */
+#elif defined(UNDER_CE)
+#if UNDER_CE >= 600
+#       define gcdHAS_ELLIPSES  1
+#   else
+#       define gcdHAS_ELLIPSES  0
+#   endif
+#else
+#   error "gcdHAS_ELLIPSES: Platform could not be determined"
+#endif
+
+/******************************************************************************\
+************************************ Keyword ***********************************
+\******************************************************************************/
+
+#if (defined(__STDC_VERSION__) && (__STDC_VERSION__ >= 199901L))
+#   define gcmINLINE            inline      /* C99 keyword. */
+#elif defined(__GNUC__)
+#   define gcmINLINE            __inline__  /* GNU keyword. */
+#elif defined(_MSC_VER) || defined(UNDER_CE)
+#   define gcmINLINE            __inline    /* Internal keyword. */
+#else
+#   error "gcmINLINE: Platform could not be determined"
+#endif
+
+/* Possible debug flags. */
+#define gcdDEBUG_NONE           0
+#define gcdDEBUG_ALL            (1 << 0)
+#define gcdDEBUG_FATAL          (1 << 1)
+#define gcdDEBUG_TRACE          (1 << 2)
+#define gcdDEBUG_BREAK          (1 << 3)
+#define gcdDEBUG_ASSERT         (1 << 4)
+#define gcdDEBUG_CODE           (1 << 5)
+#define gcdDEBUG_STACK          (1 << 6)
+
+#define gcmIS_DEBUG(flag)       ( gcdDEBUG & (flag | gcdDEBUG_ALL) )
+
+#ifndef gcdDEBUG
+#if (defined(DBG) && DBG) || defined(DEBUG) || defined(_DEBUG)
+#       define gcdDEBUG         gcdDEBUG_ALL
+#   else
+#       define gcdDEBUG         gcdDEBUG_NONE
+#   endif
+#endif
+
+#ifdef _USRDLL
+#ifdef _MSC_VER
+#ifdef HAL_EXPORTS
+#           define HALAPI       __declspec(dllexport)
+#       else
+#           define HALAPI       __declspec(dllimport)
+#       endif
+#       define HALDECL          __cdecl
+#   else
+#ifdef HAL_EXPORTS
+#           define HALAPI
+#       else
+#           define HALAPI       extern
+#       endif
+#   endif
+#else
+#   define HALAPI
+#   define HALDECL
+#endif
+
+/******************************************************************************\
+********************************** Common Types ********************************
+\******************************************************************************/
+
+#define gcvFALSE                0
+#define gcvTRUE                 1
+
+#define gcvINFINITE             ((gctUINT32) ~0U)
+
+#define gcvINVALID_HANDLE       ((gctHANDLE) ~0U)
+
+typedef int                     gctBOOL;
+typedef gctBOOL *               gctBOOL_PTR;
+
+typedef int                     gctINT;
+typedef signed char             gctINT8;
+typedef signed short            gctINT16;
+typedef signed int              gctINT32;
+typedef signed long long        gctINT64;
+
+typedef gctINT *                gctINT_PTR;
+typedef gctINT8 *               gctINT8_PTR;
+typedef gctINT16 *              gctINT16_PTR;
+typedef gctINT32 *              gctINT32_PTR;
+typedef gctINT64 *              gctINT64_PTR;
+
+typedef unsigned int            gctUINT;
+typedef unsigned char           gctUINT8;
+typedef unsigned short          gctUINT16;
+typedef unsigned int            gctUINT32;
+typedef unsigned long long      gctUINT64;
+
+typedef gctUINT *               gctUINT_PTR;
+typedef gctUINT8 *              gctUINT8_PTR;
+typedef gctUINT16 *             gctUINT16_PTR;
+typedef gctUINT32 *             gctUINT32_PTR;
+typedef gctUINT64 *             gctUINT64_PTR;
+
+typedef unsigned long           gctSIZE_T;
+typedef gctSIZE_T *             gctSIZE_T_PTR;
+
+#ifdef __cplusplus
+#   define gcvNULL              0
+#else
+#   define gcvNULL              ((void *) 0)
+#endif
+
+typedef float                   gctFLOAT;
+typedef signed int              gctFIXED_POINT;
+typedef float *                 gctFLOAT_PTR;
+
+typedef void *                  gctPHYS_ADDR;
+typedef void *                  gctHANDLE;
+typedef void *                  gctFILE;
+typedef void *                  gctSIGNAL;
+typedef void *                  gctWINDOW;
+typedef void *                  gctIMAGE;
+
+typedef void *					gctSEMAPHORE;
+
+typedef void *                  gctPOINTER;
+typedef const void *            gctCONST_POINTER;
+
+typedef char                    gctCHAR;
+typedef char *                  gctSTRING;
+typedef const char *            gctCONST_STRING;
+
+typedef struct _gcsCOUNT_STRING
+{
+    gctSIZE_T                   Length;
+    gctCONST_STRING             String;
+}
+gcsCOUNT_STRING;
+
+typedef union _gcuFLOAT_UINT32
+{
+    gctFLOAT    f;
+    gctUINT32   u;
+}
+gcuFLOAT_UINT32;
+
+/* Fixed point constants. */
+#define gcvZERO_X               ((gctFIXED_POINT) 0x00000000)
+#define gcvHALF_X               ((gctFIXED_POINT) 0x00008000)
+#define gcvONE_X                ((gctFIXED_POINT) 0x00010000)
+#define gcvNEGONE_X             ((gctFIXED_POINT) 0xFFFF0000)
+#define gcvTWO_X                ((gctFIXED_POINT) 0x00020000)
+
+/* Stringizing macro. */
+#define gcmSTRING(Value)        #Value
+
+/******************************************************************************\
+******************************* Fixed Point Math *******************************
+\******************************************************************************/
+
+#define gcmXMultiply(x1, x2)            gcoMATH_MultiplyFixed(x1, x2)
+#define gcmXDivide(x1, x2)              gcoMATH_DivideFixed(x1, x2)
+#define gcmXMultiplyDivide(x1, x2, x3)  gcoMATH_MultiplyDivideFixed(x1, x2, x3)
+
+/* 2D Engine profile. */
+typedef struct _gcs2D_PROFILE
+{
+    /* Cycle count.
+       32bit counter incremented every 2D clock cycle.
+       Wraps back to 0 when the counter overflows.
+    */
+    gctUINT32 cycleCount;
+
+    /* Pixels rendered by the 2D engine.
+       Resets to 0 every time it is read. */
+    gctUINT32 pixelsRendered;
+}
+gcs2D_PROFILE;
+
+/* Macro to combine four characters into a Charcater Code. */
+#define gcmCC(c1, c2, c3, c4) \
+( \
+    (char) (c1) \
+    | \
+    ((char) (c2) <<  8) \
+    | \
+    ((char) (c3) << 16) \
+    | \
+    ((char) (c4) << 24) \
+)
+
+#define gcmPRINTABLE(c)         ((((c) >= ' ') && ((c) <= '}')) ? ((c) != '%' ?  (c) : ' ') : ' ')
+
+#define gcmCC_PRINT(cc) \
+    gcmPRINTABLE((char) ( (cc)        & 0xFF)), \
+    gcmPRINTABLE((char) (((cc) >>  8) & 0xFF)), \
+    gcmPRINTABLE((char) (((cc) >> 16) & 0xFF)), \
+    gcmPRINTABLE((char) (((cc) >> 24) & 0xFF))
+
+/******************************************************************************\
+****************************** Function Parameters *****************************
+\******************************************************************************/
+
+#define IN
+#define OUT
+#define OPTIONAL
+
+/******************************************************************************\
+********************************* Status Codes *********************************
+\******************************************************************************/
+
+typedef enum _gceSTATUS
+{
+    gcvSTATUS_OK                    =   0,
+    gcvSTATUS_FALSE                 =   0,
+    gcvSTATUS_TRUE                  =   1,
+    gcvSTATUS_NO_MORE_DATA          =   2,
+    gcvSTATUS_CACHED                =   3,
+    gcvSTATUS_MIPMAP_TOO_LARGE      =   4,
+    gcvSTATUS_NAME_NOT_FOUND        =   5,
+    gcvSTATUS_NOT_OUR_INTERRUPT     =   6,
+    gcvSTATUS_MISMATCH              =   7,
+    gcvSTATUS_MIPMAP_TOO_SMALL      =   8,
+    gcvSTATUS_LARGER                =   9,
+    gcvSTATUS_SMALLER               =   10,
+    gcvSTATUS_CHIP_NOT_READY        =   11,
+    gcvSTATUS_NEED_CONVERSION       =   12,
+    gcvSTATUS_SKIP                  =   13,
+    gcvSTATUS_DATA_TOO_LARGE        =   14,
+    gcvSTATUS_INVALID_CONFIG        =   15,
+    gcvSTATUS_CHANGED               =   16,
+    gcvSTATUS_NOT_SUPPORT_DITHER    =   17,
+	gcvSTATUS_EXECUTED				=	18,
+    gcvSTATUS_TERMINATE             =   19,
+
+    gcvSTATUS_INVALID_ARGUMENT      =   -1,
+    gcvSTATUS_INVALID_OBJECT        =   -2,
+    gcvSTATUS_OUT_OF_MEMORY         =   -3,
+    gcvSTATUS_MEMORY_LOCKED         =   -4,
+    gcvSTATUS_MEMORY_UNLOCKED       =   -5,
+    gcvSTATUS_HEAP_CORRUPTED        =   -6,
+    gcvSTATUS_GENERIC_IO            =   -7,
+    gcvSTATUS_INVALID_ADDRESS       =   -8,
+    gcvSTATUS_CONTEXT_LOSSED        =   -9,
+    gcvSTATUS_TOO_COMPLEX           =   -10,
+    gcvSTATUS_BUFFER_TOO_SMALL      =   -11,
+    gcvSTATUS_INTERFACE_ERROR       =   -12,
+    gcvSTATUS_NOT_SUPPORTED         =   -13,
+    gcvSTATUS_MORE_DATA             =   -14,
+    gcvSTATUS_TIMEOUT               =   -15,
+    gcvSTATUS_OUT_OF_RESOURCES      =   -16,
+    gcvSTATUS_INVALID_DATA          =   -17,
+    gcvSTATUS_INVALID_MIPMAP        =   -18,
+    gcvSTATUS_NOT_FOUND             =   -19,
+    gcvSTATUS_NOT_ALIGNED           =   -20,
+    gcvSTATUS_INVALID_REQUEST       =   -21,
+    gcvSTATUS_GPU_NOT_RESPONDING    =   -22,
+    gcvSTATUS_TIMER_OVERFLOW        =   -23,
+    gcvSTATUS_VERSION_MISMATCH      =   -24,
+    gcvSTATUS_LOCKED                =   -25,
+    gcvSTATUS_INTERRUPTED           =   -26,
+    gcvSTATUS_DEVICE                =   -27,
+
+    /* Linker errors. */
+    gcvSTATUS_GLOBAL_TYPE_MISMATCH  =   -1000,
+    gcvSTATUS_TOO_MANY_ATTRIBUTES   =   -1001,
+    gcvSTATUS_TOO_MANY_UNIFORMS     =   -1002,
+    gcvSTATUS_TOO_MANY_VARYINGS     =   -1003,
+    gcvSTATUS_UNDECLARED_VARYING    =   -1004,
+    gcvSTATUS_VARYING_TYPE_MISMATCH =   -1005,
+    gcvSTATUS_MISSING_MAIN          =   -1006,
+    gcvSTATUS_NAME_MISMATCH         =   -1007,
+    gcvSTATUS_INVALID_INDEX         =   -1008,
+    gcvSTATUS_UNIFORM_TYPE_MISMATCH =   -1009,
+}
+gceSTATUS;
+
+/******************************************************************************\
+********************************* Status Macros ********************************
+\******************************************************************************/
+
+#define gcmIS_ERROR(status)         (status < 0)
+#define gcmNO_ERROR(status)         (status >= 0)
+#define gcmIS_SUCCESS(status)       (status == gcvSTATUS_OK)
+
+/******************************************************************************\
+********************************* Field Macros *********************************
+\******************************************************************************/
+
+#define __gcmSTART(reg_field) \
+    (0 ? reg_field)
+
+#define __gcmEND(reg_field) \
+    (1 ? reg_field)
+
+#define __gcmGETSIZE(reg_field) \
+    (__gcmEND(reg_field) - __gcmSTART(reg_field) + 1)
+
+#define __gcmALIGN(data, reg_field) \
+    (((gctUINT32) (data)) << __gcmSTART(reg_field))
+
+#define __gcmMASK(reg_field) \
+    ((gctUINT32) ((__gcmGETSIZE(reg_field) == 32) \
+        ?  ~0 \
+        : (~(~0 << __gcmGETSIZE(reg_field)))))
+
+/*******************************************************************************
+**
+**  gcmFIELDMASK
+**
+**      Get aligned field mask.
+**
+**  ARGUMENTS:
+**
+**      reg     Name of register.
+**      field   Name of field within register.
+*/
+#define gcmFIELDMASK(reg, field) \
+( \
+    __gcmALIGN(__gcmMASK(reg##_##field), reg##_##field) \
+)
+
+/*******************************************************************************
+**
+**  gcmGETFIELD
+**
+**      Extract the value of a field from specified data.
+**
+**  ARGUMENTS:
+**
+**      data    Data value.
+**      reg     Name of register.
+**      field   Name of field within register.
+*/
+#define gcmGETFIELD(data, reg, field) \
+( \
+    ((((gctUINT32) (data)) >> __gcmSTART(reg##_##field)) \
+        & __gcmMASK(reg##_##field)) \
+)
+
+/*******************************************************************************
+**
+**  gcmSETFIELD
+**
+**      Set the value of a field within specified data.
+**
+**  ARGUMENTS:
+**
+**      data    Data value.
+**      reg     Name of register.
+**      field   Name of field within register.
+**      value   Value for field.
+*/
+#define gcmSETFIELD(data, reg, field, value) \
+( \
+    (((gctUINT32) (data)) \
+        & ~__gcmALIGN(__gcmMASK(reg##_##field), reg##_##field)) \
+        |  __gcmALIGN((gctUINT32) (value) \
+            & __gcmMASK(reg##_##field), reg##_##field) \
+)
+
+/*******************************************************************************
+**
+**  gcmSETFIELDVALUE
+**
+**      Set the value of a field within specified data with a
+**      predefined value.
+**
+**  ARGUMENTS:
+**
+**      data    Data value.
+**      reg     Name of register.
+**      field   Name of field within register.
+**      value   Name of the value within the field.
+*/
+#define gcmSETFIELDVALUE(data, reg, field, value) \
+( \
+    (((gctUINT32) (data)) \
+        & ~__gcmALIGN(__gcmMASK(reg##_##field), reg##_##field)) \
+        |  __gcmALIGN(reg##_##field##_##value \
+            & __gcmMASK(reg##_##field), reg##_##field) \
+)
+
+/*******************************************************************************
+**
+**  gcmGETMASKEDFIELDMASK
+**
+**      Determine field mask of a masked field.
+**
+**  ARGUMENTS:
+**
+**      reg     Name of register.
+**      field   Name of field within register.
+*/
+#define gcmGETMASKEDFIELDMASK(reg, field) \
+( \
+    gcmSETFIELD(0, reg,          field, ~0) | \
+    gcmSETFIELD(0, reg, MASK_ ## field, ~0)   \
+)
+
+/*******************************************************************************
+**
+**  gcmSETMASKEDFIELD
+**
+**      Set the value of a masked field with specified data.
+**
+**  ARGUMENTS:
+**
+**      reg     Name of register.
+**      field   Name of field within register.
+**      value   Value for field.
+*/
+#define gcmSETMASKEDFIELD(reg, field, value) \
+( \
+    gcmSETFIELD     (~0, reg,          field, value) & \
+    gcmSETFIELDVALUE(~0, reg, MASK_ ## field, ENABLED) \
+)
+
+/*******************************************************************************
+**
+**  gcmSETMASKEDFIELDVALUE
+**
+**      Set the value of a masked field with specified data.
+**
+**  ARGUMENTS:
+**
+**      reg     Name of register.
+**      field   Name of field within register.
+**      value   Value for field.
+*/
+#define gcmSETMASKEDFIELDVALUE(reg, field, value) \
+( \
+    gcmSETFIELDVALUE(~0, reg,          field, value) & \
+    gcmSETFIELDVALUE(~0, reg, MASK_ ## field, ENABLED) \
+)
+
+/*******************************************************************************
+**
+**  gcmVERIFYFIELDVALUE
+**
+**      Verify if the value of a field within specified data equals a
+**      predefined value.
+**
+**  ARGUMENTS:
+**
+**      data    Data value.
+**      reg     Name of register.
+**      field   Name of field within register.
+**      value   Name of the value within the field.
+*/
+#define gcmVERIFYFIELDVALUE(data, reg, field, value) \
+( \
+    (((gctUINT32) (data)) >> __gcmSTART(reg##_##field) & \
+                             __gcmMASK(reg##_##field)) \
+        == \
+    (reg##_##field##_##value & __gcmMASK(reg##_##field)) \
+)
+
+/*******************************************************************************
+**  Bit field macros.
+*/
+
+#define __gcmSTARTBIT(Field) \
+    ( 1 ? Field )
+
+#define __gcmBITSIZE(Field) \
+    ( 0 ? Field )
+
+#define __gcmBITMASK(Field) \
+( \
+    (1 << __gcmBITSIZE(Field)) - 1 \
+)
+
+#define gcmGETBITS(Value, Type, Field) \
+( \
+    ( ((Type) (Value)) >> __gcmSTARTBIT(Field) ) \
+    & \
+    __gcmBITMASK(Field) \
+)
+
+#define gcmSETBITS(Value, Type, Field, NewValue) \
+( \
+    ( ((Type) (Value)) \
+    & ~(__gcmBITMASK(Field) << __gcmSTARTBIT(Field)) \
+    ) \
+    | \
+    ( ( ((Type) (NewValue)) \
+      & __gcmBITMASK(Field) \
+      ) << __gcmSTARTBIT(Field) \
+    ) \
+)
+
+/*******************************************************************************
+**
+**  gcmISINREGRANGE
+**
+**      Verify whether the specified address is in the register range.
+**
+**  ARGUMENTS:
+**
+**      Address Address to be verified.
+**      Name    Name of a register.
+*/
+
+#define gcmISINREGRANGE(Address, Name) \
+( \
+    ((Address & (~0U << Name ## _LSB)) == (Name ## _Address >> 2)) \
+)
+
+/*******************************************************************************
+**
+**  A set of macros to aid state loading.
+**
+**  ARGUMENTS:
+**
+**      CommandBuffer   Pointer to a gcoCMDBUF object.
+**      StateDelta      Pointer to a gcsSTATE_DELTA state delta structure.
+**      Memory          Destination memory pointer of gctUINT32_PTR type.
+**      PartOfContext   Whether or not the state is a part of the context.
+**      FixedPoint      Whether or not the state is of the fixed point format.
+**      Count           Number of consecutive states to be loaded.
+**      Address         State address.
+**      Data            Data to be set to the state.
+*/
+
+/*----------------------------------------------------------------------------*/
+
+#if gcmIS_DEBUG(gcdDEBUG_CODE)
+
+#   define gcmSTORELOADSTATE(CommandBuffer, Memory, Address, Count) \
+        CommandBuffer->lastLoadStatePtr     = Memory; \
+        CommandBuffer->lastLoadStateAddress = Address; \
+        CommandBuffer->lastLoadStateCount   = Count
+
+#   define gcmVERIFYLOADSTATE(CommandBuffer, Memory, Address) \
+        gcmASSERT( \
+            (gctUINT) (Memory  - CommandBuffer->lastLoadStatePtr - 1) \
+            == \
+            (gctUINT) (Address - CommandBuffer->lastLoadStateAddress) \
+            ); \
+        \
+        gcmASSERT(CommandBuffer->lastLoadStateCount > 0); \
+        \
+        CommandBuffer->lastLoadStateCount -= 1
+
+#   define gcmVERIFYLOADSTATEDONE(CommandBuffer) \
+        gcmASSERT(CommandBuffer->lastLoadStateCount == 0)
+
+#else
+
+#   define gcmSTORELOADSTATE(CommandBuffer, Memory, Address, Count)
+#   define gcmVERIFYLOADSTATE(CommandBuffer, Memory, Address)
+#   define gcmVERIFYLOADSTATEDONE(CommandBuffer)
+
+#endif
+
+#if gcdSECURE_USER
+
+#   define gcmDEFINESECUREUSER() \
+        gctUINT         __secure_user_offset__; \
+        gctUINT32_PTR   __secure_user_hintArray__;
+
+#   define gcmBEGINSECUREUSER() \
+        __secure_user_offset__ = reserve->lastOffset; \
+        \
+        __secure_user_hintArray__ = reserve->hintArrayTail
+
+#   define gcmENDSECUREUSER() \
+        reserve->hintArrayTail = __secure_user_hintArray__
+
+#   define gcmSKIPSECUREUSER() \
+        __secure_user_offset__ += gcmSIZEOF(gctUINT32)
+
+#   define gcmUPDATESECUREUSER() \
+        *__secure_user_hintArray__ = __secure_user_offset__; \
+        \
+        __secure_user_offset__    += gcmSIZEOF(gctUINT32); \
+        __secure_user_hintArray__ += 1
+
+#else
+
+#   define gcmDEFINESECUREUSER()
+#   define gcmBEGINSECUREUSER()
+#   define gcmENDSECUREUSER()
+#   define gcmSKIPSECUREUSER()
+#   define gcmUPDATESECUREUSER()
+
+#endif
+
+/*----------------------------------------------------------------------------*/
+
+#if gcdDUMP
+#   define gcmDUMPSTATEDATA(StateDelta, FixedPoint, Address, Data) \
+        if (FixedPoint) \
+        { \
+            gcmDUMP(gcvNULL, "@[state.x 0x%04X 0x%08X]", \
+                Address, Data \
+                ); \
+        } \
+        else \
+        { \
+            gcmDUMP(gcvNULL, "@[state 0x%04X 0x%08X]", \
+                Address, Data \
+                ); \
+        }
+#else
+#   define gcmDUMPSTATEDATA(StateDelta, FixedPoint, Address, Data)
+#endif
+
+/*----------------------------------------------------------------------------*/
+
+#define gcmDEFINESTATEBUFFER(CommandBuffer, StateDelta, Memory, ReserveSize) \
+    gcmDEFINESECUREUSER() \
+    gctSIZE_T ReserveSize; \
+    gcoCMDBUF CommandBuffer; \
+    gctUINT32_PTR Memory; \
+    gcsSTATE_DELTA_PTR StateDelta
+
+#define gcmBEGINSTATEBUFFER(Hardware, CommandBuffer, StateDelta, Memory, ReserveSize) \
+{ \
+    gcmONERROR(gcoBUFFER_Reserve( \
+        Hardware->buffer, ReserveSize, gcvTRUE, &CommandBuffer \
+        )); \
+    \
+    Memory = (gctUINT32_PTR) CommandBuffer->lastReserve; \
+    \
+    StateDelta = Hardware->delta; \
+    \
+    gcmBEGINSECUREUSER(); \
+}
+
+#define gcmENDSTATEBUFFER(CommandBuffer, Memory, ReserveSize) \
+{ \
+    gcmENDSECUREUSER(); \
+    \
+    gcmASSERT( \
+        ((gctUINT8_PTR) CommandBuffer->lastReserve) + ReserveSize \
+        == \
+         (gctUINT8_PTR) Memory \
+        ); \
+}
+
+/*----------------------------------------------------------------------------*/
+
+#define gcmBEGINSTATEBATCH(CommandBuffer, Memory, FixedPoint, Address, Count) \
+{ \
+    gcmASSERT(((Memory - (gctUINT32_PTR) CommandBuffer->lastReserve) & 1) == 0); \
+    \
+    gcmVERIFYLOADSTATEDONE(CommandBuffer); \
+    \
+    gcmSTORELOADSTATE(CommandBuffer, Memory, Address, Count); \
+    \
+    *Memory++ \
+        = gcmSETFIELDVALUE(0, AQ_COMMAND_LOAD_STATE_COMMAND, OPCODE,  LOAD_STATE) \
+        | gcmSETFIELD     (0, AQ_COMMAND_LOAD_STATE_COMMAND, FLOAT,   FixedPoint) \
+        | gcmSETFIELD     (0, AQ_COMMAND_LOAD_STATE_COMMAND, COUNT,   Count) \
+        | gcmSETFIELD     (0, AQ_COMMAND_LOAD_STATE_COMMAND, ADDRESS, Address); \
+    \
+    gcmSKIPSECUREUSER(); \
+}
+
+#define gcmENDSTATEBATCH(CommandBuffer, Memory) \
+{ \
+    gcmVERIFYLOADSTATEDONE(CommandBuffer); \
+    \
+    gcmASSERT(((Memory - (gctUINT32_PTR) CommandBuffer->lastReserve) & 1) == 0); \
+}
+
+/*----------------------------------------------------------------------------*/
+
+#define gcmSETSTATEDATA(StateDelta, CommandBuffer, Memory, FixedPoint, \
+                        Address, Data) \
+{ \
+    gctUINT32 __temp_data32__; \
+    \
+    gcmVERIFYLOADSTATE(CommandBuffer, Memory, Address); \
+    \
+    __temp_data32__ = Data; \
+    \
+    *Memory++ = __temp_data32__; \
+    \
+    gcoHARDWARE_UpdateDelta( \
+        StateDelta, FixedPoint, Address, 0, __temp_data32__ \
+        ); \
+    \
+    gcmDUMPSTATEDATA(StateDelta, FixedPoint, Address, __temp_data32__); \
+    \
+    gcmUPDATESECUREUSER(); \
+}
+
+#define gcmSETCTRLSTATE(StateDelta, CommandBuffer, Memory, Address, Data) \
+{ \
+    gctUINT32 __temp_data32__; \
+    \
+    gcmVERIFYLOADSTATE(CommandBuffer, Memory, Address); \
+    \
+    __temp_data32__ = Data; \
+    \
+    *Memory++ = __temp_data32__; \
+    \
+    gcmDUMPSTATEDATA(StateDelta, gcvFALSE, Address, __temp_data32__); \
+    \
+    gcmSKIPSECUREUSER(); \
+}
+
+#define gcmSETFILLER(CommandBuffer, Memory) \
+{ \
+    gcmVERIFYLOADSTATEDONE(CommandBuffer); \
+    \
+    Memory += 1; \
+    \
+    gcmSKIPSECUREUSER(); \
+}
+
+/*----------------------------------------------------------------------------*/
+
+#define gcmSETSINGLESTATE(StateDelta, CommandBuffer, Memory, FixedPoint, \
+                          Address, Data) \
+{ \
+    gcmBEGINSTATEBATCH(CommandBuffer, Memory, FixedPoint, Address, 1); \
+    gcmSETSTATEDATA(StateDelta, CommandBuffer, Memory, FixedPoint, \
+                    Address, Data); \
+    gcmENDSTATEBATCH(CommandBuffer, Memory); \
+}
+
+#define gcmSETSINGLECTRLSTATE(StateDelta, CommandBuffer, Memory, FixedPoint, \
+                              Address, Data) \
+{ \
+    gcmBEGINSTATEBATCH(CommandBuffer, Memory, FixedPoint, Address, 1); \
+    gcmSETCTRLSTATE(StateDelta, CommandBuffer, Memory, Address, Data); \
+    gcmENDSTATEBATCH(CommandBuffer, Memory); \
+}
+
+
+/*******************************************************************************
+**
+**  gcmSETSTARTDECOMMAND
+**
+**      Form a START_DE command.
+**
+**  ARGUMENTS:
+**
+**      Memory          Destination memory pointer of gctUINT32_PTR type.
+**      Count           Number of the rectangles.
+*/
+
+#define gcmSETSTARTDECOMMAND(Memory, Count) \
+{ \
+    *Memory++ \
+        = gcmSETFIELDVALUE(0, AQ_COMMAND_START_DE_COMMAND, OPCODE,     START_DE) \
+        | gcmSETFIELD     (0, AQ_COMMAND_START_DE_COMMAND, COUNT,      Count) \
+        | gcmSETFIELD     (0, AQ_COMMAND_START_DE_COMMAND, DATA_COUNT, 0); \
+    \
+    *Memory++ = 0xDEADDEED; \
+}
+
+/******************************************************************************\
+******************************** Ceiling Macro ********************************
+\******************************************************************************/
+#define gcmCEIL(x) ((x - (gctUINT32)x) == 0 ? (gctUINT32)x : (gctUINT32)x + 1)
+
+/******************************************************************************\
+******************************** Min/Max Macros ********************************
+\******************************************************************************/
+
+#define gcmMIN(x, y)            (((x) <= (y)) ?  (x) :  (y))
+#define gcmMAX(x, y)            (((x) >= (y)) ?  (x) :  (y))
+#define gcmCLAMP(x, min, max)   (((x) < (min)) ? (min) : \
+                                 ((x) > (max)) ? (max) : (x))
+#define gcmABS(x)               (((x) < 0)    ? -(x) :  (x))
+#define gcmNEG(x)               (((x) < 0)    ?  (x) : -(x))
+
+/*******************************************************************************
+**
+**  gcmPTR2INT
+**
+**      Convert a pointer to an integer value.
+**
+**  ARGUMENTS:
+**
+**      p       Pointer value.
+*/
+#if defined(_WIN32) || (defined(__LP64__) && __LP64__)
+#   define gcmPTR2INT(p) \
+    ( \
+        (gctUINT32) (gctUINT64) (p) \
+    )
+#else
+#   define gcmPTR2INT(p) \
+    ( \
+        (gctUINT32) (p) \
+    )
+#endif
+
+/*******************************************************************************
+**
+**  gcmINT2PTR
+**
+**      Convert an integer value into a pointer.
+**
+**  ARGUMENTS:
+**
+**      v       Integer value.
+*/
+#ifdef __LP64__
+#   define gcmINT2PTR(i) \
+    ( \
+        (gctPOINTER) (gctINT64) (i) \
+    )
+#else
+#   define gcmINT2PTR(i) \
+    ( \
+        (gctPOINTER) (i) \
+    )
+#endif
+
+/*******************************************************************************
+**
+**  gcmOFFSETOF
+**
+**      Compute the byte offset of a field inside a structure.
+**
+**  ARGUMENTS:
+**
+**      s       Structure name.
+**      field   Field name.
+*/
+#define gcmOFFSETOF(s, field) \
+( \
+    gcmPTR2INT(& (((struct s *) 0)->field)) \
+)
+
+/*******************************************************************************
+***** Database ****************************************************************/
+
+typedef struct _gcsDATABASE_COUNTERS
+{
+    /* Number of currently allocated bytes. */
+    gctSIZE_T                   bytes;
+
+    /* Maximum number of bytes allocated (memory footprint). */
+    gctSIZE_T                   maxBytes;
+
+    /* Total number of bytes allocated. */
+    gctSIZE_T                   totalBytes;
+}
+gcsDATABASE_COUNTERS;
+
+typedef struct _gcuDATABASE_INFO
+{
+    /* Counters. */
+    gcsDATABASE_COUNTERS        counters;
+
+    /* Time value. */
+    gctUINT64                   time;
+}
+gcuDATABASE_INFO;
+
+/*******************************************************************************
+***** Frame database **********************************************************/
+
+/* gcsHAL_FRAME_INFO */
+typedef struct _gcsHAL_FRAME_INFO
+{
+    /* Current timer tick. */
+    OUT gctUINT64               ticks;
+
+    /* Bandwidth counters. */
+    OUT gctUINT                 readBytes8[8];
+    OUT gctUINT                 writeBytes8[8];
+
+    /* Counters. */
+    OUT gctUINT                 cycles[8];
+    OUT gctUINT                 idleCycles[8];
+    OUT gctUINT                 mcCycles[8];
+    OUT gctUINT                 readRequests[8];
+    OUT gctUINT                 writeRequests[8];
+
+    /* 3D counters. */
+    OUT gctUINT                 vertexCount;
+    OUT gctUINT                 primitiveCount;
+    OUT gctUINT                 rejectedPrimitives;
+    OUT gctUINT                 culledPrimitives;
+    OUT gctUINT                 clippedPrimitives;
+    OUT gctUINT                 outPrimitives;
+    OUT gctUINT                 inPrimitives;
+    OUT gctUINT                 culledQuadCount;
+    OUT gctUINT                 totalQuadCount;
+    OUT gctUINT                 quadCount;
+    OUT gctUINT                 totalPixelCount;
+
+    /* PE counters. */
+    OUT gctUINT                 colorKilled[8];
+    OUT gctUINT                 colorDrawn[8];
+    OUT gctUINT                 depthKilled[8];
+    OUT gctUINT                 depthDrawn[8];
+
+    /* Shader counters. */
+    OUT gctUINT                 shaderCycles;
+    OUT gctUINT                 vsInstructionCount;
+    OUT gctUINT                 vsTextureCount;
+    OUT gctUINT                 psInstructionCount;
+    OUT gctUINT                 psTextureCount;
+
+    /* Texture counters. */
+    OUT gctUINT                 bilinearRequests;
+    OUT gctUINT                 trilinearRequests;
+    OUT gctUINT                 txBytes8;
+    OUT gctUINT                 txHitCount;
+    OUT gctUINT                 txMissCount;
+}
+gcsHAL_FRAME_INFO;
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __gc_hal_types_h_ */
diff --git a/attic/gc_hal_version.h b/attic/gc_hal_version.h
new file mode 100644
index 0000000..83db422
--- /dev/null
+++ b/attic/gc_hal_version.h
@@ -0,0 +1,39 @@
+/****************************************************************************
+*
+*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*
+*    This program is free software; you can redistribute it and/or modify
+*    it under the terms of the GNU General Public License as published by
+*    the Free Software Foundation; either version 2 of the license, or
+*    (at your option) any later version.
+*
+*    This program is distributed in the hope that it will be useful,
+*    but WITHOUT ANY WARRANTY; without even the implied warranty of
+*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+*    GNU General Public License for more details.
+*
+*    You should have received a copy of the GNU General Public License
+*    along with this program; if not write to the Free Software
+*    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*
+*****************************************************************************/
+
+
+
+
+#ifndef __gc_hal_version_h_
+#define __gc_hal_version_h_
+
+#define gcvVERSION_MAJOR        4
+
+#define gcvVERSION_MINOR        6
+
+#define gcvVERSION_PATCH        6
+
+#define gcvVERSION_BUILD        1381
+
+#define gcvVERSION_DATE      __DATE__
+
+#define gcvVERSION_TIME      __TIME__
+
+#endif /* __gc_hal_version_h_ */
diff --git a/attic/gc_hal_vg.h b/attic/gc_hal_vg.h
new file mode 100644
index 0000000..2060170
--- /dev/null
+++ b/attic/gc_hal_vg.h
@@ -0,0 +1,933 @@
+/****************************************************************************
+*
+*    Copyright (C) 2005 - 2012 by Vivante Corp.
+*
+*    This program is free software; you can redistribute it and/or modify
+*    it under the terms of the GNU General Public License as published by
+*    the Free Software Foundation; either version 2 of the license, or
+*    (at your option) any later version.
+*
+*    This program is distributed in the hope that it will be useful,
+*    but WITHOUT ANY WARRANTY; without even the implied warranty of
+*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+*    GNU General Public License for more details.
+*
+*    You should have received a copy of the GNU General Public License
+*    along with this program; if not write to the Free Software
+*    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+*
+*****************************************************************************/
+
+
+
+
+
+
+#ifndef __gc_hal_vg_h_
+#define __gc_hal_vg_h_
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+#include "gc_hal_rename.h"
+#include "gc_hal_types.h"
+#include "gc_hal_enum.h"
+#include "gc_hal_base.h"
+
+#if gcdENABLE_VG
+
+/* Thread routine type. */
+#if defined(LINUX)
+    typedef gctINT              gctTHREADFUNCRESULT;
+    typedef gctPOINTER          gctTHREADFUNCPARAMETER;
+#   define  gctTHREADFUNCTYPE
+#elif defined(WIN32)
+    typedef gctUINT             gctTHREADFUNCRESULT;
+    typedef gctPOINTER          gctTHREADFUNCPARAMETER;
+#   define  gctTHREADFUNCTYPE   __stdcall
+#elif defined(__QNXNTO__)
+    typedef void *              gctTHREADFUNCRESULT;
+    typedef gctPOINTER          gctTHREADFUNCPARAMETER;
+#   define  gctTHREADFUNCTYPE
+#endif
+
+typedef gctTHREADFUNCRESULT (gctTHREADFUNCTYPE * gctTHREADFUNC) (
+    gctTHREADFUNCPARAMETER ThreadParameter
+    );
+
+
+#if defined(gcvDEBUG)
+#   undef gcvDEBUG
+#endif
+
+#define gcdFORCE_DEBUG 0
+#define gcdFORCE_MESSAGES 0
+
+
+#if DBG || defined(DEBUG) || defined(_DEBUG) || gcdFORCE_DEBUG
+#   define gcvDEBUG 1
+#else
+#   define gcvDEBUG 0
+#endif
+
+#define _gcmERROR_RETURN(prefix, func) \
+    status = func; \
+    if (gcmIS_ERROR(status)) \
+    { \
+        prefix##PRINT_VERSION(); \
+        prefix##TRACE(gcvLEVEL_ERROR, \
+            #prefix "ERR_RETURN: status=%d(%s) @ %s(%d)", \
+            status, gcoOS_DebugStatus2Name(status), __FUNCTION__, __LINE__); \
+        return status; \
+    } \
+    do { } while (gcvFALSE)
+
+#define gcmERROR_RETURN(func)         _gcmERROR_RETURN(gcm, func)
+
+#define gcmLOG_LOCATION()
+
+#define gcmkIS_ERROR(status)        (status < 0)
+
+#define gcmALIGNDOWN(n, align) \
+( \
+    (n) & ~((align) - 1) \
+)
+
+#define gcmIS_VALID_INDEX(Index, Array) \
+    (((gctUINT) (Index)) < gcmCOUNTOF(Array))
+
+
+#define gcmIS_NAN(x) \
+( \
+    ((* (gctUINT32_PTR) &(x)) & 0x7FFFFFFF) == 0x7FFFFFFF \
+)
+
+#define gcmLERP(v1, v2, w) \
+    ((v1) * (w) + (v2) * (1.0f - (w)))
+
+#define gcmINTERSECT(Start1, Start2, Length) \
+    (gcmABS((Start1) - (Start2)) < (Length))
+
+/*******************************************************************************
+**
+**  gcmERR_GOTO
+**
+**      Prints a message and terminates the current loop on error.
+**
+**  ASSUMPTIONS:
+**
+**      'status' variable of gceSTATUS type must be defined.
+**
+**  ARGUMENTS:
+**
+**      Function
+**          Function to evaluate.
+*/
+
+#define gcmERR_GOTO(Function) \
+    status = Function; \
+    if (gcmIS_ERROR(status)) \
+    { \
+        gcmTRACE( \
+            gcvLEVEL_ERROR, \
+            "gcmERR_GOTO: status=%d @ line=%d in function %s.\n", \
+            status, __LINE__, __FUNCTION__ \
+            ); \
+        goto ErrorHandler; \
+    }
+
+#if gcvDEBUG || gcdFORCE_MESSAGES
+#   define gcmVERIFY_BOOLEAN(Expression) \
+        gcmASSERT( \
+            ( (Expression) == gcvFALSE ) || \
+            ( (Expression) == gcvTRUE  )    \
+            )
+#else
+#   define gcmVERIFY_BOOLEAN(Expression)
+#endif
+
+/*******************************************************************************
+**
+**  gcmVERIFYFIELDFIT
+**
+**      Verify whether the value fits in the field.
+**
+**  ARGUMENTS:
+**
+**      data    Data value.
+**      reg     Name of register.
+**      field   Name of field within register.
+**      value   Value for field.
+*/
+#define gcmVERIFYFIELDFIT(reg, field, value) \
+    gcmASSERT( \
+        (value) <= gcmFIELDMAX(reg, field) \
+        )
+/*******************************************************************************
+**
+**  gcmFIELDMAX
+**
+**      Get field maximum value.
+**
+**  ARGUMENTS:
+**
+**      reg     Name of register.
+**      field   Name of field within register.
+*/
+#define gcmFIELDMAX(reg, field) \
+( \
+    (gctUINT32) \
+        ( \
+        (__gcmGETSIZE(reg##_##field) == 32) \
+                ?  ~0 \
+                : (~(~0 << __gcmGETSIZE(reg##_##field))) \
+        ) \
+)
+
+
+/* ANSI C does not have the 'f' functions, define replacements here. */
+#define gcmSINF(x)                      ((gctFLOAT) sin(x))
+#define gcmCOSF(x)                      ((gctFLOAT) cos(x))
+#define gcmASINF(x)                     ((gctFLOAT) asin(x))
+#define gcmACOSF(x)                     ((gctFLOAT) acos(x))
+#define gcmSQRTF(x)                     ((gctFLOAT) sqrt(x))
+#define gcmFABSF(x)                     ((gctFLOAT) fabs(x))
+#define gcmFMODF(x, y)                  ((gctFLOAT) fmod((x), (y)))
+#define gcmCEILF(x)                     ((gctFLOAT) ceil(x))
+#define gcmFLOORF(x)                    ((gctFLOAT) floor(x))
+
+
+
+/* Fixed point constants. */
+#define gcvZERO_X               ((gctFIXED_POINT) 0x00000000)
+#define gcvHALF_X               ((gctFIXED_POINT) 0x00008000)
+#define gcvONE_X                ((gctFIXED_POINT) 0x00010000)
+#define gcvNEGONE_X             ((gctFIXED_POINT) 0xFFFF0000)
+#define gcvTWO_X                ((gctFIXED_POINT) 0x00020000)
+
+/* Integer constants. */
+#define gcvMAX_POS_INT          ((gctINT) 0x7FFFFFFF)
+#define gcvMAX_NEG_INT          ((gctINT) 0x80000000)
+
+/* Float constants. */
+#define gcvMAX_POS_FLOAT        ((gctFLOAT)  3.4028235e+038)
+#define gcvMAX_NEG_FLOAT        ((gctFLOAT) -3.4028235e+038)
+
+/******************************************************************************\
+***************************** Miscellaneous Macro ******************************
+\******************************************************************************/
+
+#define gcmKB2BYTES(Kilobyte) \
+( \
+    (Kilobyte) << 10 \
+)
+
+#define gcmMB2BYTES(Megabyte) \
+( \
+    (Megabyte) << 20 \
+)
+
+#define gcmMAT(Matrix, Row, Column) \
+( \
+    (Matrix) [(Row) * 3 + (Column)] \
+)
+
+#define gcmMAKE2CHAR(Char1, Char2) \
+( \
+    ((gctUINT16) (gctUINT8) (Char1) << 0) | \
+    ((gctUINT16) (gctUINT8) (Char2) << 8) \
+)
+
+#define gcmMAKE4CHAR(Char1, Char2, Char3, Char4) \
+( \
+    ((gctUINT32)(gctUINT8) (Char1) <<  0) | \
+    ((gctUINT32)(gctUINT8) (Char2) <<  8) | \
+    ((gctUINT32)(gctUINT8) (Char3) << 16) | \
+    ((gctUINT32)(gctUINT8) (Char4) << 24) \
+)
+
+/* some platforms need to fix the physical address for HW to access*/
+#ifdef __QNXNTO__
+
+gcmINLINE static gctUINT32 _qnxFixAddress(gctUINT32 Address)
+{
+    gctUINT32 baseAddress = 0;
+
+    if (gcmIS_ERROR(gcoOS_GetBaseAddress(gcvNULL, &baseAddress)))
+    {
+        baseAddress = 0;
+    }
+
+    return Address + baseAddress;
+}
+
+#define gcmFIXADDRESS       _qnxFixAddress
+
+gcmINLINE static gctUINT32 _qnxkFixAddress(gctUINT32 Address)
+{
+    extern unsigned long baseAddress;
+    return Address + baseAddress;
+}
+
+#define gcmkFIXADDRESS      _qnxkFixAddress
+
+#else
+
+#define gcmFIXADDRESS(address) \
+(\
+    (address)\
+)
+
+#define gcmkFIXADDRESS(address) \
+(\
+    (address)\
+)
+
+#endif
+
+/******************************************************************************\
+****************************** Kernel Debug Macro ******************************
+\******************************************************************************/
+
+/* Set signal to signaled state for specified process. */
+gceSTATUS
+gckOS_SetSignal(
+    IN gckOS Os,
+    IN gctHANDLE Process,
+    IN gctSIGNAL Signal
+    );
+
+/* Return the kernel logical pointer for the given physical one. */
+gceSTATUS
+gckOS_GetKernelLogical(
+    IN gckOS Os,
+    IN gctUINT32 Address,
+    OUT gctPOINTER * KernelPointer
+    );
+
+/* Return the kernel logical pointer for the given physical one. */
+gceSTATUS
+gckOS_GetKernelLogicalEx(
+    IN gckOS Os,
+    IN gceCORE Core,
+    IN gctUINT32 Address,
+    OUT gctPOINTER * KernelPointer
+    );
+
+/*----------------------------------------------------------------------------*/
+/*----------------------------- Semaphore Object -----------------------------*/
+
+/* Increment the value of a semaphore. */
+gceSTATUS
+gckOS_IncrementSemaphore(
+    IN gckOS Os,
+    IN gctSEMAPHORE Semaphore
+    );
+
+/* Decrement the value of a semaphore (waiting might occur). */
+gceSTATUS
+gckOS_DecrementSemaphore(
+    IN gckOS Os,
+    IN gctSEMAPHORE Semaphore
+    );
+
+
+/*----------------------------------------------------------------------------*/
+/*------------------------------- Thread Object ------------------------------*/
+
+/* Start a thread. */
+gceSTATUS
+gckOS_StartThread(
+    IN gckOS Os,
+    IN gctTHREADFUNC ThreadFunction,
+    IN gctPOINTER ThreadParameter,
+    OUT gctTHREAD * Thread
+    );
+
+/* Stop a thread. */
+gceSTATUS
+gckOS_StopThread(
+    IN gckOS Os,
+    IN gctTHREAD Thread
+    );
+
+/* Verify whether the thread is still running. */
+gceSTATUS
+gckOS_VerifyThread(
+    IN gckOS Os,
+    IN gctTHREAD Thread
+    );
+
+
+/* Construct a new gckVGKERNEL object. */
+gceSTATUS
+gckVGKERNEL_Construct(
+    IN gckOS Os,
+    IN gctPOINTER Context,
+    IN gckKERNEL  inKernel,
+    OUT gckVGKERNEL * Kernel
+    );
+
+/* Destroy an gckVGKERNEL object. */
+gceSTATUS
+gckVGKERNEL_Destroy(
+    IN gckVGKERNEL Kernel
+    );
+
+/* Allocate linear video memory. */
+gceSTATUS
+gckKERNEL_AllocateLinearMemory(
+    IN gckKERNEL Kernel,
+    IN OUT gcePOOL * Pool,
+    IN gctSIZE_T Bytes,
+    IN gctSIZE_T Alignment,
+    IN gceSURF_TYPE Type,
+    OUT gcuVIDMEM_NODE_PTR * Node
+    );
+
+/* Unmap memory. */
+gceSTATUS
+gckKERNEL_UnmapMemory(
+    IN gckKERNEL Kernel,
+    IN gctPHYS_ADDR Physical,
+    IN gctSIZE_T Bytes,
+    IN gctPOINTER Logical
+    );
+
+/* Dispatch a user-level command. */
+gceSTATUS
+gckVGKERNEL_Dispatch(
+    IN gckKERNEL Kernel,
+    IN gctBOOL FromUser,
+    IN OUT struct _gcsHAL_INTERFACE * Interface
+    );
+
+/* Query command buffer requirements. */
+gceSTATUS
+gckKERNEL_QueryCommandBuffer(
+    IN gckKERNEL Kernel,
+    OUT gcsCOMMAND_BUFFER_INFO_PTR Information
+    );
+
+#if gcdDYNAMIC_MAP_RESERVED_MEMORY
+gceSTATUS
+gckOS_MapReservedMemoryToKernel(
+    IN gckOS Os,
+    IN gctUINT32 Physical,
+    IN gctINT Bytes,
+    IN OUT gctPOINTER *Virtual
+    );
+
+gceSTATUS
+gckOS_UnmapReservedMemoryFromKernel(
+    IN gctPOINTER Virtual
+    );
+#endif
+
+/******************************************************************************\
+******************************* gckVGHARDWARE Object ******************************
+\******************************************************************************/
+
+/* Construct a new gckVGHARDWARE object. */
+gceSTATUS
+gckVGHARDWARE_Construct(
+    IN gckOS Os,
+    OUT gckVGHARDWARE * Hardware
+    );
+
+/* Destroy an gckVGHARDWARE object. */
+gceSTATUS
+gckVGHARDWARE_Destroy(
+    IN gckVGHARDWARE Hardware
+    );
+
+/* Query system memory requirements. */
+gceSTATUS
+gckVGHARDWARE_QuerySystemMemory(
+    IN gckVGHARDWARE Hardware,
+    OUT gctSIZE_T * SystemSize,
+    OUT gctUINT32 * SystemBaseAddress
+    );
+
+/* Build virtual address. */
+gceSTATUS
+gckVGHARDWARE_BuildVirtualAddress(
+    IN gckVGHARDWARE Hardware,
+    IN gctUINT32 Index,
+    IN gctUINT32 Offset,
+    OUT gctUINT32 * Address
+    );
+
+/* Kickstart the command processor. */
+gceSTATUS
+gckVGHARDWARE_Execute(
+    IN gckVGHARDWARE Hardware,
+    IN gctUINT32 Address,
+    IN gctSIZE_T Count
+    );
+
+/* Query the available memory. */
+gceSTATUS
+gckVGHARDWARE_QueryMemory(
+    IN gckVGHARDWARE Hardware,
+    OUT gctSIZE_T * InternalSize,
+    OUT gctUINT32 * InternalBaseAddress,
+    OUT gctUINT32 * InternalAlignment,
+    OUT gctSIZE_T * ExternalSize,
+    OUT gctUINT32 * ExternalBaseAddress,
+    OUT gctUINT32 * ExternalAlignment,
+    OUT gctUINT32 * HorizontalTileSize,
+    OUT gctUINT32 * VerticalTileSize
+    );
+
+/* Query the identity of the hardware. */
+gceSTATUS
+gckVGHARDWARE_QueryChipIdentity(
+    IN gckVGHARDWARE Hardware,
+    OUT gceCHIPMODEL* ChipModel,
+    OUT gctUINT32* ChipRevision,
+    OUT gctUINT32* ChipFeatures,
+    OUT gctUINT32* ChipMinorFeatures,
+    OUT gctUINT32* ChipMinorFeatures1
+    );
+
+/* Convert an API format. */
+gceSTATUS
+gckVGHARDWARE_ConvertFormat(
+    IN gckVGHARDWARE Hardware,
+    IN gceSURF_FORMAT Format,
+    OUT gctUINT32 * BitsPerPixel,
+    OUT gctUINT32 * BytesPerTile
+    );
+
+/* Split a harwdare specific address into API stuff. */
+gceSTATUS
+gckVGHARDWARE_SplitMemory(
+    IN gckVGHARDWARE Hardware,
+    IN gctUINT32 Address,
+    OUT gcePOOL * Pool,
+    OUT gctUINT32 * Offset
+    );
+
+/* Align size to tile boundary. */
+gceSTATUS
+gckVGHARDWARE_AlignToTile(
+    IN gckVGHARDWARE Hardware,
+    IN gceSURF_TYPE Type,
+    IN OUT gctUINT32_PTR Width,
+    IN OUT gctUINT32_PTR Height
+    );
+
+/* Convert logical address to hardware specific address. */
+gceSTATUS
+gckVGHARDWARE_ConvertLogical(
+    IN gckVGHARDWARE Hardware,
+    IN gctPOINTER Logical,
+    OUT gctUINT32 * Address
+    );
+
+/* Program MMU. */
+gceSTATUS
+gckVGHARDWARE_SetMMU(
+    IN gckVGHARDWARE Hardware,
+    IN gctPOINTER Logical
+    );
+
+/* Flush the MMU. */
+gceSTATUS
+gckVGHARDWARE_FlushMMU(
+    IN gckVGHARDWARE Hardware
+    );
+
+/* Get idle register. */
+gceSTATUS
+gckVGHARDWARE_GetIdle(
+    IN gckVGHARDWARE Hardware,
+    OUT gctUINT32 * Data
+    );
+
+/* Flush the caches. */
+gceSTATUS
+gckVGHARDWARE_Flush(
+    IN gckVGHARDWARE Hardware,
+    IN gceKERNEL_FLUSH Flush,
+    IN gctPOINTER Logical,
+    IN OUT gctSIZE_T * Bytes
+    );
+
+/* Enable/disable fast clear. */
+gceSTATUS
+gckVGHARDWARE_SetFastClear(
+    IN gckVGHARDWARE Hardware,
+    IN gctINT Enable
+    );
+
+gceSTATUS
+gckVGHARDWARE_ReadInterrupt(
+    IN gckVGHARDWARE Hardware,
+    OUT gctUINT32_PTR IDs
+    );
+
+/* Power management. */
+gceSTATUS
+gckVGHARDWARE_SetPowerManagementState(
+    IN gckVGHARDWARE Hardware,
+    IN gceCHIPPOWERSTATE State
+    );
+
+gceSTATUS
+gckVGHARDWARE_QueryPowerManagementState(
+    IN gckVGHARDWARE Hardware,
+    OUT gceCHIPPOWERSTATE* State
+    );
+
+gceSTATUS
+gckVGHARDWARE_SetPowerOffTimeout(
+    IN gckVGHARDWARE  Hardware,
+    IN gctUINT32    Timeout
+    );
+
+gceSTATUS
+gckVGHARDWARE_QueryPowerOffTimeout(
+    IN gckVGHARDWARE  Hardware,
+    OUT gctUINT32*  Timeout
+    );
+
+gceSTATUS
+gckVGHARDWARE_QueryIdle(
+    IN gckVGHARDWARE Hardware,
+    OUT gctBOOL_PTR IsIdle
+    );
+/******************************************************************************\
+*************************** Command Buffer Structures **************************
+\******************************************************************************/
+
+/* Vacant command buffer marker. */
+#define gcvVACANT_BUFFER        ((gcsCOMPLETION_SIGNAL_PTR) (1))
+
+/* Command buffer header. */
+typedef struct _gcsCMDBUFFER * gcsCMDBUFFER_PTR;
+typedef struct _gcsCMDBUFFER
+{
+    /* Pointer to the completion signal. */
+    gcsCOMPLETION_SIGNAL_PTR    completion;
+
+    /* The user sets this to the node of the container buffer whitin which
+       this particular command buffer resides. The kernel sets this to the
+       node of the internally allocated buffer. */
+    gcuVIDMEM_NODE_PTR          node;
+
+    /* Command buffer hardware address. */
+    gctUINT32                   address;
+
+    /* The offset of the buffer from the beginning of the header. */
+    gctUINT32                   bufferOffset;
+
+    /* Size of the area allocated for the data portion of this particular
+       command buffer (headers and tail reserves are excluded). */
+    gctSIZE_T                   size;
+
+    /* Offset into the buffer [0..size]; reflects exactly how much data has
+       been put into the command buffer. */
+    gctUINT                     offset;
+
+    /* The number of command units in the buffer for the hardware to
+       execute. */
+    gctSIZE_T                   dataCount;
+
+    /* MANAGED BY : user HAL (gcoBUFFER object).
+       USED BY    : user HAL (gcoBUFFER object).
+       Points to the immediate next allocated command buffer. */
+    gcsCMDBUFFER_PTR            nextAllocated;
+
+    /* MANAGED BY : user layers (HAL and drivers).
+       USED BY    : kernel HAL (gcoBUFFER object).
+       Points to the next subbuffer if any. A family of subbuffers are chained
+       together and are meant to be executed inseparably as a unit. Meaning
+       that context switching cannot occur while a chain of subbuffers is being
+       executed. */
+    gcsCMDBUFFER_PTR            nextSubBuffer;
+}
+gcsCMDBUFFER;
+
+/* Command queue element. */
+typedef struct _gcsVGCMDQUEUE
+{
+    /* Pointer to the command buffer header. */
+    gcsCMDBUFFER_PTR            commandBuffer;
+
+    /* Dynamic vs. static command buffer state. */
+    gctBOOL                     dynamic;
+}
+gcsVGCMDQUEUE;
+
+/* Context map entry. */
+typedef struct _gcsVGCONTEXT_MAP
+{
+    /* State index. */
+    gctUINT32                   index;
+
+    /* New state value. */
+    gctUINT32                   data;
+
+    /* Points to the next entry in the mod list. */
+    gcsVGCONTEXT_MAP_PTR            next;
+}
+gcsVGCONTEXT_MAP;
+
+/* gcsVGCONTEXT structure that holds the current context. */
+typedef struct _gcsVGCONTEXT
+{
+    /* Context ID. */
+    gctUINT64                   id;
+
+    /* State caching ebable flag. */
+    gctBOOL                     stateCachingEnabled;
+
+    /* Current pipe. */
+    gctUINT32                   currentPipe;
+
+    /* State map/mod buffer. */
+    gctSIZE_T                   mapFirst;
+    gctSIZE_T                   mapLast;
+#ifdef __QNXNTO__
+    gctSIZE_T                   mapContainerSize;
+#endif
+    gcsVGCONTEXT_MAP_PTR            mapContainer;
+    gcsVGCONTEXT_MAP_PTR            mapPrev;
+    gcsVGCONTEXT_MAP_PTR            mapCurr;
+    gcsVGCONTEXT_MAP_PTR            firstPrevMap;
+    gcsVGCONTEXT_MAP_PTR            firstCurrMap;
+
+    /* Main context buffer. */
+    gcsCMDBUFFER_PTR            header;
+    gctUINT32_PTR               buffer;
+
+    /* Completion signal. */
+    gctHANDLE                   process;
+    gctSIGNAL                   signal;
+
+#if defined(__QNXNTO__)
+    gctINT32                    coid;
+    gctINT32                    rcvid;
+#endif
+}
+gcsVGCONTEXT;
+
+/* User space task header. */
+typedef struct _gcsTASK * gcsTASK_PTR;
+typedef struct _gcsTASK
+{
+    /* Pointer to the next task for the same interrupt in user space. */
+    gcsTASK_PTR                 next;
+
+    /* Size of the task data that immediately follows the structure. */
+    gctUINT                     size;
+
+    /* Task data starts here. */
+    /* ... */
+}
+gcsTASK;
+
+/* User space task master table entry. */
+typedef struct _gcsTASK_MASTER_ENTRY * gcsTASK_MASTER_ENTRY_PTR;
+typedef struct _gcsTASK_MASTER_ENTRY
+{
+    /* Pointers to the head and to the tail of the task chain. */
+    gcsTASK_PTR                 head;
+    gcsTASK_PTR                 tail;
+}
+gcsTASK_MASTER_ENTRY;
+
+/* User space task master table entry. */
+typedef struct _gcsTASK_MASTER_TABLE
+{
+    /* Table with one entry per block. */
+    gcsTASK_MASTER_ENTRY        table[gcvBLOCK_COUNT];
+
+    /* The total number of tasks sckeduled. */
+    gctUINT                     count;
+
+    /* The total size of event data in bytes. */
+    gctUINT                     size;
+
+#if defined(__QNXNTO__)
+    gctINT32                    coid;
+    gctINT32                    rcvid;
+#endif
+}
+gcsTASK_MASTER_TABLE;
+
+/******************************************************************************\
+***************************** gckVGINTERRUPT Object ******************************
+\******************************************************************************/
+
+typedef struct _gckVGINTERRUPT * gckVGINTERRUPT;
+
+typedef gceSTATUS (* gctINTERRUPT_HANDLER)(
+    IN gckVGKERNEL Kernel
+    );
+
+gceSTATUS
+gckVGINTERRUPT_Construct(
+    IN gckVGKERNEL Kernel,
+    OUT gckVGINTERRUPT * Interrupt
+    );
+
+gceSTATUS
+gckVGINTERRUPT_Destroy(
+    IN gckVGINTERRUPT Interrupt
+    );
+
+gceSTATUS
+gckVGINTERRUPT_Enable(
+    IN gckVGINTERRUPT Interrupt,
+    IN OUT gctINT32_PTR Id,
+    IN gctINTERRUPT_HANDLER Handler
+    );
+
+gceSTATUS
+gckVGINTERRUPT_Disable(
+    IN gckVGINTERRUPT Interrupt,
+    IN gctINT32 Id
+    );
+
+#ifndef __QNXNTO__
+
+gceSTATUS
+gckVGINTERRUPT_Enque(
+    IN gckVGINTERRUPT Interrupt
+    );
+
+#else
+
+gceSTATUS
+gckVGINTERRUPT_Enque(
+    IN gckVGINTERRUPT Interrupt,
+    OUT gckOS *Os,
+    OUT gctSEMAPHORE *Semaphore
+    );
+
+#endif
+
+gceSTATUS
+gckVGINTERRUPT_DumpState(
+    IN gckVGINTERRUPT Interrupt
+    );
+
+
+/******************************************************************************\
+******************************* gckVGCOMMAND Object *******************************
+\******************************************************************************/
+
+typedef struct _gckVGCOMMAND *      gckVGCOMMAND;
+
+/* Construct a new gckVGCOMMAND object. */
+gceSTATUS
+gckVGCOMMAND_Construct(
+    IN gckVGKERNEL Kernel,
+    IN gctUINT TaskGranularity,
+    IN gctUINT QueueSize,
+    OUT gckVGCOMMAND * Command
+    );
+
+/* Destroy an gckVGCOMMAND object. */
+gceSTATUS
+gckVGCOMMAND_Destroy(
+    IN gckVGCOMMAND Command
+    );
+
+/* Query command buffer attributes. */
+gceSTATUS
+gckVGCOMMAND_QueryCommandBuffer(
+    IN gckVGCOMMAND Command,
+    OUT gcsCOMMAND_BUFFER_INFO_PTR Information
+    );
+
+/* Allocate a command queue. */
+gceSTATUS
+gckVGCOMMAND_Allocate(
+    IN gckVGCOMMAND Command,
+    IN gctSIZE_T Size,
+    OUT gcsCMDBUFFER_PTR * CommandBuffer,
+    OUT gctPOINTER * Data
+    );
+
+/* Release memory held by the command queue. */
+gceSTATUS
+gckVGCOMMAND_Free(
+    IN gckVGCOMMAND Command,
+    IN gcsCMDBUFFER_PTR CommandBuffer
+    );
+
+/* Schedule the command queue for execution. */
+gceSTATUS
+gckVGCOMMAND_Execute(
+    IN gckVGCOMMAND Command,
+    IN gcsCMDBUFFER_PTR CommandBuffer
+    );
+
+/* Commit a buffer to the command queue. */
+gceSTATUS
+gckVGCOMMAND_Commit(
+    IN gckVGCOMMAND Command,
+    IN gcsVGCONTEXT_PTR Context,
+    IN gcsVGCMDQUEUE_PTR Queue,
+    IN gctUINT EntryCount,
+    IN gcsTASK_MASTER_TABLE_PTR TaskTable
+    );
+
+/******************************************************************************\
+********************************* gckVGMMU Object ********************************
+\******************************************************************************/
+
+typedef struct _gckVGMMU *          gckVGMMU;
+
+/* Construct a new gckVGMMU object. */
+gceSTATUS
+gckVGMMU_Construct(
+    IN gckVGKERNEL Kernel,
+    IN gctSIZE_T MmuSize,
+    OUT gckVGMMU * Mmu
+    );
+
+/* Destroy an gckVGMMU object. */
+gceSTATUS
+gckVGMMU_Destroy(
+    IN gckVGMMU Mmu
+    );
+
+/* Allocate pages inside the MMU. */
+gceSTATUS
+gckVGMMU_AllocatePages(
+    IN gckVGMMU Mmu,
+    IN gctSIZE_T PageCount,
+    OUT gctPOINTER * PageTable,
+    OUT gctUINT32 * Address
+    );
+
+/* Remove a page table from the MMU. */
+gceSTATUS
+gckVGMMU_FreePages(
+    IN gckVGMMU Mmu,
+    IN gctPOINTER PageTable,
+    IN gctSIZE_T PageCount
+    );
+
+/* Set the MMU page with info. */
+gceSTATUS
+gckVGMMU_SetPage(
+   IN gckVGMMU Mmu,
+   IN gctUINT32 PageAddress,
+   IN gctUINT32 *PageEntry
+   );
+
+#endif /* gcdENABLE_VG */
+
+#ifdef __cplusplus
+} /* extern "C" */
+#endif
+
+#endif /* __gc_hal_h_ */
